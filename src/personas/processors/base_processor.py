#!/usr/bin/env python3
"""
Base processor class for all AI personas
Provides common functionality for processing work items and generating outputs
"""

import os
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
from pathlib import Path

class BaseProcessor:
    """Base class for all persona processors"""
    
    def __init__(self, output_directory: str):
        """Initialize the base processor
        
        Args:
            output_directory: Directory to store processor outputs
        """
        self.output_directory = Path(output_directory)
        self.output_directory.mkdir(parents=True, exist_ok=True)
        
        self.logger = logging.getLogger(self.__class__.__name__)
        self.persona_name = self.__class__.__name__.replace('Processor', '').replace('Bot', '')
        
        # Initialize logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
    
    async def process_work_item(self, work_item: Any) -> Dict[str, Any]:
        """Process a work item - to be implemented by subclasses
        
        Args:
            work_item: The work item to process
            
        Returns:
            Dictionary containing processing results
        """
        raise NotImplementedError("Subclasses must implement process_work_item")
    
    def _get_output_path(self, filename: str, subfolder: str = None) -> Path:
        """Get full path for an output file
        
        Args:
            filename: Name of the output file
            subfolder: Optional subfolder within output directory
            
        Returns:
            Full path to the output file
        """
        if subfolder:
            path = self.output_directory / subfolder
            path.mkdir(parents=True, exist_ok=True)
            return path / filename
        else:
            return self.output_directory / filename
    
    def _save_output(self, content: str, filename: str, subfolder: str = None) -> str:
        """Save content to an output file
        
        Args:
            content: Content to save
            filename: Name of the output file
            subfolder: Optional subfolder within output directory
            
        Returns:
            Full path to the saved file
        """
        output_path = self._get_output_path(filename, subfolder)
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            self.logger.info(f"Saved output to {output_path}")
            return str(output_path)
            
        except Exception as e:
            self.logger.error(f"Failed to save output to {output_path}: {e}")
            raise
    
    def _create_output_metadata(self, output_type: str, filename: str, 
                               description: str = None, **kwargs) -> Dict[str, Any]:
        """Create metadata for an output file
        
        Args:
            output_type: Type of output (e.g., 'architecture', 'security')
            filename: Name of the output file
            description: Optional description of the output
            **kwargs: Additional metadata fields
            
        Returns:
            Dictionary containing output metadata
        """
        metadata = {
            'type': output_type,
            'name': filename,
            'path': str(self._get_output_path(filename, kwargs.get('subfolder'))),
            'created_at': datetime.now().isoformat(),
            'created_by': self.persona_name,
            'description': description or f"{output_type} generated by {self.persona_name}"
        }
        
        # Add any additional metadata
        metadata.update(kwargs)
        
        return metadata
    
    def _generate_summary(self, outputs: List[Dict[str, Any]]) -> str:
        """Generate a summary of processing results
        
        Args:
            outputs: List of output metadata dictionaries
            
        Returns:
            Summary string
        """
        summary_lines = [
            f"Processing completed by {self.persona_name}",
            f"Generated {len(outputs)} output(s):",
            ""
        ]
        
        for i, output in enumerate(outputs, 1):
            summary_lines.append(f"{i}. {output.get('type', 'Unknown')}: {output.get('name', 'Unnamed')}")
            if output.get('description'):
                summary_lines.append(f"   - {output['description']}")
        
        return "\n".join(summary_lines)
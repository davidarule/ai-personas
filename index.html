<!DOCTYPE html>
<html>
<head>
    <title>AI Persona Control Center</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#3b82f6',
                primaryTextColor: '#fff',
                primaryBorderColor: '#2563eb',
                lineColor: '#64748b',
                secondaryColor: '#8b5cf6',
                tertiaryColor: '#10b981'
            }
        });
    </script>
    <style>
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            margin: 0; 
            padding: 0;
            background: #0a0a0a;
            color: #e0e0e0;
        }
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            gap: 15px;
        }
        h1 { margin: 0; font-size: 1.8em; }
        .real-api-badge {
            background: #22c55e;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 10px;
        }
        
        .header-status-container {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        
        .header-status-box {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
        }
        
        #azureDevopsBox {
            min-width: 380px;
        }
        
        .header-status-box:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: translateY(-1px);
        }
        
        .header-status-box.online {
            border-color: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        
        .header-status-box.offline {
            border-color: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
        }
        
        .header-status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .header-status-light.online {
            background: #22c55e;
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
        }
        
        .header-status-light.offline {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
        }
        
        .header-status-label {
            font-size: 1.1em;
            font-weight: 500;
            color: white;
        }
        
        .header-status-info {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1.1em;
            color: #e0e0e0;
        }
        
        .azure-stats-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95em;
        }
        
        .azure-stats-container span {
            color: #94d3ff;
        }
        
        .azure-stats-container .separator {
            color: #666;
        }
        
        .azure-stat-clickable {
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .azure-stat-clickable:hover {
            color: #ffffff;
            text-decoration: underline;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        button:hover { background: #2563eb; }
        button:disabled { background: #6b7280; cursor: not-allowed; }
        
        /* Save button states */
        button.save-btn {
            background: #6b7280; /* Grey by default */
            transition: background-color 0.3s ease;
        }
        button.save-btn:hover {
            filter: brightness(1.1);
        }
        button.save-btn.has-changes {
            background: #22c55e; /* Green when there are changes */
        }
        button.save-btn.has-changes:hover {
            background: #16a34a;
        }
        
        /* Primary button */
        .btn-primary {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: #4a5568;
            color: white;
            border: none;
            padding: 8px 16px;  /* Updated to match btn-primary */
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;     /* Updated to match btn-primary */
            transition: background-color 0.3s ease;
        }
        
        .btn-secondary:hover {
            background: #5a6578;
        }
        
        /* Test connection button state */
        .btn-secondary.has-changes {
            background: #22c55e; /* Green when API key changed */
        }
        .btn-secondary.has-changes:hover {
            background: #16a34a;
        }
        
        .btn-icon {
            background: transparent;
            color: #999;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-icon:hover {
            background: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        
        /* Workflow styles */
        .workflows-container {
            max-height: none;
            overflow-y: visible;
            padding-right: 10px;
        }
        
        .workflows-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .workflows-container::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        .workflows-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        .workflows-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .workflow-section {
            margin-bottom: 30px;
        }
        
        .workflow-section-header {
            background: #1e293b;
            padding: 12px 20px;
            border-radius: 8px 8px 0 0;
            border: 1px solid #334155;
            border-bottom: none;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .workflow-section-header:hover {
            background: #263445;
        }
        
        .workflow-section.collapsed .workflow-section-header {
            border-radius: 8px;
            border-bottom: 1px solid #334155;
        }
        
        .workflow-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #e2e8f0;
            margin: 0;
        }
        
        .workflow-section-count {
            background: #334155;
            color: #94a3b8;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 14px;
        }
        
        .workflow-section-content {
            background: #1a1a1a;
            border: 1px solid #334155;
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 15px;
            min-height: 100px;
            transition: all 0.3s ease;
        }
        
        .workflow-section.collapsed .workflow-section-content {
            display: none;
        }
        
        .workflow-section-toggle {
            font-size: 16px;
            color: #999;
            margin-left: 10px;
            display: inline-block;
            min-width: 20px;
        }
        
        .workflow-section-empty {
            color: #666;
            text-align: center;
            padding: 30px;
            font-style: italic;
        }
        
        .workflow-item {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Add specific spacing for Core workflow items to prevent overlap */
        #coreWorkflows .workflow-item {
            margin-bottom: 25px;
            position: relative;
        }
        
        /* Add a subtle separator after each workflow item except the last */
        #coreWorkflows .workflow-item:not(:last-child)::after {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 1px;
            background: linear-gradient(to right, transparent, #444, transparent);
        }
        
        .workflow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .workflow-header:hover .workflow-name {
            color: #3b82f6;
        }
        
        .workflow-toggle {
            font-size: 16px;
            color: #999;
            margin-left: 10px;
            display: inline-block;
            min-width: 20px;
        }
        
        .workflow-info {
            flex: 1;
        }
        
        .workflow-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .workflow-description {
            color: #ccc;
            font-size: 13px;
            line-height: 1.4;
            max-height: 600px;
            overflow-y: auto;
            margin-top: 8px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #333;
            display: none;
        }
        
        .workflow-description.expanded {
            display: block;
        }
        
        /* Style code blocks within workflow descriptions */
        .workflow-description code {
            background: #0a0a0a;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
            color: #58a6ff;
        }
        
        .workflow-description pre {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .workflow-description h2 {
            color: #fff;
            font-size: 16px;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        
        .workflow-description h3 {
            color: #e0e0e0;
            font-size: 14px;
            margin-top: 8px;
            margin-bottom: 5px;
        }
        
        .workflow-description strong {
            color: #fff;
        }
        
        .workflow-description ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        
        .workflow-description li {
            margin: 3px 0;
            list-style-type: disc;
        }
        
        /* Additional markdown styles */
        .workflow-description p {
            margin: 5px 0;
        }
        
        .workflow-description pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .workflow-description code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .workflow-description pre code {
            display: block;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #58a6ff;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .workflow-description::-webkit-scrollbar {
            width: 8px;
        }
        
        .workflow-description::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .workflow-description::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        .workflow-description::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .workflow-actions {
            display: flex;
            gap: 10px;
        }
        
        .workflow-btn {
            background: none;
            border: 1px solid #3b82f6;
            color: #3b82f6;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        
        .workflow-btn:hover {
            background: #3b82f6;
            color: #fff;
        }
        
        .workflow-btn.delete {
            border-color: #dc2626;
            color: #dc2626;
        }
        
        .workflow-btn.delete:hover {
            background: #dc2626;
            color: white;
        }
        
        /* Textarea styles */
        textarea {
            resize: vertical;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            padding: 10px;
        }
        
        textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        /* Test Connection button states */
        button.test-btn {
            transition: background-color 0.3s ease;
        }
        button.test-btn.no-pat {
            background: #6b7280; /* Grey when no PAT */
            cursor: not-allowed;
        }
        button.test-btn.new-pat {
            background: #22c55e; /* Green when new PAT entered */
        }
        button.test-btn.new-pat:hover {
            background: #16a34a;
        }
        button.test-btn.existing-pat {
            background: #3b82f6; /* Blue when existing PAT available */
        }
        button.test-btn.existing-pat:hover {
            background: #2563eb;
        }
        
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }
        
        .sidebar {
            width: 500px;
            background: #111;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }
        
        .persona-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .persona-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .persona-card:hover {
            border-color: #3b82f6;
            transform: translateX(5px);
        }
        .persona-card.selected {
            border-color: #3b82f6;
            background: #1e293b;
        }
        
        .persona-type-card:hover {
            border: 1px solid #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.2);
        }
        
        .persona-type-card .delete-button {
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .persona-type-card:hover .delete-button {
            opacity: 1;
        }
        
        .persona-type-card .delete-button:hover {
            background: rgba(239, 68, 68, 0.1) !important;
            color: #f87171 !important;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        /* Updated color scheme per user requirements */
        .status-stopped { background: #ef4444; } /* Red = Stopped */
        .status-idle { background: #3b82f6; }    /* Blue = Idle */
        .status-working { background: #22c55e; animation: pulse 2s infinite; } /* Green = Working */
        .status-error { background: #f59e0b; }   /* Yellow = Errored */
        .status-blocked { background: #f59e0b; } /* Yellow = Blocked */
        .status-not_implemented { background: #6b7280; } /* Gray = Not Implemented */
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .content {
            flex: 1;
            padding: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .stat-card[onclick]:hover {
            background: #2a2a2a;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .stat-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #3b82f6;
            margin-top: 5px;
        }
        
        .stat-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .status-light.online {
            background: #22c55e;
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
        }
        
        .status-light.offline {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }
        
        .stat-number {
            font-size: 1.2em;
            font-weight: bold;
            color: #e0e0e0;
        }
        
        .factory-control-btn {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 20px;
            transition: color 0.2s;
        }
        
        .factory-control-btn:hover {
            color: #3b82f6;
        }
        
        .factory-control-btn:disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .azure-stats {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.2em;
        }
        
        .azure-stat-clickable {
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .azure-stat-clickable:hover {
            color: #3b82f6;
        }
        
        #mainContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .log-viewer {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            overflow-y: auto;
            min-height: 0; /* Allow flex shrinking */
        }
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid #222;
        }
        .log-entry.error { color: #ef4444; }
        .log-entry.warning { color: #f59e0b; }
        .log-entry.info { color: #3b82f6; }
        .log-entry.success { color: #22c55e; }
        .log-entry.debug { color: #6b7280; }
        .log-entry.verbose { color: #4b5563; }
        
        .filter-btn {
            padding: 5px 12px;
            margin: 2px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .filter-btn:hover { background: #3a3a3a; }
        .filter-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }
        
        .work-item {
            background: #1a1a1a;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #333;
        }
        .work-item.pending { border-left: 3px solid #f59e0b; }
        .work-item.processing { border-left: 3px solid #3b82f6; }
        .work-item.completed { border-left: 3px solid #22c55e; }
        
        .legend {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.8em;
            margin-top: 10px;
        }
        .legend h4 {
            margin: 0 0 10px 0;
            color: #3b82f6;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        /* Toggle switch styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: 0.4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background-color: #22c55e;
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* Project warning indicator */
        .project-warning {
            display: none;
            margin-right: 15px;
            padding: 5px 10px;
            background: #f59e0b;
            color: white;
            border-radius: 4px;
            font-size: 0.85em;
            cursor: help;
            align-items: center;
            gap: 5px;
        }
        
        .project-warning.visible {
            display: inline-flex;
        }
        
        .project-warning-icon {
            font-size: 1.2em;
            font-weight: bold;
            margin-right: 2px;
        }
        
        .project-item {
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .project-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .project-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .team-setup-link {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #f59e0b;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .team-setup-link.visible {
            display: block;
        }
        
        .team-setup-link a {
            color: #3b82f6;
            text-decoration: none;
        }
        
        .team-setup-link a:hover {
            text-decoration: underline;
        }
        
        /* Settings message close button */
        .message-close {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.8);
            padding: 0 5px;
        }
        
        .message-close:hover {
            color: white;
        }
        
        #settingsMessage {
            position: relative;
            padding-right: 35px;
        }
        
        /* Tab styles */
        .settings-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .tab-button {
            background: transparent;
            color: #888;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab-button:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #ccc;
        }
        
        .tab-button.active {
            color: #3b82f6;
            background: transparent;
            border-bottom-color: #3b82f6;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            background-color: #1a1a1a;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .modal-header h2 {
            margin: 0;
            color: #3b82f6;
        }
        
        .close-button {
            font-size: 28px;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            line-height: 20px;
            transition: color 0.3s;
        }
        
        .close-button:hover {
            color: #fff;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            max-width: 100%;
            padding: 8px 12px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 1em;
            box-sizing: border-box;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .btn-save,
        .btn-cancel {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        
        .btn-save {
            background: #3b82f6;
            color: white;
        }
        
        .btn-save:hover {
            background: #2563eb;
        }
        
        .btn-cancel {
            background: #444;
            color: #e0e0e0;
        }
        
        .btn-cancel:hover {
            background: #555;
        }
        
        /* Skills tag styles */
        .skills-container {
            margin-top: 10px;
        }
        
        .skills-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
        }
        
        .skill-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: #1e293b;
            border: 1px solid #3b82f6;
            border-radius: 15px;
            color: #e0e0e0;
            font-size: 0.9em;
        }
        
        .skill-tag .remove-skill {
            cursor: pointer;
            color: #888;
            font-weight: bold;
            transition: color 0.2s;
        }
        
        .skill-tag .remove-skill:hover {
            color: #ef4444;
        }
        
        .add-skill-container {
            display: flex;
            gap: 10px;
        }
        
        .add-skill-input {
            flex: 1;
            padding: 8px 12px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 1em;
        }
        
        .add-skill-btn {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        
        .add-skill-btn:hover {
            background: #2563eb;
        }
        
        /* Agent-specific styles */
        .provider-section {
            transition: all 0.3s ease;
        }
        
        .model-card {
            transition: all 0.2s ease;
        }
        
        .model-card:hover {
            background: #222 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .tag {
            white-space: nowrap;
        }
        
        /* Highlight selected models */
        .model-card:has(input:checked) {
            border-color: #3b82f6 !important;
            background: #1e293b !important;
        }
        
        /* Save button states */
        .btn-save.has-changes {
            background: #22c55e !important;
            animation: pulse 2s infinite;
        }
        
        .btn-save.has-changes:hover {
            background: #16a34a !important;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        .workflow-save-btn.has-changes {
            background: #22c55e !important;
            animation: pulse 2s infinite;
        }
        
        .workflow-save-btn.has-changes:hover {
            background: #16a34a !important;
        }
        
        .persona-type-save-btn.has-changes {
            background: #22c55e !important;
            animation: pulse 2s infinite;
        }
        
        .persona-type-save-btn.has-changes:hover {
            background: #16a34a !important;
        }
        
        /* Icon buttons */
        .btn-icon {
            background: transparent;
            border: 1px solid #444;
            color: #888;
            padding: 5px 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-left: 5px;
        }
        
        .btn-icon:hover {
            background: #2a2a2a;
            color: #fff;
            border-color: #666;
        }
        
        .btn-icon i {
            font-size: 12px;
        }
        
        /* Workflow section collapsed state */
        .workflow-section-content.collapsed {
            display: none;
        }
        
        /* Edit Persona Instance Styles */
        .edit-persona-instance-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .edit-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .persona-type-badge {
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
        }
        
        .status-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .metric-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .metric-item label {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #3b82f6;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>AI Persona Control Center</h1>
        
        <div class="header-status-container">
            <div id="aiPersonasBox" class="header-status-box offline" onclick="toggleFactory()">
                <div id="aiPersonasStatusLight" class="header-status-light offline"></div>
                <div class="header-status-label">AI Personas</div>
                <div class="header-status-info">
                    <span id="headerActivePersonas">0</span>
                </div>
            </div>
            
            <div id="apiBackendBox" class="header-status-box offline" onclick="toggleAPI()">
                <div id="apiBackendStatusLight" class="header-status-light offline"></div>
                <div class="header-status-label">API Backend</div>
            </div>
            
            <div id="azureDevopsBox" class="header-status-box offline">
                <div id="azureDevopsStatusLight" class="header-status-light offline"></div>
                <div class="header-status-label">Azure DevOps</div>
                <div class="azure-stats-container">
                    <span class="azure-stat-clickable" onclick="showWorkQueue()">Working: <span id="headerWorkQueue">0</span></span>
                    <span class="separator">|</span>
                    <span class="azure-stat-clickable" onclick="showCompletedItems()">Completed: <span id="headerCompleted">0</span></span>
                    <span class="separator">|</span>
                    <span>Total: <span id="headerTotal">0</span></span>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="showSystemLogs()">&#9776; System Logs</button>
            <button onclick="refreshData()">&#8635; Refresh</button>
            <button onclick="showSettings()">&#9881; Settings</button>
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <h3>AI Personas</h3>
            <div id="personaList" class="persona-list"></div>
            
            <button onclick="showCreatePersonaModal()" style="width: 100%; margin: 10px 0; background: #3b82f6;">
                <span style="font-size: 16px;">&plus;</span> Persona
            </button>
            
            <div class="legend">
                <h4>Status Legend</h4>
                <div class="legend-item">
                    <div class="legend-color status-stopped"></div>
                    <span>Stopped</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-idle"></div>
                    <span>Idle</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-working"></div>
                    <span>Working</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-error"></div>
                    <span>Error/Blocked</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-not_implemented"></div>
                    <span>Not Implemented</span>
                </div>
            </div>
        </div>
        
        <div class="content">
            
            <div id="mainContent">
                <!-- Dynamic content goes here -->
            </div>
        </div>
    </div>
    
    <!-- js-yaml library for YAML parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    
    <script>
        let selectedPersona = null;
        let factoryRunning = false;
        let apiRunning = false;
        const API_BASE = 'http://localhost:8080';
        
        // Unsaved changes tracking for persona type edit
        let personaTypeHasUnsavedChanges = false;
        let personaTypeOriginalData = null;
        
        // Workflow versions storage (in-memory for now, could be persisted)
        let workflowVersionHistory = {};
        
        // Default persona configurations with comprehensive skills
        const defaultPersonaConfigs = {
            'steve': {
                firstName: 'Steve',
                lastName: 'Bot',
                email: 'steve.bot@insitec.com.au',
                role: 'System Architect',
                skills: 'Cloud platform expertise (AWS / Azure / GCP), Microservices architecture design, Configuration management tools mastery, Containerization and orchestration (Docker / Kubernetes), CI/CD pipeline architecture, Performance optimization strategies, Security architecture and compliance, Networking protocols and architecture, Monitoring and logging architecture (CloudWatch / ELK), Scripting and automation, API design and management, Event-driven architecture, Domain-driven design (DDD), Distributed systems design, Database architecture (SQL/NoSQL), Caching strategies, Load balancing and scalability patterns, Disaster recovery planning, Technical documentation, Cost optimization strategies'
            },
            'kav': {
                firstName: 'Kav',
                lastName: 'Bot', 
                email: 'kav.bot@insitec.com.au',
                role: 'Test Engineer',
                skills: 'Test planning and strategy development, Test case design and execution, Manual testing methodologies, Test automation framework development, Integration testing, System testing, Regression testing, User acceptance testing (UAT), Performance and load testing, Compatibility testing, Localization and internationalization testing, Test data generation and management, Defect lifecycle management, Test environment setup and configuration, Test metrics and reporting, Root cause analysis, Test documentation and standards, Continuous testing implementation, Risk-based testing approaches, Compliance and regulatory testing'
            },
            'lachlan': {
                firstName: 'Lachlan',
                lastName: 'Bot',
                email: 'lachlan.bot@insitec.com.au',
                role: 'DevSecOps Engineer',
                skills: 'Threat modeling and risk assessment, Vulnerability management and security testing, CI/CD pipeline automation (Jenkins / GitLab CI), Infrastructure as Code (Terraform / CloudFormation), Container security (Docker / Kubernetes), Cloud security principles and architecture, Compliance frameworks (PCI-DSS / HIPAA / GDPR), Python and PowerShell scripting, Secure coding practices implementation, Security monitoring and incident response, Configuration management (Ansible / Puppet / Chef), SAST/DAST/IAST tool implementation, Secrets management (HashiCorp Vault / AWS Secrets Manager), Security orchestration and automation (SOAR), Zero-trust architecture implementation, API security and testing, Network security and segmentation, Cloud-native security tools, Security metrics and KPI tracking, DevSecOps toolchain integration, Security policy automation, Supply chain security management, Security awareness training delivery, Compliance automation, Security incident documentation'
            },
            'dave': {
                firstName: 'Dave',
                lastName: 'Bot',
                email: 'dave.bot@insitec.com.au',
                role: 'Security Engineer',
                skills: 'Security architecture design, Penetration testing, Security incident response, Identity and access management (IAM), Encryption and key management, Security compliance auditing, SIEM tool management, Forensic analysis, Security awareness training, Vulnerability scanning, Web application firewall (WAF) management, DDoS protection, Security policy development, Third-party risk assessment, Security automation scripting'
            },
            'jordan': {
                firstName: 'Jordan',
                lastName: 'Bot',
                email: 'jordan.bot@insitec.com.au',
                role: 'Backend Developer',
                skills: 'Server-side programming (Node.js / Python / Java / Go), RESTful API design and development, Database design and optimization, SQL and NoSQL databases, Authentication and authorization (OAuth / JWT), Microservices architecture, Message queue systems, Caching strategies, Server security best practices, API documentation, GraphQL server implementation, WebSocket server development, Cloud services integration, Containerization with Docker, CI/CD pipeline setup, Logging and monitoring, Performance tuning, Unit and integration testing, ORM/ODM frameworks, Event-driven architecture'
            },
            'puck': {
                firstName: 'Puck',
                lastName: 'Bot',
                email: 'puck.bot@insitec.com.au',
                role: 'Developer',
                skills: 'Multiple programming languages (Python / Java / Go / Ruby), Version control (Git / GitFlow), Test-driven development (TDD), Behavior-driven development (BDD), Infrastructure as Code (Terraform / Ansible), Container development (Docker), API development and RESTful services, Database programming (SQL/NoSQL), Unit testing and code coverage, Code review practices, Secure coding standards (OWASP), Debugging and profiling, Design patterns implementation, Agile/Scrum methodologies, Continuous integration practices, Feature flagging, Performance optimization, Dependency management, Documentation writing, GraphQL development, WebSocket programming, Reactive programming, Event streaming (Kafka / RabbitMQ), Mobile development (iOS/Android), Frontend frameworks (React / Angular / Vue)'
            },
            'moby': {
                firstName: 'Moby',
                lastName: 'Bot',
                email: 'moby.bot@insitec.com.au',
                role: 'Mobile Developer',
                skills: 'iOS development (Swift / SwiftUI), Android development (Kotlin / Jetpack Compose), Cross-platform frameworks (React Native / Flutter), Mobile UI/UX design principles, Responsive layouts and adaptive design, Mobile app architecture patterns (MVC / MVVM / MVP), RESTful API integration, Push notifications implementation, Offline data synchronization, Mobile security best practices, App store optimization (ASO), Mobile testing and debugging, Performance optimization, Device feature integration (camera / GPS / sensors), Mobile analytics implementation, Deep linking and app indexing, In-app purchases and monetization, Mobile CI/CD pipelines, Code signing and certificates, Accessibility features'
            },
            'shaun': {
                firstName: 'Shaun',
                lastName: 'Bot',
                email: 'shaun.bot@insitec.com.au',
                role: 'UI/UX Designer',
                skills: 'User research and persona development, Information architecture design, Wireframing and prototyping, Visual design and typography, Interaction design and microinteractions, Usability testing and analysis, Design systems and component libraries, Responsive and adaptive design, Accessibility standards (WCAG compliance), User journey mapping, A/B testing and optimization, Design thinking methodology, Color theory and psychology, Grid systems and layout design, Motion design and animations, Mobile-first design principles, Cross-platform design consistency, Heuristic evaluation, Card sorting and tree testing, Competitive analysis and benchmarking, Design sprint facilitation, Stakeholder presentation and communication, Design documentation and handoff, Conversion rate optimization (CRO), Brand identity and guidelines'
            },
            'matt': {
                firstName: 'Matt',
                lastName: 'Bot',
                email: 'matt.bot@insitec.com.au',
                role: 'Frontend Developer',
                skills: 'HTML5/CSS3 mastery, JavaScript ES6+ expertise, React/Angular/Vue.js frameworks, Responsive web design, CSS preprocessors (SASS / LESS), State management (Redux / MobX / Vuex), Progressive Web Apps (PWA), Web accessibility (WCAG standards), Cross-browser compatibility, Performance optimization (lazy loading / code splitting), TypeScript proficiency, REST API integration, GraphQL client implementation, Web animations and transitions, CSS frameworks (Bootstrap / Tailwind), Build tools (Webpack / Vite / Parcel), Testing (Jest / Cypress / Testing Library), Version control with Git, UI/UX design principles, SEO optimization'
            },
            'laureen': {
                firstName: 'Laureen',
                lastName: 'Bot',
                email: 'laureen.bot@insitec.com.au',
                role: 'Technical Writer',
                skills: 'API documentation expertise (OpenAPI / Swagger), Markdown and AsciiDoc proficiency, Version control systems (Git / GitHub), API testing tools (Postman / Insomnia), Documentation automation tools, CI/CD pipeline integration for docs, Agile documentation methodologies, Developer documentation writing, User guide creation, Release notes compilation, Video tutorial creation, Diagram and flowchart creation, Style guide development, Content management systems, Command-line documentation'
            },
            'brumbie': {
                firstName: 'Brumbie',
                lastName: 'Bot',
                email: 'brumbie.bot@insitec.com.au',
                role: 'Project Manager',
                skills: 'Product backlog management and prioritization, Customer advocacy and needs analysis, Stakeholder management and alignment, Product goal development and communication, User story creation and refinement, Business value optimization, Agile planning and forecasting, Market analysis and competitive intelligence, DevOps culture understanding, Data-driven decision making, Release planning and coordination, Customer feedback integration, ROI analysis and measurement, Sprint goal definition, Acceptance criteria definition'
            },
            'ruley': {
                firstName: 'Ruley',
                lastName: 'Bot',
                email: 'ruley.bot@insitec.com.au',
                role: 'Requirements Analyst',
                skills: 'Requirements gathering techniques, Requirements documentation and specification, Requirements traceability management, Functional and non-functional requirements analysis, Requirements validation and verification, Use case modeling, User journey mapping, Prototyping and wireframing, Requirements prioritization (MoSCoW / Kano), Requirements change management, Requirements review and approval processes, Test case derivation from requirements, Domain knowledge acquisition, Conflict resolution and negotiation, Requirements metrics and reporting, Regulatory and compliance requirements, Requirements modeling (UML / SysML), Requirements risk analysis'
            },
            'claude': {
                firstName: 'Claude',
                lastName: 'Bot',
                email: 'claude.bot@insitec.com.au',
                role: 'AI Engineer',
                skills: 'Machine learning algorithms and theory, Deep learning frameworks (TensorFlow / PyTorch), Natural language processing (NLP), Computer vision techniques, Neural network architecture design, Model training and optimization, Feature engineering and selection, Data preprocessing and augmentation, Model deployment and serving, MLOps practices and pipelines, Reinforcement learning, Transfer learning and fine-tuning, Model evaluation and validation, Hyperparameter tuning, Distributed training, Edge AI and model compression, Ethical AI and bias detection, Time series analysis and forecasting, Generative AI and LLMs, Vector databases and embeddings'
            }
        };
        
        // Load persona configurations from localStorage or use defaults
        let personaConfigs = JSON.parse(localStorage.getItem('ai_personas_config')) || defaultPersonaConfigs;
        
        // Default tools for each role
        const roleToolsMapping = {
            'System Architect': {
                'Design & Modeling': ['Draw.io', 'Lucidchart', 'Microsoft Visio', 'PlantUML', 'Mermaid'],
                'Enterprise Architecture': ['ArchiMate', 'TOGAF tools', 'Enterprise Architect', 'IBM Rational'],
                'Documentation': ['Confluence', 'Notion', 'Wiki tools', 'SharePoint'],
                'Cloud Architecture': ['AWS Well-Architected Tool', 'CloudCraft', 'Cloudockit'],
                'API Management': ['Kong', 'Apigee', 'AWS API Gateway', 'Swagger/OpenAPI'],
                'Service Mesh': ['Istio', 'Linkerd', 'Consul'],
                'Message Queues': ['RabbitMQ', 'Kafka', 'AWS SQS', 'Azure Service Bus'],
                'Caching': ['Redis', 'Memcached', 'Hazelcast'],
                'Performance Testing': ['JMeter', 'K6', 'Gatling', 'LoadRunner'],
                'Monitoring': ['Datadog', 'New Relic', 'AppDynamics'],
                'Diagramming': ['C4 Model tools', 'UML tools'],
                'Cost Analysis': ['AWS Cost Explorer', 'CloudHealth', 'Apptio']
            },
            'Test Engineer': {
                'Web Automation': ['Selenium', 'Cypress', 'Playwright', 'WebdriverIO'],
                'Testing Frameworks': ['Jest', 'Mocha', 'Jasmine', 'TestNG', 'pytest'],
                'API Testing': ['Postman', 'REST Assured', 'SoapUI', 'Newman'],
                'Performance Testing': ['JMeter', 'Gatling', 'K6', 'LoadRunner'],
                'Mobile Testing': ['Appium', 'XCTest', 'Espresso', 'Detox'],
                'Cross-Browser': ['BrowserStack', 'Sauce Labs', 'LambdaTest'],
                'BDD Tools': ['Cucumber', 'SpecFlow', 'Behave'],
                'Test Management': ['TestRail', 'Zephyr', 'TestLink', 'PractiTest'],
                'Bug Tracking': ['Jira', 'Bugzilla', 'Azure DevOps'],
                'Network Tools': ['Charles Proxy', 'Fiddler', 'Wireshark'],
                'Security Testing': ['OWASP ZAP', 'Burp Suite'],
                'Reporting': ['Allure', 'ExtentReports', 'ReportPortal'],
                'CI/CD': ['Jenkins', 'GitLab CI', 'GitHub Actions'],
                'Monitoring': ['Grafana', 'Kibana', 'Datadog']
            },
            'DevSecOps Engineer': {
                'CI/CD': ['Jenkins', 'GitLab CI', 'GitHub Actions', 'CircleCI', 'Azure DevOps'],
                'IaC': ['Terraform', 'CloudFormation', 'Pulumi', 'Ansible', 'Puppet', 'Chef'],
                'Containers': ['Docker', 'Kubernetes', 'OpenShift', 'Helm'],
                'Security Scanning': ['SonarQube', 'Checkmarx', 'Veracode', 'OWASP ZAP', 'Burp Suite'],
                'Vulnerability Scanning': ['Trivy', 'Clair', 'Anchore', 'Nessus', 'Qualys'],
                'Secret Management': ['HashiCorp Vault', 'AWS Secrets Manager', 'Azure Key Vault'],
                'Container Security': ['Aqua Security', 'Twistlock', 'Sysdig', 'Falco'],
                'Monitoring': ['Splunk', 'ELK Stack', 'Datadog', 'Prometheus', 'Grafana'],
                'Version Control': ['Git', 'GitLab', 'GitHub', 'Bitbucket'],
                'Artifact Management': ['Nexus', 'JFrog Artifactory', 'Harbor'],
                'Policy Management': ['Open Policy Agent (OPA)', 'Rego'],
                'SIEM': ['Splunk Enterprise Security', 'QRadar', 'ArcSight']
            },
            'Security Engineer': {
                'Penetration Testing': ['Metasploit', 'Kali Linux', 'Cobalt Strike'],
                'Web Security': ['Burp Suite', 'OWASP ZAP', 'Acunetix'],
                'Vulnerability Scanning': ['Nessus', 'OpenVAS', 'Qualys'],
                'Network Analysis': ['Wireshark', 'tcpdump', 'nmap'],
                'SIEM': ['Splunk', 'QRadar', 'ArcSight', 'Elastic Security'],
                'Endpoint Security': ['CrowdStrike', 'Carbon Black', 'SentinelOne'],
                'Secret Management': ['HashiCorp Vault', 'AWS KMS', 'CyberArk'],
                'Identity Management': ['Okta', 'Auth0', 'Ping Identity'],
                'WAF': ['CloudFlare', 'AWS WAF', 'ModSecurity'],
                'IDS/IPS': ['Snort', 'Suricata'],
                'Password Cracking': ['John the Ripper', 'Hashcat'],
                'Forensics': ['EnCase', 'FTK', 'Autopsy'],
                'Code Security': ['Git-secrets', 'TruffleHog'],
                'Compliance': ['Chef InSpec', 'AWS Config']
            },
            'Backend Developer': {
                'Frameworks': ['Express', 'NestJS', 'Django', 'Flask', 'Spring Boot', '.NET Core'],
                'Databases': ['PostgreSQL', 'MySQL', 'MongoDB', 'DynamoDB', 'Redis'],
                'Caching': ['Redis', 'Memcached', 'ElasticSearch'],
                'Message Queues': ['RabbitMQ', 'Kafka', 'NATS', 'AWS SQS'],
                'Containers': ['Docker', 'Kubernetes', 'Docker Swarm'],
                'API Testing': ['Postman', 'Insomnia', 'Thunder Client'],
                'API Documentation': ['Swagger', 'OpenAPI', 'API Blueprint'],
                'Process Managers': ['PM2', 'Forever', 'Supervisor'],
                'Logging': ['Winston', 'Morgan', 'Bunyan', 'Log4j'],
                'Monitoring': ['New Relic', 'AppDynamics', 'Datadog'],
                'Testing': ['Jest', 'Mocha', 'pytest', 'JUnit'],
                'ORMs': ['Sequelize', 'Prisma', 'TypeORM', 'SQLAlchemy'],
                'Web Servers': ['nginx', 'Apache', 'HAProxy'],
                'Version Control': ['Git', 'GitHub', 'GitLab']
            },
            'Developer': {
                'IDEs': ['VS Code', 'IntelliJ IDEA', 'Eclipse', 'WebStorm'],
                'Version Control': ['Git', 'GitHub', 'GitLab', 'Bitbucket'],
                'Containers': ['Docker', 'Docker Compose', 'Podman'],
                'Build Tools': ['Maven', 'Gradle', 'npm', 'yarn', 'Make'],
                'Testing': ['JUnit', 'pytest', 'Jest', 'Mocha', 'Jasmine'],
                'Code Quality': ['SonarQube', 'ESLint', 'Prettier', 'PMD'],
                'API Testing': ['Postman', 'Insomnia', 'curl', 'REST Assured'],
                'Databases': ['MongoDB', 'PostgreSQL', 'MySQL', 'Redis'],
                'Message Queues': ['Kafka', 'RabbitMQ', 'AWS SQS'],
                'CI/CD': ['Jenkins', 'CircleCI', 'Travis CI', 'GitHub Actions'],
                'Project Management': ['Jira', 'Azure DevOps', 'Linear'],
                'Documentation': ['Swagger', 'GraphQL Playground'],
                'Debugging': ['Chrome DevTools', 'React DevTools'],
                'Feature Flags': ['LaunchDarkly', 'Unleash']
            },
            'Mobile Developer': {
                'IDEs': ['Xcode', 'Android Studio', 'VS Code'],
                'Cross-Platform': ['React Native CLI', 'Expo', 'Flutter SDK'],
                'Languages': ['Swift', 'Kotlin', 'Dart', 'JavaScript'],
                'Dependency Management': ['CocoaPods', 'Swift Package Manager', 'Gradle'],
                'Backend Services': ['Firebase', 'AWS Amplify', 'Supabase'],
                'Crash Reporting': ['Crashlytics', 'Bugsnag', 'Sentry'],
                'Testing Platforms': ['TestFlight', 'Google Play Console'],
                'Testing Tools': ['Appium', 'XCTest', 'Espresso', 'Detox'],
                'Debugging': ['Charles Proxy', 'Flipper', 'React Native Debugger'],
                'CI/CD': ['Fastlane', 'Bitrise', 'Codemagic', 'App Center'],
                'Analytics': ['Firebase Analytics', 'Mixpanel', 'Amplitude'],
                'Database': ['Realm', 'SQLite', 'Core Data'],
                'API Testing': ['Postman', 'Paw'],
                'Performance': ['Instruments (iOS)', 'Android Profiler']
            },
            'UI/UX Designer': {
                'Design': ['Figma', 'Sketch', 'Adobe XD'],
                'Adobe Suite': ['Photoshop', 'Illustrator', 'After Effects'],
                'Prototyping': ['Framer', 'Principle', 'ProtoPie'],
                'Collaboration': ['InVision', 'Marvel', 'Proto.io'],
                'Whiteboarding': ['Miro', 'Mural', 'FigJam'],
                'User Testing': ['UserTesting', 'Maze', 'UsabilityHub'],
                'Analytics': ['Hotjar', 'FullStory', 'Crazy Egg'],
                'Research': ['Optimal Workshop', 'Treejack', 'OptimalSort'],
                'Handoff': ['Zeplin', 'Avocode', 'Abstract'],
                'Wireframing': ['Whimsical', 'Balsamiq', 'Wireframe.cc'],
                'Typography': ['Adobe Fonts', 'Google Fonts'],
                'Color': ['Coolors', 'Adobe Color'],
                'Animation': ['Lottie', 'Rive', 'Spline'],
                'Web Design': ['Webflow', 'Framer Sites'],
                'Documentation': ['Notion', 'Confluence'],
                'Component Libraries': ['Storybook'],
                'Accessibility': ['WAVE', 'axe DevTools']
            },
            'Frontend Developer': {
                'IDEs': ['VS Code', 'WebStorm', 'Sublime Text'],
                'Frameworks': ['React', 'Angular', 'Vue.js', 'Svelte', 'Next.js'],
                'State Management': ['Redux', 'MobX', 'Zustand', 'Recoil', 'Vuex'],
                'Build Tools': ['Webpack', 'Vite', 'Parcel', 'Rollup'],
                'Package Managers': ['npm', 'yarn', 'pnpm'],
                'Testing': ['Jest', 'Mocha', 'Jasmine', 'Vitest', 'Cypress', 'Playwright'],
                'Component Development': ['Storybook', 'Bit'],
                'Design Collaboration': ['Figma', 'Adobe XD', 'Sketch', 'Zeplin'],
                'Dev Tools': ['Chrome DevTools', 'React DevTools', 'Vue DevTools'],
                'Performance': ['Lighthouse', 'PageSpeed Insights', 'WebPageTest'],
                'CSS Tools': ['PostCSS', 'Autoprefixer', 'Sass', 'Less'],
                'Linting': ['ESLint', 'Prettier', 'Stylelint'],
                'Version Control': ['Git', 'GitHub', 'GitLab'],
                'CSS Frameworks': ['Bootstrap', 'Tailwind CSS', 'Material-UI']
            },
            'Technical Writer': {
                'Authoring': ['MadCap Flare', 'Adobe FrameMaker', 'Oxygen XML'],
                'Documentation Platforms': ['Confluence', 'SharePoint', 'Wiki.js', 'Notion'],
                'Markdown Editors': ['Typora', 'Mark Text', 'VS Code'],
                'Version Control': ['Git', 'GitHub', 'GitLab'],
                'API Documentation': ['Swagger UI', 'Redoc', 'Slate', 'Postman'],
                'Diagramming': ['Draw.io', 'Lucidchart', 'Visio', 'PlantUML'],
                'Screen Capture': ['Snagit', 'Camtasia', 'OBS Studio', 'Loom'],
                'Grammar': ['Grammarly', 'Hemingway Editor'],
                'Static Site Generators': ['Jekyll', 'Hugo', 'Docusaurus', 'MkDocs'],
                'Documentation Hosting': ['ReadMe', 'GitBook', 'GitHub Pages'],
                'Structured Authoring': ['DITA', 'DocBook', 'AsciiDoc'],
                'Project Tracking': ['Jira', 'Azure DevOps'],
                'Code Editors': ['VS Code', 'Atom']
            },
            'Project Manager': {
                'Project Management': ['Jira', 'Azure DevOps', 'Rally', 'Monday.com'],
                'Roadmapping': ['ProductPlan', 'Roadmunk', 'Aha!'],
                'Documentation': ['Confluence', 'Notion', 'Coda'],
                'Collaboration': ['Miro', 'Mural', 'Figma'],
                'Analytics': ['Google Analytics', 'Mixpanel', 'Amplitude'],
                'User Research': ['Hotjar', 'FullStory', 'Crazy Egg'],
                'Communication': ['Slack', 'Microsoft Teams'],
                'Feedback Management': ['UserVoice', 'Canny', 'ProductBoard'],
                'Data Visualization': ['Tableau', 'Power BI', 'Looker'],
                'Survey Tools': ['SurveyMonkey', 'Typeform'],
                'A/B Testing': ['Optimizely', 'VWO', 'Google Optimize'],
                'Task Management': ['Trello', 'Asana'],
                'Spreadsheets': ['Excel', 'Google Sheets'],
                'Prototyping': ['Balsamiq', 'Sketch', 'Adobe XD']
            },
            'Requirements Analyst': {
                'Requirements Management': ['IBM DOORS', 'Jama Connect', 'ReqView', 'ReqSuite'],
                'Modeling': ['Enterprise Architect', 'MagicDraw'],
                'Project Management': ['Jira', 'Azure DevOps'],
                'Documentation': ['Confluence', 'SharePoint'],
                'Diagramming': ['Lucidchart', 'Microsoft Visio'],
                'Prototyping': ['Balsamiq', 'Mockplus', 'Figma'],
                'Spreadsheets': ['Excel Requirements Management'],
                'Task Management': ['Trello', 'Monday.com'],
                'UML Tools': ['PlantUML', 'yEd'],
                'Mind Mapping': ['XMind', 'MindMeister'],
                'Word Processing': ['MS Word', 'Google Docs'],
                'Requirements Tools': ['Rational RequisitePro', 'Caliber', 'Helix RM'],
                'Version Control': ['Git']
            },
            'AI Engineer': {
                'ML Frameworks': ['TensorFlow', 'PyTorch', 'JAX', 'Keras'],
                'ML Libraries': ['Scikit-learn', 'XGBoost', 'LightGBM'],
                'Development': ['Jupyter Notebook', 'Google Colab', 'VS Code'],
                'MLOps': ['MLflow', 'Weights & Biases', 'Neptune', 'Kubeflow'],
                'Workflow': ['Apache Airflow', 'Prefect', 'Dagster'],
                'Containers': ['Docker', 'Kubernetes'],
                'GPU Tools': ['CUDA', 'cuDNN', 'TensorRT'],
                'NLP': ['Hugging Face Transformers', 'spaCy', 'NLTK'],
                'Computer Vision': ['OpenCV', 'Pillow', 'scikit-image'],
                'Cloud ML': ['AWS SageMaker', 'Azure ML', 'Google Vertex AI'],
                'Distributed Training': ['Ray', 'Horovod', 'DeepSpeed'],
                'Model Deployment': ['ONNX', 'TensorFlow Lite', 'TorchServe'],
                'LLM Tools': ['LangChain', 'LlamaIndex', 'Ollama'],
                'Vector Databases': ['Pinecone', 'Weaviate', 'Milvus']
            },
            'AI Integration': {
                'ML Frameworks': ['TensorFlow', 'PyTorch', 'JAX', 'Keras'],
                'ML Libraries': ['Scikit-learn', 'XGBoost', 'LightGBM'],
                'Development': ['Jupyter Notebook', 'Google Colab', 'VS Code'],
                'MLOps': ['MLflow', 'Weights & Biases', 'Neptune', 'Kubeflow'],
                'Workflow': ['Apache Airflow', 'Prefect', 'Dagster'],
                'Containers': ['Docker', 'Kubernetes'],
                'GPU Tools': ['CUDA', 'cuDNN', 'TensorRT'],
                'NLP': ['Hugging Face Transformers', 'spaCy', 'NLTK'],
                'Computer Vision': ['OpenCV', 'Pillow', 'scikit-image'],
                'Cloud ML': ['AWS SageMaker', 'Azure ML', 'Google Vertex AI'],
                'Distributed Training': ['Ray', 'Horovod', 'DeepSpeed'],
                'Model Deployment': ['ONNX', 'TensorFlow Lite', 'TorchServe'],
                'LLM Tools': ['LangChain', 'LlamaIndex', 'Ollama'],
                'Vector Databases': ['Pinecone', 'Weaviate', 'Milvus']
            }
        };
        
        async function fetchAPI(endpoint, options = {}) {
            try {
                const response = await fetch(`${API_BASE}${endpoint}`, options);
                if (!response.ok) {
                    // Try to get error message from response
                    let errorMessage = `API error: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.message) {
                            errorMessage = errorData.message;
                        }
                    } catch (e) {
                        // Response wasn't JSON, use default message
                    }
                    throw new Error(errorMessage);
                }
                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }
        
        async function updateDashboard() {
            try {
                // Get header elements
                const apiBackendBox = document.getElementById('apiBackendBox');
                const apiBackendStatusLight = document.getElementById('apiBackendStatusLight');
                const aiPersonasBox = document.getElementById('aiPersonasBox');
                const aiPersonasStatusLight = document.getElementById('aiPersonasStatusLight');
                const azureDevopsBox = document.getElementById('azureDevopsBox');
                const azureDevopsStatusLight = document.getElementById('azureDevopsStatusLight');
                
                try {
                    // Get factory status
                    const status = await fetchAPI('/api/status');
                    
                    // API is online if we got a response
                    apiRunning = true;
                    apiBackendBox.classList.remove('offline');
                    apiBackendBox.classList.add('online');
                    apiBackendStatusLight.classList.remove('offline');
                    apiBackendStatusLight.classList.add('online');
                    
                    factoryRunning = status.factory_running;
                    
                    // Update factory status
                    if (factoryRunning) {
                        aiPersonasBox.classList.remove('offline');
                        aiPersonasBox.classList.add('online');
                        aiPersonasStatusLight.classList.remove('offline');
                        aiPersonasStatusLight.classList.add('online');
                    } else {
                        aiPersonasBox.classList.remove('online');
                        aiPersonasBox.classList.add('offline');
                        aiPersonasStatusLight.classList.remove('online');
                        aiPersonasStatusLight.classList.add('offline');
                    }
                    
                    // Update active personas number
                    document.getElementById('headerActivePersonas').textContent = status.active_personas;
                    
                    // Check Azure DevOps connection status
                    if (status.azure_connected) {
                        azureDevopsBox.classList.remove('offline');
                        azureDevopsBox.classList.add('online');
                        azureDevopsStatusLight.classList.remove('offline');
                        azureDevopsStatusLight.classList.add('online');
                    } else {
                        azureDevopsBox.classList.remove('online');
                        azureDevopsBox.classList.add('offline');
                        azureDevopsStatusLight.classList.remove('online');
                        azureDevopsStatusLight.classList.add('offline');
                    }
                    
                    // Fetch work queue and completed items from Azure DevOps
                    let workQueueCount = 0;
                    let completedCount = 0;
                    
                    try {
                        const azureWorkQueue = await fetchAPI('/api/work-queue-azure');
                        workQueueCount = azureWorkQueue.total || 0;
                        document.getElementById('headerWorkQueue').textContent = workQueueCount;
                        
                        // Store the Azure work queue data for later use
                        window.azureWorkQueueData = azureWorkQueue;
                    } catch (e) {
                        console.error('Failed to fetch Azure work queue:', e);
                        // Fall back to local queue size
                        workQueueCount = status.work_queue_size;
                        document.getElementById('headerWorkQueue').textContent = workQueueCount;
                    }
                    
                    try {
                        const azureCompletedItems = await fetchAPI('/api/completed-items-azure');
                        completedCount = azureCompletedItems.total || 0;
                        document.getElementById('headerCompleted').textContent = completedCount;
                        
                        // Store the Azure completed items data for later use
                        window.azureCompletedItemsData = azureCompletedItems;
                    } catch (e) {
                        console.error('Failed to fetch Azure completed items:', e);
                        // Fall back to local completed items
                        completedCount = status.completed_items;
                        document.getElementById('headerCompleted').textContent = completedCount;
                    }
                    
                    // Update total items
                    document.getElementById('headerTotal').textContent = workQueueCount + completedCount;
                    
                    // Get personas
                    const personas = await fetchAPI('/api/personas');
                    updatePersonaList(personas);
                    
                } catch (apiError) {
                    // API is offline
                    apiRunning = false;
                    apiBackendBox.classList.remove('online');
                    apiBackendBox.classList.add('offline');
                    apiBackendStatusLight.classList.remove('online');
                    apiBackendStatusLight.classList.add('offline');
                    
                    // Factory status when API is offline
                    aiPersonasBox.classList.remove('online');
                    aiPersonasBox.classList.add('offline');
                    aiPersonasStatusLight.classList.remove('online');
                    aiPersonasStatusLight.classList.add('offline');
                    
                    // Azure DevOps status when API is offline
                    azureDevopsBox.classList.remove('online');
                    azureDevopsBox.classList.add('offline');
                    azureDevopsStatusLight.classList.remove('online');
                    azureDevopsStatusLight.classList.add('offline');
                    
                    // Reset all numbers to 0
                    document.getElementById('headerActivePersonas').textContent = '0';
                    document.getElementById('headerWorkQueue').textContent = '0';
                    document.getElementById('headerCompleted').textContent = '0';
                    document.getElementById('headerTotal').textContent = '0';
                    
                    throw apiError;
                }
                
            } catch (error) {
                console.error('Failed to update dashboard:', error);
            }
        }
        
        function updatePersonaList(personas) {
            const container = document.getElementById('personaList');
            container.innerHTML = '';
            
            Object.entries(personas).forEach(([id, persona]) => {
                const card = document.createElement('div');
                card.className = 'persona-card';
                if (selectedPersona === id) card.classList.add('selected');
                
                const status = persona.state.status;
                const statusIndicator = document.createElement('div');
                statusIndicator.className = `status-indicator status-${status}`;
                
                const info = document.createElement('div');
                const config = personaConfigs[id] || {};
                const displayName = config.firstName && config.lastName 
                    ? `${config.firstName} ${config.lastName}` 
                    : persona.info.name;
                const displayRole = config.role || persona.info.role;
                
                info.innerHTML = `
                    <div style="font-weight: bold;">${displayName}</div>
                    <div style="font-size: 0.85em; color: #888;">${displayRole}</div>
                    <div style="font-size: 0.8em; color: #666;">Status: ${status}</div>
                `;
                
                card.appendChild(statusIndicator);
                card.appendChild(info);
                card.onclick = () => selectPersona(id);
                
                container.appendChild(card);
            });
        }
        
        async function selectPersona(id) {
            selectedPersona = id;
            document.querySelectorAll('.persona-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Find and highlight the selected card
            const selectedCard = document.querySelector(`[onclick="selectPersona('${id}')"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            // Load the edit persona instance page
            await loadEditPersonaInstance(id);
        }
        
        function openPersonaEditModal(personaId) {
            const modal = document.getElementById('personaEditModal');
            const config = personaConfigs[personaId] || defaultPersonaConfigs[personaId] || {
                firstName: '',
                lastName: '',
                email: '',
                role: '',
                skills: ''
            };
            
            // Populate form fields
            document.getElementById('personaId').value = personaId;
            document.getElementById('firstName').value = config.firstName || '';
            document.getElementById('lastName').value = config.lastName || '';
            document.getElementById('email').value = config.email || '';
            document.getElementById('role').value = config.role || '';
            
            // Populate skills
            const skillsArray = config.skills ? config.skills.split(',').map(s => s.trim()).filter(s => s) : [];
            displaySkills(skillsArray);
            
            // Show modal
            modal.style.display = 'block';
        }
        
        function displaySkills(skillsArray) {
            const skillsContainer = document.getElementById('skillsTags');
            skillsContainer.innerHTML = '';
            
            skillsArray.forEach(skill => {
                const skillTag = document.createElement('div');
                skillTag.className = 'skill-tag';
                skillTag.innerHTML = `
                    <span>${skill}</span>
                    <span class="remove-skill" onclick="removeSkill('${skill.replace(/'/g, "\\'")}')">&times;</span>
                `;
                skillsContainer.appendChild(skillTag);
            });
        }
        
        function getCurrentSkills() {
            const skillTags = document.querySelectorAll('#skillsTags .skill-tag span:first-child');
            return Array.from(skillTags).map(tag => tag.textContent);
        }
        
        function renderPersonaTools(role) {
            const tools = roleToolsMapping[role];
            if (!tools) {
                return '<p style="color: #666;">No tools configured for this role.</p>';
            }
            
            const categories = Object.entries(tools);
            const midpoint = Math.ceil(categories.length / 2);
            const leftColumn = categories.slice(0, midpoint);
            const rightColumn = categories.slice(midpoint);
            
            let html = '<div style="display: flex; gap: 20px;">';
            
            // Left column of tools
            html += '<div style="flex: 1;">';
            leftColumn.forEach(([category, toolList]) => {
                html += `
                    <div style="margin-bottom: 12px;">
                        <p style="margin: 0 0 3px 0; color: #3b82f6; font-size: 0.85em; font-weight: bold;">${category}:</p>
                        <ul style="margin: 0; padding-left: 16px; color: #e0e0e0;">
                            ${toolList.map(tool => `<li style="margin-bottom: 1px; font-size: 0.85em;">${tool}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            html += '</div>';
            
            // Right column of tools
            html += '<div style="flex: 1;">';
            rightColumn.forEach(([category, toolList]) => {
                html += `
                    <div style="margin-bottom: 12px;">
                        <p style="margin: 0 0 3px 0; color: #3b82f6; font-size: 0.85em; font-weight: bold;">${category}:</p>
                        <ul style="margin: 0; padding-left: 16px; color: #e0e0e0;">
                            ${toolList.map(tool => `<li style="margin-bottom: 1px; font-size: 0.85em;">${tool}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            html += '</div>';
            
            html += '</div>';
            return html;
        }
        
        function addSkill() {
            const input = document.getElementById('newSkillInput');
            const skill = input.value.trim();
            
            if (!skill) return;
            
            const currentSkills = getCurrentSkills();
            if (currentSkills.includes(skill)) {
                showNotification('Skill already exists!', 'warning');
                return;
            }
            
            currentSkills.push(skill);
            displaySkills(currentSkills);
            input.value = '';
        }
        
        function removeSkill(skill) {
            const currentSkills = getCurrentSkills().filter(s => s !== skill);
            displaySkills(currentSkills);
        }
        
        // Add enter key support for adding skills
        document.addEventListener('DOMContentLoaded', function() {
            const newSkillInput = document.getElementById('newSkillInput');
            if (newSkillInput) {
                newSkillInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addSkill();
                    }
                });
            }
        });
        
        function closePersonaModal() {
            const modal = document.getElementById('personaEditModal');
            modal.style.display = 'none';
        }
        
        async function savePersona() {
            const personaId = document.getElementById('personaId').value;
            
            // Get form values
            const firstName = document.getElementById('firstName').value;
            const lastName = document.getElementById('lastName').value;
            const email = document.getElementById('email').value;
            const role = document.getElementById('role').value;
            
            // Get skills as comma-separated string
            const skills = getCurrentSkills().join(', ');
            
            try {
                // Call the backend API to update persona instance
                const response = await fetchAPI(`/api/personas/instances/${personaId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        first_name: firstName,
                        last_name: lastName,
                        email: email,
                        role: role,
                        skills: skills
                    })
                });
                
                if (response && response.status === 'success') {
                    // Update local config cache
                    if (!personaConfigs[personaId]) {
                        personaConfigs[personaId] = {};
                    }
                    
                    personaConfigs[personaId] = {
                        ...personaConfigs[personaId],
                        firstName,
                        lastName,
                        email,
                        role,
                        skills
                    };
                    
                    // Close modal and refresh
                    closePersonaModal();
                    updateDashboard();
                    
                    // If we're viewing this persona, refresh the details
                    if (selectedPersona === personaId) {
                        loadPersonaDetails();
                    }
                    
                    // Show success message
                    showNotification('Persona saved successfully!', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save persona');
                }
            } catch (error) {
                console.error('Error saving persona:', error);
                showNotification(`Failed to save persona: ${error.message}`, 'error');
            }
        }
        
        // Workflow management functions
        let commonWorkflows = [];
        let workflowExpanded = {}; // Track which workflows are expanded
        
        // Simple markdown to HTML converter
        function parseMarkdown(markdown) {
            let html = markdown;
            
            // Code blocks first (to preserve their content)
            html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, function(match, lang, code) {
                return '<CODEBLOCK>' + escapeHtml(code.trim()) + '</CODEBLOCK>';
            });
            
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Bold
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            
            // Lists - handle line by line
            const lines = html.split('\n');
            let inList = false;
            let processedLines = [];
            
            for (let line of lines) {
                if (line.match(/^- \[ \] /)) {
                    if (!inList) {
                        processedLines.push('<ul style="margin: 5px 0;">');
                        inList = true;
                    }
                    processedLines.push('<li style="margin: 3px 0;">' + line.substring(6) + '</li>');
                } else if (line.match(/^- \[x\] /)) {
                    if (!inList) {
                        processedLines.push('<ul style="margin: 5px 0;">');
                        inList = true;
                    }
                    processedLines.push('<li style="margin: 3px 0;">' + line.substring(6) + '</li>');
                } else if (line.match(/^- /)) {
                    if (!inList) {
                        processedLines.push('<ul style="margin: 5px 0;">');
                        inList = true;
                    }
                    processedLines.push('<li style="margin: 3px 0;">' + line.substring(2) + '</li>');
                } else {
                    if (inList) {
                        processedLines.push('</ul>');
                        inList = false;
                    }
                    // Only add line if it's not empty
                    if (line.trim()) {
                        processedLines.push(line);
                    } else if (processedLines.length > 0 && processedLines[processedLines.length - 1] !== '<br>') {
                        // Add single break for empty lines between content
                        processedLines.push('<br>');
                    }
                }
            }
            
            if (inList) {
                processedLines.push('</ul>');
            }
            
            html = processedLines.join('\n');
            
            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Restore code blocks
            html = html.replace(/<CODEBLOCK>([\s\S]*?)<\/CODEBLOCK>/g, '<pre><code>$1</code></pre>');
            
            return html;
        }
        
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        function toggleWorkflow(workflowId) {
            workflowExpanded[workflowId] = !workflowExpanded[workflowId];
            displayWorkflows();
        }
        
        function toggleWorkflowSection(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('collapsed');
            
            // Update the arrow icon - follows same pattern as workflow items
            const isCollapsed = section.classList.contains('collapsed');
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isCollapsed ? '&#9650;' : '&#9660;';
            }
        }
        
        async function loadWorkflows() {
            // Try to load from API with cache busting
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`${API_BASE}/api/workflows?_t=${timestamp}`);
                const data = await response.json();
                if (data.success && data.workflows) {
                    // Initialize workflowsByCategory from loaded categories
                    const workflowsByCategory = {};
                    
                    // Initialize all known categories from the backend
                    window.workflowCategories.forEach(cat => {
                        workflowsByCategory[cat.id] = [];
                    });
                    
                    // Process workflows
                    data.workflows.forEach(workflow => {
                        const category = workflow.category;
                        
                        // If it's a new category we haven't seen
                        if (!workflowsByCategory[category]) {
                            workflowsByCategory[category] = [];
                            // This shouldn't happen if backend is consistent
                            console.warn(`Found workflow with unknown category: ${category}`);
                                
                                // Create the UI section for this category if it doesn't exist
                                if (!document.getElementById(category + 'Section')) {
                                    const workflowsList = document.getElementById('workflowsList');
                                    const newSection = document.createElement('div');
                                    newSection.className = 'workflow-section';
                                    newSection.id = category + 'Section';
                                    newSection.innerHTML = `
                                        <div class="workflow-section-header" onclick="toggleWorkflowSection('${category}Section')">
                                            <h4 class="workflow-section-title">${category.charAt(0).toUpperCase() + category.slice(1)} Workflows</h4>
                                            <span class="workflow-section-count" id="${category}Count">0</span>
                                            <span class="workflow-section-toggle">&#9660;</span>
                                        </div>
                                        <div class="workflow-section-content" id="${category}Workflows">
                                            <div class="workflow-section-empty">Loading workflows...</div>
                                        </div>
                                    `;
                                    workflowsList.appendChild(newSection);
                                }
                            }
                        
                        workflowsByCategory[category].push(workflow);
                    });
                    
                    // Store for later use
                    window.workflowsByCategory = workflowsByCategory;
                    
                    console.log(`Loaded ${data.workflows.length} workflows from API`);
                    displayWorkflows(workflowsByCategory);
                }
            } catch (error) {
                console.error('Failed to load workflows from API:', error);
                showMessage('workflowsMessage', 'Failed to load workflows: ' + error.message, 'error');
            }
        }
        
        function displayWorkflows(workflowsByCategory) {
            if (!workflowsByCategory) {
                workflowsByCategory = window.workflowsByCategory || { master: [], core: [], support: [] };
            }
            
            // Display workflows in all categories
            let totalWorkflows = 0;
            for (const [category, workflows] of Object.entries(workflowsByCategory)) {
                displayWorkflowSection(category, workflows);
                totalWorkflows += workflows.length;
            }
            
            // Update total count in title
            const workflowsTitle = document.getElementById('workflowsTitle');
            if (workflowsTitle) {
                workflowsTitle.textContent = `Workflow Definitions (${totalWorkflows})`;
            }
        }
        
        function displayWorkflowSection(category, workflows) {
            const container = document.getElementById(`${category}Workflows`);
            const countElement = document.getElementById(`${category}Count`);
            
            if (!container) return;
            
            // Update count
            if (countElement) {
                countElement.textContent = workflows.length;
            }
            
            if (workflows.length === 0) {
                container.innerHTML = '<div class="workflow-section-empty">No workflows in this category</div>';
                return;
            }
            
            container.innerHTML = workflows.map((workflow) => {
                const isExpanded = workflowExpanded[workflow.id] || false;
                
                // Get current version from metadata
                const currentVersion = workflow.raw_data?.metadata?.version || '1.0.0';
                
                return renderWorkflowSection(workflow, category, isExpanded, currentVersion);
            }).join('');
        }
        
        // Render workflow in Persona Prompt style
        function renderWorkflowSection(workflow, category, isExpanded, currentVersion) {
            const workflowId = workflow.id;
            const workflowName = workflow.name || 'Unnamed Workflow';
            const toggleIcon = isExpanded ? '&#9660;' : '&#9650;';
            
            // Initialize tracking for this workflow if not exists
            if (!window.workflowStates) {
                window.workflowStates = {};
            }
            if (!window.workflowStates[workflowId]) {
                window.workflowStates[workflowId] = {
                    hasChanges: false,
                    originalYaml: workflow.raw_yaml || '',
                    currentVersion: currentVersion
                };
            }
            
            const html = `
                <div class="workflow-section" id="workflow-section-${workflowId}" style="margin-bottom: 15px;">
                    <div class="workflow-section-header" onclick="toggleWorkflowEdit('${workflowId}')">
                        <h4 class="workflow-section-title">${escapeHtml(workflowName)}</h4>
                        <span class="workflow-section-count">Version ${currentVersion}</span>
                        <span class="workflow-section-toggle">${toggleIcon}</span>
                        <div style="flex: 1;"></div>
                        <div class="workflow-actions" onclick="event.stopPropagation()">
                            ${(workflowId === 'wf0' || workflowId === 'wf1' || workflowId === 'wf2') ? `
                                <button class="btn-icon" onclick="showWorkflowDiagram('${workflowId}', 'orchestration')" title="View orchestration diagram">
                                    &#128200;
                                </button>
                                <button class="btn-icon" onclick="showWorkflowDiagram('${workflowId}', 'interaction')" title="View interaction diagram">
                                    &#128101;
                                </button>
                                <button class="btn-icon" onclick="showWorkflowDiagram('${workflowId}', 'raci')" title="View RACI matrix">
                                    &#128203;
                                </button>
                            ` : ''}
                            <button class="btn-icon" onclick="editWorkflowName('${workflowId}')" title="Edit workflow name">
                                &#9998;
                            </button>
                            <button class="btn-icon" onclick="deleteWorkflow('${workflowId}')" title="Delete workflow">
                                &#128465;
                            </button>
                        </div>
                    </div>
                    <div class="workflow-section-content ${isExpanded ? '' : 'collapsed'}">
                        <div style="padding: 20px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Workflow Definition</h4>
                            <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <small style="color: #888;">Edit the YAML definition for this workflow</small>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="viewWorkflowHistory('${workflowId}')">
                                        <span style="margin-right: 5px;">&#128220;</span>History
                                    </button>
                                    <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="exportWorkflow('${workflowId}')">
                                        <span style="margin-right: 5px;">&#128228;</span>Export
                                    </button>
                                    <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="importWorkflow('${workflowId}')">
                                        <span style="margin-right: 5px;">&#128229;</span>Import
                                    </button>
                                </div>
                            </div>
                            <textarea id="workflow-yaml-${workflowId}" rows="20" 
                                      onchange="trackWorkflowChange('${workflowId}')" 
                                      oninput="onWorkflowYamlEdit('${workflowId}')"
                                      style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                             border-radius: 4px; color: #e0e0e0; font-size: 14px; font-family: 'Courier New', monospace;
                                             resize: vertical; min-height: 400px;">
${workflow.raw_yaml || jsyaml.dump(workflow.raw_data || {}, {indent: 2, lineWidth: -1})}
                            </textarea>
                            <div id="workflow-validation-${workflowId}" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                            <div style="margin-top: 10px;">
                                <input type="text" id="workflow-change-notes-${workflowId}" 
                                       placeholder="Change notes (optional)" 
                                       onchange="trackWorkflowChange('${workflowId}')"
                                       style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444;
                                              border-radius: 4px; color: #e0e0e0;">
                            </div>
                            <div style="margin-top: 15px; color: #888; font-size: 12px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <div style="display: flex; gap: 10px;">
                                        <button class="btn-save workflow-save-btn-${workflowId}" 
                                                onclick="saveWorkflowChanges('${workflowId}')" 
                                                style="padding: 8px 20px;" disabled>
                                            Save Workflow
                                        </button>
                                    </div>
                                    <span>Version: <span id="workflow-version-${workflowId}" style="color: #3b82f6;">${currentVersion}</span> | Last updated: <span id="workflow-last-updated-${workflowId}" style="color: #3b82f6;">${workflow.last_modified ? new Date(workflow.last_modified).toLocaleString() : 'Never'}</span></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        // Toggle workflow edit section
        function toggleWorkflowEdit(workflowId) {
            const section = document.getElementById(`workflow-section-${workflowId}`);
            if (!section) return;
            
            const content = section.querySelector('.workflow-section-content');
            const isExpanded = !content.classList.contains('collapsed');
            
            if (isExpanded) {
                content.classList.add('collapsed');
            } else {
                content.classList.remove('collapsed');
                // Load fresh data when expanding
                loadWorkflowData(workflowId);
            }
            
            // Update toggle icon
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isExpanded ? '&#9650;' : '&#9660;';
            }
            
            // Update expanded state
            workflowExpanded[workflowId] = !isExpanded;
        }
        
        // Load workflow data when expanding
        async function loadWorkflowData(workflowId) {
            try {
                const response = await fetch(`${API_BASE}/api/workflows/${workflowId}`);
                if (!response.ok) return;
                
                const data = await response.json();
                if (data.success && data.workflow) {
                    const textarea = document.getElementById(`workflow-yaml-${workflowId}`);
                    if (textarea) {
                        const yamlContent = jsyaml.dump(data.workflow, {indent: 2, lineWidth: -1});
                        textarea.value = yamlContent;
                        
                        // Update original YAML
                        if (window.workflowStates[workflowId]) {
                            window.workflowStates[workflowId].originalYaml = yamlContent;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load workflow data:', error);
            }
        }
        
        // Track workflow changes
        function trackWorkflowChange(workflowId) {
            if (!window.workflowStates[workflowId]) return;
            
            const textarea = document.getElementById(`workflow-yaml-${workflowId}`);
            const currentYaml = textarea ? textarea.value : '';
            const hasChanges = currentYaml !== window.workflowStates[workflowId].originalYaml;
            
            window.workflowStates[workflowId].hasChanges = hasChanges;
            
            // Reset validation state when changes are made
            if (hasChanges && window.workflowStates[workflowId].isValid) {
                window.workflowStates[workflowId].isValid = false;
                // Hide validation message
                const validationDiv = document.getElementById(`workflow-validation-${workflowId}`);
                if (validationDiv) {
                    validationDiv.style.display = 'none';
                }
            }
            
            updateWorkflowSaveButton(workflowId, hasChanges);
        }
        
        // Real-time YAML validation on edit
        function onWorkflowYamlEdit(workflowId) {
            // Track changes
            trackWorkflowChange(workflowId);
            
            // Validate YAML
            const textarea = document.getElementById(`workflow-yaml-${workflowId}`);
            const validationDiv = document.getElementById(`workflow-validation-${workflowId}`);
            
            if (!textarea || !validationDiv) return;
            
            // Clear previous timeout
            if (window.workflowValidationTimeouts && window.workflowValidationTimeouts[workflowId]) {
                clearTimeout(window.workflowValidationTimeouts[workflowId]);
            }
            
            if (!window.workflowValidationTimeouts) {
                window.workflowValidationTimeouts = {};
            }
            
            // Set new timeout for automatic validation
            window.workflowValidationTimeouts[workflowId] = setTimeout(async () => {
                try {
                    const yamlContent = textarea.value;
                    jsyaml.load(yamlContent);
                    
                    // If local parsing succeeds, do full validation
                    await validateWorkflowYaml(workflowId);
                    
                } catch (error) {
                    // Show error message
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#4d1a1a';
                    validationDiv.style.border = '1px solid #7a2d2d';
                    validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; ${escapeHtml(error.message)}</span>`;
                    
                    // Disable save button on validation failure
                    const saveBtn = document.querySelector(`.workflow-save-btn-${workflowId}`);
                    if (saveBtn) {
                        saveBtn.disabled = true;
                    }
                    
                    // Update validation state
                    if (window.workflowStates[workflowId]) {
                        window.workflowStates[workflowId].isValid = false;
                    }
                }
            }, 500);
        }
        
        // Update save button state
        function updateWorkflowSaveButton(workflowId, hasChanges) {
            const saveBtn = document.querySelector(`.workflow-save-btn-${workflowId}`);
            
            if (saveBtn) {
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                    // Don't change disabled state here - let validation handle it
                } else {
                    saveBtn.classList.remove('has-changes');
                    saveBtn.disabled = true; // No changes = disabled
                }
            }
        }
        
        // Edit workflow name
        async function editWorkflowName(workflowId) {
            const section = document.getElementById(`workflow-section-${workflowId}`);
            const titleElement = section.querySelector('.workflow-section-title');
            const currentName = titleElement.textContent;
            
            const newName = prompt('Enter new workflow name:', currentName);
            if (newName && newName !== currentName) {
                try {
                    // Get current workflow data
                    const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
                    if (!yamlTextarea) {
                        showNotification('Could not find workflow data', 'error');
                        return;
                    }
                    
                    let parsedYaml;
                    try {
                        parsedYaml = jsyaml.load(yamlTextarea.value);
                    } catch (e) {
                        showNotification('Invalid workflow YAML', 'error');
                        return;
                    }
                    
                    // Update the name in the YAML
                    if (!parsedYaml.metadata) {
                        parsedYaml.metadata = {};
                    }
                    parsedYaml.metadata.name = newName;
                    
                    // Save to backend
                    const response = await fetch(`${API_BASE}/api/workflows/save`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            id: workflowId,
                            yaml: jsyaml.dump(parsedYaml),
                            changeNotes: `Renamed workflow to "${newName}"`
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save workflow name');
                    }
                    
                    // Update display
                    titleElement.textContent = newName;
                    
                    // Update the YAML in the textarea
                    yamlTextarea.value = jsyaml.dump(parsedYaml);
                    
                    // Update the original YAML in state
                    if (window.workflowStates[workflowId]) {
                        window.workflowStates[workflowId].originalYaml = yamlTextarea.value;
                    }
                    
                    showNotification('Workflow name updated successfully', 'success');
                } catch (error) {
                    console.error('Error updating workflow name:', error);
                    showNotification(`Failed to update workflow name: ${error.message}`, 'error');
                    // Revert display name on error
                    titleElement.textContent = currentName;
                }
            }
        }
        
        // View workflow history (real implementation)
        async function viewWorkflowHistory(workflowId) {
            try {
                const response = await fetch(`${API_BASE}/api/workflows/${workflowId}/history`);
                if (!response.ok) throw new Error('Failed to fetch history');
                
                const data = await response.json();
                if (!data.success || !data.history || data.history.length === 0) {
                    showNotification('No version history available', 'info');
                    return;
                }
                
                // Create history modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>Workflow Version History</h2>
                            <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                        </div>
                        <div class="modal-body">
                            <div style="max-height: 500px; overflow-y: auto;">
                                ${data.history.map((version) => `
                                    <div style="padding: 15px; margin-bottom: 10px; background: #2a2a2a; border-radius: 8px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <strong>Version ${version.version}</strong>
                                                <div style="color: #888; font-size: 12px;">${new Date(version.createdAt).toLocaleString()}</div>
                                                ${version.changeNotes ? `<div style="margin-top: 5px; color: #ccc;">${escapeHtml(version.changeNotes)}</div>` : ''}
                                            </div>
                                            <button class="btn-secondary" onclick="restoreWorkflowVersionFromHistory('${workflowId}', '${version.version}', \`${btoa(version.yamlContent)}\`)">
                                                Restore
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Failed to load workflow history:', error);
                showNotification('Failed to load version history', 'error');
            }
        }
        
        // Restore workflow version from history
        function restoreWorkflowVersionFromHistory(workflowId, version, encodedYaml) {
            const yamlContent = atob(encodedYaml);
            const textarea = document.getElementById(`workflow-yaml-${workflowId}`);
            
            if (textarea) {
                textarea.value = yamlContent;
                trackWorkflowChange(workflowId);
                showNotification(`Restored version ${version}`, 'success');
            }
            
            // Close the modal
            document.querySelector('.modal').remove();
        }
        
        function addNewWorkflow() {
            showWorkflowModal();
        }
        
        function addNewWorkflowCategory() {
            showWorkflowCategoryModal();
        }
        
        function showWorkflowCategoryModal() {
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2>Add New Workflow Category</h2>
                        <span class="close-button" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="categoryId">Category ID</label>
                            <input type="text" id="categoryId" placeholder="e.g., custom" 
                                   style="width: 100%; padding: 8px; background: #1a1a1a; color: #e0e0e0; 
                                          border: 1px solid #333; border-radius: 4px;"
                                   pattern="[a-z0-9-]+" required>
                            <small style="color: #666;">Lowercase letters, numbers, and hyphens only</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="categoryName">Display Name</label>
                            <input type="text" id="categoryName" placeholder="e.g., Custom Workflows" 
                                   style="width: 100%; padding: 8px; background: #1a1a1a; color: #e0e0e0; 
                                          border: 1px solid #333; border-radius: 4px;" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="categoryDescription">Description</label>
                            <textarea id="categoryDescription" placeholder="Brief description of this category"
                                      style="width: 100%; padding: 8px; background: #1a1a1a; color: #e0e0e0; 
                                             border: 1px solid #333; border-radius: 4px; min-height: 80px;"></textarea>
                        </div>
                    </div>
                    <div class="modal-buttons">
                        <button type="button" class="btn-cancel" onclick="this.closest('.modal').remove()">Cancel</button>
                        <button type="button" class="btn-save" onclick="saveWorkflowCategory()">Create Category</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus on first input
            setTimeout(() => {
                document.getElementById('categoryId').focus();
            }, 100);
        }
        
        async function saveWorkflowCategory() {
            const categoryId = document.getElementById('categoryId').value.trim();
            const categoryName = document.getElementById('categoryName').value.trim();
            const categoryDescription = document.getElementById('categoryDescription').value.trim();
            
            // Validate
            if (!categoryId || !categoryName) {
                showNotification('Category ID and Name are required', 'error');
                return;
            }
            
            if (!/^[a-z0-9-]+$/.test(categoryId)) {
                showNotification('Category ID must contain only lowercase letters, numbers, and hyphens', 'error');
                return;
            }
            
            try {
                // Save to backend
                const response = await fetchAPI('/api/workflows/categories', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: categoryId,
                        name: categoryName,
                        description: categoryDescription
                    })
                });
                
                if (response && response.id) {
                    // Reload categories from backend to ensure consistency
                    await loadWorkflowCategories();
                    
                    // Add new category section to the UI
                const workflowsList = document.getElementById('workflowsList');
                const newSection = document.createElement('div');
                newSection.className = 'workflow-section';
                newSection.id = categoryId + 'Section';
                newSection.innerHTML = `
                    <div class="workflow-section-header" onclick="toggleWorkflowSection('${categoryId}Section')">
                        <h4 class="workflow-section-title">${escapeHtml(categoryName)}</h4>
                        <span class="workflow-section-count" id="${categoryId}Count">0</span>
                        <span class="workflow-section-toggle">&#9660;</span>
                    </div>
                    <div class="workflow-section-content" id="${categoryId}Workflows">
                        <div class="workflow-section-empty">No workflows in this category yet</div>
                    </div>
                `;
                
                // Insert before the buttons div
                workflowsList.appendChild(newSection);
                
                showNotification(`Category "${categoryName}" created successfully`, 'success');
                
                // Close modal
                document.querySelector('.modal').remove();
                }
                
            } catch (error) {
                console.error('Error creating category:', error);
                showNotification('Error creating category: ' + error.message, 'error');
            }
        }
        
        async function saveWorkflows() {
            try {
                // Show saving message
                showMessage('workflowsMessage', 'Saving workflows...', 'info');
                
                // Since workflows are saved individually through the modal,
                // this button can just show a success message
                showMessage('workflowsMessage', 'All workflows are automatically saved when edited', 'success');
                
            } catch (error) {
                console.error('Error in saveWorkflows:', error);
                showMessage('workflowsMessage', 'Error: ' + error.message, 'error');
            }
        }
        
        
        // Show workflow inline editor
        async function showWorkflowInlineEditor(workflow, category) {
            // Store original data and set editing state
            workflowOriginalData = JSON.parse(JSON.stringify(workflow));
            currentEditingWorkflowId = workflow.id;
            workflowHasUnsavedChanges = false;
            
            // Find the workflow item div
            const workflowItem = Array.from(document.querySelectorAll('.workflow-item')).find(item => {
                const editBtn = item.querySelector(`button[onclick="editWorkflow('${workflow.id}')"]`);
                return editBtn !== null;
            });
            
            if (!workflowItem) {
                console.error('Could not find workflow item for', workflow.id);
                return;
            }
            
            // Get current version or initialize
            const currentVersion = workflow.version || '1.0.0';
            const versionHistory = workflowVersionHistory[workflow.id] || [];
            
            // Create inline editor HTML
            const editorHtml = `
                <div class="workflow-inline-editor" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 20px; margin: 10px 0;">
                    <!-- Header with save/cancel buttons -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h3 style="margin: 0; color: #3b82f6;">Editing: ${escapeHtml(workflow.name)}</h3>
                            <small style="color: #888;">ID: ${workflow.id} | Category: ${category}</small>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn-cancel workflow-cancel-btn" onclick="cancelWorkflowEdit('${workflow.id}')" disabled>
                                Cancel
                            </button>
                            <button class="btn-save workflow-save-btn" onclick="saveWorkflowChanges('${workflow.id}')" disabled>
                                Save Changes
                            </button>
                        </div>
                    </div>
                    
                    <!-- Utility buttons -->
                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <small style="color: #888;">Edit the YAML definition for this workflow. Changes are validated in real-time.</small>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="viewWorkflowHistory('${workflow.id}')">
                                <span style="margin-right: 5px;">&#128220;</span>History
                            </button>
                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="exportWorkflow('${workflow.id}')">
                                <span style="margin-right: 5px;">&#128228;</span>Export
                            </button>
                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="importWorkflow('${workflow.id}')">
                                <span style="margin-right: 5px;">&#128229;</span>Import
                            </button>
                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="validateWorkflowYaml('${workflow.id}')">
                                <span style="margin-right: 5px;">&#10003;</span>Validate
                            </button>
                        </div>
                    </div>
                    
                    <!-- YAML Editor -->
                    <textarea id="workflow-yaml-${workflow.id}" 
                              onchange="trackWorkflowChange('${workflow.id}')" 
                              oninput="onWorkflowYamlInput('${workflow.id}')"
                              style="width: 100%; min-height: 500px; padding: 15px; background: #2a2a2a; 
                                     border: 1px solid #444; border-radius: 4px; color: #e0e0e0; 
                                     font-size: 14px; font-family: 'Courier New', monospace; 
                                     resize: vertical; line-height: 1.5;">
${workflow.raw_yaml || jsyaml.dump(workflow.raw_data, {indent: 2, lineWidth: -1})}
                    </textarea>
                    
                    <!-- Validation message -->
                    <div id="workflow-validation-${workflow.id}" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                    
                    <!-- Change notes -->
                    <div style="margin-top: 15px;">
                        <input type="text" id="workflow-change-notes-${workflow.id}" 
                               placeholder="Change notes (optional)" 
                               onchange="trackWorkflowChange('${workflow.id}')"
                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                    </div>
                    
                    <!-- Version info -->
                    <div style="margin-top: 5px; color: #888; font-size: 12px;">
                        Version: <span id="workflow-version-${workflow.id}" style="color: #3b82f6;">${currentVersion}</span> | 
                        Last updated: <span id="workflow-updated-${workflow.id}" style="color: #3b82f6;">${workflow.last_updated ? new Date(workflow.last_updated).toLocaleString() : 'Never'}</span>
                    </div>
                </div>
            `;
            
            // Replace the workflow item content with the editor
            workflowItem.innerHTML = editorHtml;
            
            // Focus on the textarea
            const textarea = document.getElementById(`workflow-yaml-${workflow.id}`);
            if (textarea) {
                textarea.focus();
                textarea.setSelectionRange(0, 0);
            }
        }
        
        // Cancel workflow editing and restore original display
        function cancelWorkflowEdit(workflowId) {
            if (workflowHasUnsavedChanges && !confirm('You have unsaved changes. Are you sure you want to cancel?')) {
                return;
            }
            
            // Reset state
            workflowHasUnsavedChanges = false;
            workflowOriginalData = null;
            currentEditingWorkflowId = null;
            
            // Reload workflows to restore original display
            loadWorkflows();
        }
        
        // Save workflow changes
        async function saveWorkflowChanges(workflowId) {
            try {
                const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
                const changeNotes = document.getElementById(`workflow-change-notes-${workflowId}`);
                
                if (!yamlTextarea) {
                    showNotification('Could not find workflow editor', 'error');
                    return;
                }
                
                const yamlContent = yamlTextarea.value;
                
                // Validate YAML
                let parsedYaml;
                try {
                    parsedYaml = jsyaml.load(yamlContent);
                } catch (e) {
                    showNotification(`Invalid YAML: ${e.message}`, 'error');
                    return;
                }
                
                // Update version - get from state tracking, not from YAML
                const stateVersion = window.workflowStates[workflowId]?.currentVersion || parsedYaml.metadata?.version || '1.0.0';
                const versionParts = stateVersion.split('.');
                versionParts[2] = (parseInt(versionParts[2]) + 1).toString();
                const newVersion = versionParts.join('.');
                
                if (parsedYaml.metadata) {
                    parsedYaml.metadata.version = newVersion;
                    parsedYaml.metadata.last_modified = new Date().toISOString();
                }
                
                // Store version history
                if (!workflowVersionHistory[workflowId]) {
                    workflowVersionHistory[workflowId] = [];
                }
                
                workflowVersionHistory[workflowId].push({
                    version: newVersion,
                    timestamp: new Date().toISOString(),
                    changeNotes: changeNotes?.value || '',
                    content: yamlContent
                });
                
                // Keep only last 10 versions
                if (workflowVersionHistory[workflowId].length > 10) {
                    workflowVersionHistory[workflowId] = workflowVersionHistory[workflowId].slice(-10);
                }
                
                // Save to backend
                const response = await fetch(`${API_BASE}/api/workflows/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: workflowId,
                        yaml: jsyaml.dump(parsedYaml),
                        changeNotes: changeNotes?.value || ''
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save workflow');
                }
                
                showNotification('Workflow saved successfully', 'success');
                
                // Reset state for this workflow
                if (window.workflowStates[workflowId]) {
                    window.workflowStates[workflowId].hasChanges = false;
                    window.workflowStates[workflowId].originalYaml = jsyaml.dump(parsedYaml);
                    window.workflowStates[workflowId].currentVersion = newVersion;
                    window.workflowStates[workflowId].isValid = false;
                }
                
                // Hide validation message
                const validationDiv = document.getElementById(`workflow-validation-${workflowId}`);
                if (validationDiv) {
                    validationDiv.style.display = 'none';
                }
                
                // Update UI to show new version
                const versionSpan = document.querySelector(`#workflow-section-${workflowId} .workflow-section-count`);
                if (versionSpan) {
                    versionSpan.textContent = `Version ${newVersion}`;
                }
                
                // Update version and timestamp at the bottom
                const bottomVersionSpan = document.getElementById(`workflow-version-${workflowId}`);
                if (bottomVersionSpan) {
                    bottomVersionSpan.textContent = newVersion;
                }
                
                const lastUpdatedSpan = document.getElementById(`workflow-last-updated-${workflowId}`);
                if (lastUpdatedSpan) {
                    lastUpdatedSpan.textContent = new Date().toLocaleString();
                }
                
                // Update version info in footer
                const versionInfo = document.querySelector(`#workflow-section-${workflowId} .workflow-section-content span`);
                if (versionInfo && versionInfo.textContent.startsWith('Version:')) {
                    versionInfo.textContent = `Version: ${newVersion} | Last updated: ${new Date().toLocaleString()}`;
                }
                
                // Reset save button state
                updateWorkflowSaveButton(workflowId, false);
                
            } catch (error) {
                console.error('Error saving workflow:', error);
                showNotification(`Failed to save workflow: ${error.message}`, 'error');
            }
        }
        
        
        // Export workflow
        function exportWorkflow(workflowId) {
            const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
            if (!yamlTextarea) {
                showNotification('Could not find workflow content', 'error');
                return;
            }
            
            const yamlContent = yamlTextarea.value;
            const blob = new Blob([yamlContent], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${workflowId}.yaml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Workflow exported successfully', 'success');
        }
        
        // Import workflow
        function importWorkflow(workflowId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.yaml,.yml';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const content = await file.text();
                    
                    // Validate YAML
                    try {
                        jsyaml.load(content);
                    } catch (yamlError) {
                        showNotification(`Invalid YAML file: ${yamlError.message}`, 'error');
                        return;
                    }
                    
                    // Update textarea
                    const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
                    if (yamlTextarea) {
                        yamlTextarea.value = content;
                        trackWorkflowChange(workflowId);
                        showNotification('Workflow imported successfully', 'success');
                    }
                    
                } catch (error) {
                    console.error('Error importing workflow:', error);
                    showNotification(`Failed to import workflow: ${error.message}`, 'error');
                }
            };
            
            input.click();
        }
        
        // Validate workflow YAML
        async function validateWorkflowYaml(workflowId) {
            const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
            const validationDiv = document.getElementById(`workflow-validation-${workflowId}`);
            
            if (!yamlTextarea || !validationDiv) {
                return;
            }
            
            try {
                const yamlContent = yamlTextarea.value;
                
                // Local YAML validation
                const parsedYaml = jsyaml.load(yamlContent);
                
                // Server-side validation
                const response = await fetch(`${API_BASE}/api/workflows/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        yaml: yamlContent
                    })
                });
                
                const result = await response.json();
                
                if (result.valid) {
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#1a4d1a';
                    validationDiv.style.border = '1px solid #2d7a2d';
                    validationDiv.innerHTML = '<span style="color: #4ade80;">&#10003; Workflow is valid</span>';
                    
                    // Enable save button on successful validation
                    const saveBtn = document.querySelector(`.workflow-save-btn-${workflowId}`);
                    if (saveBtn && window.workflowStates[workflowId]?.hasChanges) {
                        saveBtn.disabled = false;
                    }
                    
                    // Store validation state
                    if (window.workflowStates[workflowId]) {
                        window.workflowStates[workflowId].isValid = true;
                    }
                } else {
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#4d1a1a';
                    validationDiv.style.border = '1px solid #7a2d2d';
                    validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; Validation errors:</span><br>${escapeHtml(result.errors.join('\n'))}`;
                    
                    // Disable save button on validation failure
                    const saveBtn = document.querySelector(`.workflow-save-btn-${workflowId}`);
                    if (saveBtn) {
                        saveBtn.disabled = true;
                    }
                    
                    // Store validation state
                    if (window.workflowStates[workflowId]) {
                        window.workflowStates[workflowId].isValid = false;
                    }
                }
                
            } catch (error) {
                validationDiv.style.display = 'block';
                validationDiv.style.background = '#4d1a1a';
                validationDiv.style.border = '1px solid #7a2d2d';
                validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; ${escapeHtml(error.message)}</span>`;
            }
        }
        
        // Real-time YAML validation on input
        function onWorkflowYamlInput(workflowId) {
            const yamlTextarea = document.getElementById(`workflow-yaml-${workflowId}`);
            const validationDiv = document.getElementById(`workflow-validation-${workflowId}`);
            
            if (!yamlTextarea || !validationDiv) {
                return;
            }
            
            // Clear previous validation timeout
            if (window.workflowValidationTimeout) {
                clearTimeout(window.workflowValidationTimeout);
            }
            
            // Set new timeout for validation
            window.workflowValidationTimeout = setTimeout(() => {
                try {
                    const yamlContent = yamlTextarea.value;
                    jsyaml.load(yamlContent);
                    
                    // If parsing succeeds, hide validation message
                    validationDiv.style.display = 'none';
                    
                } catch (error) {
                    // Show error message
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#4d1a1a';
                    validationDiv.style.border = '1px solid #7a2d2d';
                    validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; ${escapeHtml(error.message)}</span>`;
                }
            }, 500);
        }
        
        function getWorkflowYamlTemplate() {
            return `metadata:
  id: todo_workflow_name
  name: TODO Workflow name
  version: 1.0.0
  type: TODO
  description: TODO
  author: TODO
  tags:
    - TODO
  averageDuration: TODO_MIN_DAYS-TODO_MAX_DAYS days
inputs:
  - name: TODO
    type: TODO
    description: TODO
    required: true
    pattern: ^[A-Z0-9-]+$
prerequisites:
  - description: TODO
    required: true
steps:
  - id: todo_steps_name
    name: TODO
    description: TODO
    action: TODO
    workflow: TODO - Other workflow name optional
    inputs:
      WORK_TYPE: todo
      WORK_ITEM_ID: \${inputs.TODO_ID}
      DESCRIPTION: \${inputs.TODO_DESCRIPTION}
    outputs:
      - TODO`;
        }

        // Initialize workflow categories from backend
        async function loadWorkflowCategories() {
            try {
                const response = await fetchAPI('/api/workflows/categories');
                if (response && response.categories) {
                    window.workflowCategories = response.categories;
                    // Update any UI that depends on categories
                    updateWorkflowUI();
                }
            } catch (error) {
                console.error('Failed to load workflow categories:', error);
                // Fallback to default categories
                window.workflowCategories = [
                    { id: 'master', name: 'Master (Orchestration)' },
                    { id: 'core', name: 'Core (Primary Tasks)' },
                    { id: 'support', name: 'Support (Utility)' }
                ];
            }
        }
        
        // Load categories on page load
        loadWorkflowCategories();
        
        // Update workflow UI when categories change
        function updateWorkflowUI() {
            // If we're on the workflows tab, reload workflows
            const workflowsTab = document.getElementById('workflowsTab');
            if (workflowsTab && workflowsTab.classList.contains('active')) {
                loadWorkflows();
            }
        }
        
        function getWorkflowCategoryOptions() {
            let options = '<option value="">Select Category</option>';
            window.workflowCategories.forEach(cat => {
                options += `<option value="${cat.id}">${escapeHtml(cat.name)}</option>`;
            });
            return options;
        }

        async function showWorkflowModal(workflow = null) {
            // Remove existing modal if present
            const existingModal = document.getElementById('workflowEditModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Reload categories from backend before showing modal
            await loadWorkflowCategories();
            
            // Create new modal
            const modal = document.createElement('div');
            modal.id = 'workflowEditModal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 900px;">
                    <div class="modal-header">
                        <h2 id="workflowModalTitle">Add New Workflow</h2>
                        <span class="close-button" onclick="closeWorkflowModal()">&times;</span>
                    </div>
                    <form id="workflowEditForm">
                        <div class="form-group">
                            <label for="workflowCategory">Category</label>
                            <select id="workflowCategory" name="workflowCategory" required style="width: 100%; padding: 8px; background: #1a1a1a; color: #e0e0e0; border: 1px solid #333; border-radius: 4px;">
                                ${getWorkflowCategoryOptions()}
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="workflowYaml">Workflow YAML Definition</label>
                            <textarea id="workflowYaml" name="workflowYaml" required 
                                style="width: 100%; min-height: 500px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 13px; line-height: 1.5; background: #0a0a0a; color: #e0e0e0; border: 1px solid #333; padding: 10px;"
                                onkeyup="validateNewWorkflowYaml()"
                                spellcheck="false"></textarea>
                            <small style="color: #666;">Define your workflow in YAML format. The workflow ID will be extracted from the metadata.</small>
                        </div>
                        
                        <div id="newWorkflowValidation" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                        
                        <div class="modal-buttons">
                            <button type="button" class="btn-cancel" onclick="closeWorkflowModal()">Cancel</button>
                            <button type="button" class="btn-save" id="saveNewWorkflowBtn" onclick="saveNewWorkflow()" disabled>Save Workflow</button>
                        </div>
                    </form>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Populate form
            if (workflow) {
                document.getElementById('workflowModalTitle').textContent = 'Edit Workflow';
                document.getElementById('workflowCategory').value = workflow.category || '';
                document.getElementById('workflowYaml').value = workflow.raw_yaml || '';
            } else {
                document.getElementById('workflowModalTitle').textContent = 'Add New Workflow';
                document.getElementById('workflowCategory').value = '';
                document.getElementById('workflowYaml').value = getWorkflowYamlTemplate();
            }
            
            modal.style.display = 'block';
            
            // Trigger initial validation
            validateNewWorkflowYaml();
        }
        
        function closeWorkflowModal() {
            const modal = document.getElementById('workflowEditModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Validation for new workflow YAML
        let newWorkflowValidationTimeout;
        function validateNewWorkflowYaml() {
            clearTimeout(newWorkflowValidationTimeout);
            
            const yamlContent = document.getElementById('workflowYaml').value;
            const validationDiv = document.getElementById('newWorkflowValidation');
            const saveBtn = document.getElementById('saveNewWorkflowBtn');
            
            newWorkflowValidationTimeout = setTimeout(() => {
                try {
                    // Parse YAML
                    const parsed = jsyaml.load(yamlContent);
                    
                    // Validate required metadata fields
                    if (!parsed.metadata || !parsed.metadata.id) {
                        throw new Error('Workflow must have metadata.id field');
                    }
                    if (!parsed.metadata.name) {
                        throw new Error('Workflow must have metadata.name field');
                    }
                    
                    // Check for valid workflow ID format
                    if (!/^[a-z0-9_]+$/.test(parsed.metadata.id)) {
                        throw new Error('Workflow ID must contain only lowercase letters, numbers, and underscores');
                    }
                    
                    // Show success
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#1a4d1a';
                    validationDiv.style.borderLeft = '4px solid #4ade80';
                    validationDiv.innerHTML = `<span style="color: #4ade80;">&#10003; Valid YAML - Workflow ID: ${parsed.metadata.id}</span>`;
                    
                    // Enable save button
                    saveBtn.disabled = false;
                    
                } catch (error) {
                    // Show error
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#4d1a1a';
                    validationDiv.style.borderLeft = '4px solid #f87171';
                    validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; ${escapeHtml(error.message)}</span>`;
                    
                    // Disable save button
                    saveBtn.disabled = true;
                }
            }, 500);
        }
        
        // Save new workflow
        async function saveNewWorkflow() {
            const yamlContent = document.getElementById('workflowYaml').value;
            const category = document.getElementById('workflowCategory').value;
            
            if (!category) {
                showNotification('Please select a category', 'error');
                return;
            }
            
            try {
                // Parse YAML to get metadata
                const parsed = jsyaml.load(yamlContent);
                const workflowId = parsed.metadata.id;
                const workflowName = parsed.metadata.name;
                
                // Create workflow object
                const newWorkflow = {
                    id: workflowId,
                    name: workflowName,
                    category: category,
                    raw_yaml: yamlContent,
                    metadata: parsed.metadata,
                    version: parsed.metadata.version || '1.0.0'
                };
                
                // Save to backend
                const response = await fetchAPI('/api/workflows', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(newWorkflow)
                });
                
                if (response && response.id) {
                    showNotification('Workflow created successfully', 'success');
                    closeWorkflowModal();
                    // Reload workflows
                    await loadWorkflows();
                } else {
                    throw new Error(response?.error || 'Failed to create workflow');
                }
                
            } catch (error) {
                console.error('Error saving workflow:', error);
                showNotification('Error saving workflow: ' + error.message, 'error');
            }
        }
        
        // YAML Edit Modal Functions
        function showYamlEditModal(workflow) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('yamlEditModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'yamlEditModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 90%; width: 1200px;">
                        <div class="modal-header">
                            <h2 id="yamlModalTitle">Edit Workflow: ${workflow.name}</h2>
                            <span class="close-button" onclick="closeYamlEditModal()">&times;</span>
                        </div>
                        <div style="padding: 20px;">
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px; color: #ccc;">Workflow ID: <span id="yamlWorkflowId" style="color: #3b82f6;">${workflow.id}</span></label>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label for="yamlContent" style="display: block; margin-bottom: 5px; color: #ccc;">YAML Content:</label>
                                <textarea id="yamlContent" 
                                    style="width: 100%; height: 500px; background: #0a0a0a; color: #e0e0e0; border: 1px solid #333; padding: 10px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 13px; line-height: 1.5; resize: vertical;"
                                    spellcheck="false"></textarea>
                            </div>
                            
                            <div id="yamlValidationMessage" style="margin-bottom: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                            
                            <div class="modal-buttons">
                                <button type="button" class="btn-cancel" onclick="closeYamlEditModal()">Cancel</button>
                                <button type="button" id="validateYamlBtn" class="btn-primary" onclick="validateYaml()" disabled>Validate</button>
                                <button type="button" id="saveYamlBtn" class="btn-save" onclick="saveYamlWorkflow()" disabled>Save</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add change listener to enable validate button
                const yamlContent = document.getElementById('yamlContent');
                yamlContent.addEventListener('input', onYamlContentChange);
            }
            
            // Store current workflow data
            modal.dataset.workflowId = workflow.id;
            modal.dataset.originalContent = JSON.stringify(workflow.raw_data, null, 2);
            
            // Update modal title
            document.getElementById('yamlModalTitle').textContent = `Edit Workflow: ${workflow.name}`;
            document.getElementById('yamlWorkflowId').textContent = workflow.id;
            
            // Load YAML content
            const yamlContent = document.getElementById('yamlContent');
            yamlContent.value = jsyaml.dump(workflow.raw_data);
            
            // Reset buttons
            document.getElementById('validateYamlBtn').disabled = true;
            document.getElementById('saveYamlBtn').disabled = true;
            document.getElementById('yamlValidationMessage').style.display = 'none';
            
            modal.style.display = 'block';
        }
        
        function closeYamlEditModal() {
            const modal = document.getElementById('yamlEditModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function onYamlContentChange() {
            const modal = document.getElementById('yamlEditModal');
            const originalContent = modal.dataset.originalContent;
            const currentContent = document.getElementById('yamlContent').value;
            
            // Convert current YAML to JSON for comparison
            try {
                const currentJson = JSON.stringify(jsyaml.load(currentContent), null, 2);
                const hasChanges = currentJson !== originalContent;
                
                // Enable validate button only if there are changes
                document.getElementById('validateYamlBtn').disabled = !hasChanges;
                document.getElementById('saveYamlBtn').disabled = true; // Always disable save until validated
                
                // Clear any previous validation messages
                if (hasChanges) {
                    document.getElementById('yamlValidationMessage').style.display = 'none';
                }
            } catch (e) {
                // If YAML is invalid, enable validate button to show error
                document.getElementById('validateYamlBtn').disabled = false;
                document.getElementById('saveYamlBtn').disabled = true;
            }
        }
        
        async function validateYaml() {
            const yamlContent = document.getElementById('yamlContent').value;
            const validationMessage = document.getElementById('yamlValidationMessage');
            
            try {
                // Call the API to validate
                const response = await fetch('http://localhost:8080/api/workflows/validate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ yaml: yamlContent })
                });
                
                const result = await response.json();
                
                if (result.valid) {
                    // Show success message
                    let message = '<span style="color: #10b981;">[OK] YAML is valid</span>';
                    if (result.warnings && result.warnings.length > 0) {
                        message += '<br><span style="color: #fbbf24;">Warnings:</span><ul style="margin: 5px 0; padding-left: 20px;">';
                        result.warnings.forEach(warning => {
                            message += `<li style="color: #fbbf24;">${warning}</li>`;
                        });
                        message += '</ul>';
                    }
                    validationMessage.innerHTML = message;
                    validationMessage.style.display = 'block';
                    validationMessage.style.backgroundColor = '#064e3b';
                    validationMessage.style.border = '1px solid #10b981';
                    
                    // Enable save button
                    document.getElementById('saveYamlBtn').disabled = false;
                } else {
                    // Show error messages
                    let message = '<span style="color: #ef4444;">[ERROR] Validation Failed</span>';
                    if (result.errors && result.errors.length > 0) {
                        message += '<br><span style="color: #ef4444;">Errors:</span><ul style="margin: 5px 0; padding-left: 20px;">';
                        result.errors.forEach(error => {
                            message += `<li style="color: #ef4444;">${error}</li>`;
                        });
                        message += '</ul>';
                    }
                    validationMessage.innerHTML = message;
                    validationMessage.style.display = 'block';
                    validationMessage.style.backgroundColor = '#7f1d1d';
                    validationMessage.style.border = '1px solid #ef4444';
                    
                    // Disable save button
                    document.getElementById('saveYamlBtn').disabled = true;
                }
                
            } catch (e) {
                // Show error message
                validationMessage.innerHTML = `<span style="color: #ef4444;">[ERROR] Validation Error: ${e.message}</span>`;
                validationMessage.style.display = 'block';
                validationMessage.style.backgroundColor = '#7f1d1d';
                validationMessage.style.border = '1px solid #ef4444';
                
                // Disable save button
                document.getElementById('saveYamlBtn').disabled = true;
            }
        }
        
        async function saveYamlWorkflow() {
            const modal = document.getElementById('yamlEditModal');
            const workflowId = modal.dataset.workflowId;
            const yamlContent = document.getElementById('yamlContent').value;
            
            try {
                // Show saving indicator
                const saveBtn = document.getElementById('saveYamlBtn');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;
                
                // Call the API to save
                const response = await fetch('http://localhost:8080/api/workflows/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        id: workflowId,
                        yaml: yamlContent 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showNotification('Workflow saved successfully!', 'success');
                    
                    // Reload workflows to show updated data
                    await loadWorkflows();
                    
                    // Close the modal
                    closeYamlEditModal();
                } else {
                    showNotification('Error saving workflow: ' + (result.error || 'Unknown error'), 'error');
                    // Restore button state
                    saveBtn.textContent = originalText;
                    saveBtn.disabled = false;
                }
                
            } catch (e) {
                showNotification('Error saving workflow: ' + e.message, 'error');
                // Restore button state
                const saveBtn = document.getElementById('saveYamlBtn');
                saveBtn.textContent = 'Save';
                saveBtn.disabled = false;
            }
        }
        
        function saveWorkflow() {
            const workflowId = document.getElementById('workflowId').value;
            const name = document.getElementById('workflowName').value.trim();
            const category = document.getElementById('workflowCategory').value;
            const description = document.getElementById('workflowDescription').value.trim();
            
            if (!name || !category || !description) {
                alert('Please provide name, category, and description');
                return;
            }
            
            if (workflowId) {
                // Edit existing
                const workflow = commonWorkflows.find(w => w.id === workflowId);
                if (workflow) {
                    workflow.name = name;
                    workflow.category = category;
                    workflow.description = description;
                }
            } else {
                // Add new
                const newWorkflow = {
                    id: 'wf' + Date.now(),
                    name: name,
                    category: category,
                    description: description
                };
                commonWorkflows.push(newWorkflow);
            }
            
            displayWorkflows();
            closeWorkflowModal();
            
            // Show save button as having changes
            const saveBtn = document.getElementById('savePersonasSettingsBtn');
            if (saveBtn) {
                saveBtn.classList.add('has-changes');
            }
        }
        
        async function deleteWorkflow(workflowId) {
            if (!confirm('Are you sure you want to delete this workflow?')) return;
            
            try {
                // Call the API to delete
                const response = await fetch(`http://localhost:8080/api/workflows/${workflowId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showNotification('Workflow deleted successfully!', 'success');
                    
                    // Reload workflows to show updated list
                    await loadWorkflows();
                } else {
                    showNotification('Error deleting workflow: ' + (result.error || 'Unknown error'), 'error');
                }
                
            } catch (e) {
                showNotification('Error deleting workflow: ' + e.message, 'error');
            }
        }
        
        async function showWorkflowDiagram(workflowId, diagramType) {
            try {
                // Fetch the diagram from the API
                const response = await fetch(`http://localhost:8080/api/workflows/${workflowId}/diagrams/${diagramType}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${diagramType} diagram`);
                }
                
                const diagram = await response.json();
                
                // Show the diagram in a modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.maxWidth = '90%';
                modalContent.style.maxHeight = '90vh';
                modalContent.style.overflow = 'auto';
                
                const closeBtn = document.createElement('span');
                closeBtn.className = 'close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => modal.remove();
                
                const title = document.createElement('h2');
                title.textContent = diagram.metadata?.title || `${diagramType.charAt(0).toUpperCase() + diagramType.slice(1)} Diagram`;
                title.style.marginBottom = '20px';
                
                modalContent.appendChild(closeBtn);
                modalContent.appendChild(title);
                
                if (diagram.format === 'mermaid') {
                    // Create a div for the mermaid diagram
                    const diagramDiv = document.createElement('div');
                    diagramDiv.className = 'mermaid';
                    diagramDiv.textContent = diagram.content;
                    modalContent.appendChild(diagramDiv);
                    
                    // Render the mermaid diagram
                    modal.appendChild(modalContent);
                    document.body.appendChild(modal);
                    
                    // Use mermaid to render the diagram
                    mermaid.run({
                        querySelector: '.mermaid',
                        suppressErrors: true
                    });
                } else if (diagram.format === 'html') {
                    // For RACI matrix, display the HTML content
                    const containerDiv = document.createElement('div');
                    containerDiv.innerHTML = diagram.content;
                    modalContent.appendChild(containerDiv);
                    
                    modal.appendChild(modalContent);
                    document.body.appendChild(modal);
                } else {
                    // Display as plain text
                    const pre = document.createElement('pre');
                    pre.style.whiteSpace = 'pre-wrap';
                    pre.style.color = '#ccc';
                    pre.textContent = diagram.content;
                    modalContent.appendChild(pre);
                    
                    modal.appendChild(modalContent);
                    document.body.appendChild(modal);
                }
                
                // Close modal when clicking outside
                modal.onclick = (event) => {
                    if (event.target === modal) {
                        modal.remove();
                    }
                };
                
            } catch (error) {
                console.error('Error loading diagram:', error);
                showNotification(`Failed to load ${diagramType} diagram: ${error.message}`, 'error');
            }
        }
        
        async function savePersonasSettings() {
            try {
                // Save to localStorage
                localStorage.setItem('commonWorkflows', JSON.stringify(commonWorkflows));
                
                // Show success message
                showSettingsMessage('Common workflows saved successfully!', 'success', 'personas');
                
                // Reset save button state
                const saveBtn = document.getElementById('savePersonasSettingsBtn');
                if (saveBtn) {
                    saveBtn.classList.remove('has-changes');
                }
                
                // Optionally save to backend if API exists
                try {
                    await fetchAPI('/api/settings/workflows', {
                        method: 'POST',
                        body: JSON.stringify({ workflows: commonWorkflows })
                    });
                } catch (error) {
                    // Ignore backend errors, localStorage is the primary storage
                    console.log('Backend save skipped:', error);
                }
            } catch (error) {
                showSettingsMessage('Error saving workflows: ' + error.message, 'error', 'personas');
            }
        }
        
        function showNotification(message, type = 'info') {
            // Simple notification - we can enhance this later
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${type === 'success' ? '#22c55e' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
                color: white;
                border-radius: 5px;
                z-index: 2000;
                animation: fadeIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        async function loadPersonaDetails() {
            if (!selectedPersona) {
                await loadSystemLogs();
                return;
            }
            
            const personas = await fetchAPI('/api/personas');
            const persona = personas[selectedPersona];
            
            // Get saved configuration
            const config = personaConfigs[selectedPersona] || {};
            const displayName = config.firstName && config.lastName 
                ? `${config.firstName} ${config.lastName}` 
                : persona.info.name;
            const displayRole = config.role || persona.info.role;
            const displayEmail = config.email || `${selectedPersona}.bot@insitec.com.au`;
            
            const content = document.getElementById('mainContent');
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>${displayName}</h2>
                    <button class="btn-save" onclick="openPersonaEditModal('${selectedPersona}')" style="padding: 8px 20px;">
                        &#9998; Edit Profile
                    </button>
                </div>
                <p><strong>Email:</strong> ${displayEmail}</p>
                <p><strong>Role:</strong> ${displayRole}</p>
                <p><strong>Status:</strong> ${persona.state.status}</p>
                <p><strong>Work Items Completed:</strong> ${persona.state.work_items_completed}</p>
                ${persona.state.current_work_item ? 
                    `<p><strong>Current Work Item:</strong> ${persona.state.current_work_item}</p>` : ''}
                ${persona.state.last_activity ? 
                    `<p><strong>Last Activity:</strong> ${new Date(persona.state.last_activity).toLocaleString()}</p>` : ''}
                
                <div style="display: flex; gap: 40px; margin-top: 20px; flex: 1; overflow-y: auto;">
                    <div style="flex: 1; min-width: 45%;">
                        <p style="margin-bottom: 5px; position: sticky; top: 0; background: #0a0a0a; padding: 5px 0;"><strong>Skills:</strong></p>
                        <ul style="margin: 0; padding-left: 20px; color: #e0e0e0;">
                            ${(config.skills || persona.info.skills).split(',').map(skill => 
                                `<li style="margin-bottom: 4px;">${skill.trim()}</li>`
                            ).join('')}
                        </ul>
                    </div>
                    
                    <div style="flex: 1;">
                        <p style="margin-bottom: 5px; position: sticky; top: 0; background: #0a0a0a; padding: 5px 0;"><strong>Tools:</strong></p>
                        ${renderPersonaTools(displayRole)}
                    </div>
                </div>
            `;
        }
        
        
        function showSystemLogs() {
            selectedPersona = null;
            document.querySelectorAll('.persona-card').forEach(card => {
                card.classList.remove('selected');
            });
            loadSystemLogs();
        }

        async function loadSystemLogs() {
            try {
                const logs = await fetchAPI('/api/logs?limit=100&format=formatted');
                const content = document.getElementById('mainContent');
                
                content.innerHTML = `
                    <div style="display: flex; flex-direction: column; height: 100%;">
                        <h2>System Logs</h2>
                        <div class="log-filters" style="margin-bottom: 10px;">
                            <button class="filter-btn active" onclick="filterLogs('all')">All</button>
                            <button class="filter-btn" onclick="filterLogs('error')">Error</button>
                            <button class="filter-btn" onclick="filterLogs('warning')">Warning</button>
                            <button class="filter-btn" onclick="filterLogs('info')">Info</button>
                            <button class="filter-btn" onclick="filterLogs('success')">Success</button>
                            <button class="filter-btn" onclick="filterLogs('debug')">Debug</button>
                            <button class="filter-btn" onclick="filterLogs('verbose')">Verbose</button>
                        </div>
                        <div class="log-viewer" id="logViewer" style="font-family: 'Consolas', 'Courier New', monospace; flex: 1; margin-bottom: 20px; display: flex; flex-direction: column;">
                            <div style="display: flex; margin-bottom: 5px; font-weight: bold; border-bottom: 1px solid #333; padding-bottom: 5px; flex-shrink: 0;">
                                <span style="flex: 0 0 31ch; color: #999;">Date/Time <button onclick="toggleLogSort()" id="sortBtn" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px; padding: 0; margin-left: 5px;">${window.currentLogSort === 'oldest' ? '&#9650;' : '&#9660;'}</button></span>
                                <span style="flex: 0 0 8ch;">Level</span>
                                <span style="flex: 0 0 14ch; color: #66b3ff;">Source</span>
                                <span style="flex: 1; padding-left: 10px;">Description</span>
                            </div>
                            <div style="flex: 1; overflow-y: auto; min-height: 0;">
                                ${(window.currentLogSort === 'oldest' ? logs : logs.reverse()).map(log => {
                            const original = log.original || log;
                            const parts = parseLogEntry(original);
                            return `
                                <div class="log-entry ${original.level.toLowerCase()}" data-level="${original.level.toLowerCase()}" style="display: flex; margin-bottom: 2px;">
                                    <span style="flex: 0 0 31ch; color: #999;">${parts.timestamp} </span>
                                    <span style="flex: 0 0 8ch; font-weight: bold;">${parts.level}</span>
                                    <span style="flex: 0 0 14ch; color: #66b3ff;">${parts.source}</span>
                                    <span style="flex: 1; padding-left: 10px; white-space: pre-wrap; word-break: break-word;">${parts.message}</span>
                                </div>
                            `;
                        }).join('')}
                            </div>
                        </div>
                    </div>
                `;
                
                // Scroll based on sort order
                const logViewer = document.getElementById('logViewer');
                if (logViewer) {
                    const scrollableArea = logViewer.querySelector('div[style*="overflow-y: auto"]');
                    if (scrollableArea) {
                        if (window.currentLogSort === 'newest') {
                            // Newest at bottom (down arrow), scroll to bottom
                            scrollableArea.scrollTop = scrollableArea.scrollHeight;
                        } else {
                            // Oldest at bottom (up arrow), scroll to top
                            scrollableArea.scrollTop = 0;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load logs:', error);
            }
        }
        
        // Parse log entry into components
        function parseLogEntry(log) {
            const timestamp = log.timestamp || new Date().toISOString();
            const level = (log.level || 'INFO').toUpperCase().padEnd(8);
            const source = (log.persona_name || log.source || 'SYSTEM').substring(0, 14).padEnd(14);
            const message = log.message || '';
            return { timestamp, level, source, message };
        }
        
        async function toggleAPI() {
            if (apiRunning) {
                // Stop API
                if (confirm('Are you sure you want to stop the API server? This will stop all operations.')) {
                    try {
                        // For now, we'll just alert the user
                        alert('To stop the API server, use: pkill -f real_factory_api.py');
                    } catch (e) {
                        // Expected to fail as server shuts down
                    }
                }
            } else {
                // Restart API
                try {
                    // Try to restart via a special endpoint
                    const response = await fetch(`${API_BASE}/api/restart`, { method: 'POST' });
                } catch (e) {
                    // If that fails, the server is truly down
                    alert('API server is offline. To start it, run:\n\n./start_api.sh\n\nor\n\npython3 src/api/real_factory_api.py');
                }
                // Check status after a delay
                setTimeout(() => updateDashboard(), 3000);
            }
        }
        
        async function toggleFactory() {
            if (!apiRunning) {
                alert('Please start the API server first');
                return;
            }
            
            try {
                const endpoint = factoryRunning ? '/api/factory/stop' : '/api/factory/start';
                const action = factoryRunning ? 'stop' : 'start';
                await fetchAPI(endpoint, { method: 'POST' });
                await updateDashboard();
                // Refresh logs to show start/stop event if currently viewing logs
                const mainContent = document.getElementById('mainContent');
                if (mainContent.innerHTML.includes('System Logs')) {
                    await loadSystemLogs();
                }
            } catch (error) {
                const action = factoryRunning ? 'stop' : 'start';
                alert(`Failed to ${action} factory: ` + error.message);
            }
        }
        
        function refreshData() {
            updateDashboard();
            if (selectedPersona) {
                loadPersonaDetails();
            } else {
                loadSystemLogs();
            }
        }
        
        async function showWorkQueue() {
            selectedPersona = null;
            document.querySelectorAll('.persona-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            try {
                // Use Azure work queue data if available, otherwise fetch it
                let azureData = window.azureWorkQueueData;
                if (!azureData) {
                    azureData = await fetchAPI('/api/work-queue-azure');
                }
                
                const content = document.getElementById('mainContent');
                
                // Format date for display
                function formatDate(dateStr) {
                    if (!dateStr) return 'N/A';
                    const date = new Date(dateStr);
                    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                }
                
                content.innerHTML = `
                    <h2>Work Queue</h2>
                    <div style="margin-bottom: 10px;">
                        <small style="color: #888;">Total items in queue: ${azureData.total || 0}</small>
                    </div>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                            <thead>
                                <tr style="background: #2a2a2a; border-bottom: 2px solid #444;">
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Item No</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Project</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Persona</th>
                                    <th style="padding: 10px; text-align: left; min-width: 300px;">Description</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">State</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Date Created</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Date Started</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${azureData.work_items && azureData.work_items.length > 0 ? azureData.work_items.map(item => `
                                    <tr style="border-bottom: 1px solid #333;">
                                        <td style="padding: 10px; color: #3b82f6;">#${item.id}</td>
                                        <td style="padding: 10px;">${item.project || 'Unknown'}</td>
                                        <td style="padding: 10px;">${item.assignedTo || 'Unassigned'}</td>
                                        <td style="padding: 10px;">${item.title || 'No description'}</td>
                                        <td style="padding: 10px;">
                                            <span style="padding: 2px 8px; border-radius: 4px; font-size: 12px; background: ${
                                                item.state === 'New' ? '#3b82f6' :
                                                item.state === 'Active' ? '#22c55e' :
                                                item.state === 'Resolved' ? '#a855f7' : '#888'
                                            };">
                                                ${item.state || 'Unknown'}
                                            </span>
                                        </td>
                                        <td style="padding: 10px; font-size: 12px; color: #888;">${formatDate(item.createdDate)}</td>
                                        <td style="padding: 10px; font-size: 12px; color: #888;">
                                            ${item.state !== 'New' ? formatDate(item.changedDate || item.createdDate) : 'Not started'}
                                        </td>
                                    </tr>
                                `).join('') : `
                                    <tr>
                                        <td colspan="7" style="padding: 20px; text-align: center; color: #888;">No items in work queue</td>
                                    </tr>
                                `}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to load work queue:', error);
                const content = document.getElementById('mainContent');
                content.innerHTML = `
                    <h2>Work Queue</h2>
                    <p style="color: #ef4444;">Failed to load work queue: ${error.message}</p>
                `;
            }
        }
        
        async function showCompletedItems() {
            selectedPersona = null;
            document.querySelectorAll('.persona-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            try {
                // Use Azure completed items data if available, otherwise fetch it
                let azureData = window.azureCompletedItemsData;
                if (!azureData) {
                    azureData = await fetchAPI('/api/completed-items-azure');
                }
                
                const content = document.getElementById('mainContent');
                
                // Format date for display
                function formatDate(dateStr) {
                    if (!dateStr) return 'N/A';
                    const date = new Date(dateStr);
                    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                }
                
                content.innerHTML = `
                    <h2>Completed Items</h2>
                    <div style="margin-bottom: 10px;">
                        <small style="color: #888;">Total completed: ${azureData.total || 0}</small>
                    </div>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                            <thead>
                                <tr style="background: #2a2a2a; border-bottom: 2px solid #444;">
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Item No</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Project</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Persona</th>
                                    <th style="padding: 10px; text-align: left; min-width: 300px;">Description</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">State</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Date Assigned</th>
                                    <th style="padding: 10px; text-align: left; white-space: nowrap;">Date Completed</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${azureData.completed_items && azureData.completed_items.length > 0 ? azureData.completed_items.map(item => `
                                    <tr style="border-bottom: 1px solid #333;">
                                        <td style="padding: 10px; color: #22c55e;">#${item.id}</td>
                                        <td style="padding: 10px;">${item.project || 'Unknown'}</td>
                                        <td style="padding: 10px;">${item.assignedTo || 'Unassigned'}</td>
                                        <td style="padding: 10px;">${item.title || 'No description'}</td>
                                        <td style="padding: 10px;">
                                            <span style="padding: 2px 8px; border-radius: 4px; font-size: 12px; background: ${
                                                item.state === 'Closed' ? '#22c55e' :
                                                item.state === 'Done' ? '#3b82f6' :
                                                item.state === 'Resolved' ? '#a855f7' : '#888'
                                            };">
                                                ${item.state || 'Unknown'}
                                            </span>
                                        </td>
                                        <td style="padding: 10px; font-size: 12px; color: #888;">${formatDate(item.createdDate)}</td>
                                        <td style="padding: 10px; font-size: 12px; color: #888;">${formatDate(item.completedDate)}</td>
                                    </tr>
                                `).join('') : `
                                    <tr>
                                        <td colspan="7" style="padding: 20px; text-align: center; color: #888;">No completed items yet</td>
                                    </tr>
                                `}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to load completed items:', error);
                const content = document.getElementById('mainContent');
                content.innerHTML = `
                    <h2>Completed Items</h2>
                    <p style="color: #ef4444;">Failed to load completed items: ${error.message}</p>
                `;
            }
        }
        
        function showSettings() {
            selectedPersona = null;
            document.querySelectorAll('.persona-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            const content = document.getElementById('mainContent');
            content.innerHTML = `
                <h2>Settings</h2>
                
                <!-- Tab buttons -->
                <div class="settings-tabs">
                    <button class="tab-button active" onclick="switchSettingsTab('azure-devops')">Azure DevOps</button>
                    <button class="tab-button" onclick="switchSettingsTab('system')">System</button>
                    <button class="tab-button" onclick="switchSettingsTab('repository')">Repository</button>
                    <button class="tab-button" onclick="switchSettingsTab('workflows')">Workflows</button>
                    <button class="tab-button" onclick="switchSettingsTab('personas')">Personas</button>
                    <button class="tab-button" onclick="switchSettingsTab('mcp-servers')">MCP Servers</button>
                    <button class="tab-button" onclick="switchSettingsTab('tools')">Tools</button>
                    <button class="tab-button" onclick="switchSettingsTab('agents')">Agents</button>
                </div>
                
                <!-- Azure DevOps Tab -->
                <div id="azure-devops-tab" class="tab-content active">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 style="margin-top: 0; color: #3b82f6;">Azure DevOps Configuration</h3>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Organization URL</label>
                            <input type="text" id="orgUrl" placeholder="https://dev.azure.com/yourorg" 
                                   style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                          border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                            <small style="color: #888;">Example: https://dev.azure.com/data6</small>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Personal Access Token (PAT)</label>
                            <div style="position: relative;">
                                <input type="password" id="patToken" placeholder="Enter PAT token (stored securely)" 
                                       style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                              border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                <span id="patTokenStatus" style="position: absolute; right: 10px; top: 12px; font-size: 12px;"></span>
                            </div>
                            <small style="color: #888;">Create a PAT with Work Items (Read, Write) and Project (Read) scopes</small>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                <i class="fas fa-lock"></i> Your PAT will be encrypted and stored securely
                            </small>
                        </div>
                        
                        <div style="display: flex; gap: 10px;">
                            <button id="saveSettingsBtn" class="save-btn" onclick="saveSettings()">Save Settings</button>
                            <button id="testConnectionBtn" class="test-btn" onclick="testConnection()">Test Connection</button>
                        </div>
                        
                        <div id="settingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                    
                    <div id="projectsSection" style="margin-top: 20px; display: none;">
                        <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                            <h3 style="margin-top: 0; color: #3b82f6;">Project Configuration</h3>
                            <div id="projectsList">
                                <!-- Projects and persona matrix will be loaded here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- System Tab -->
                <div id="system-tab" class="tab-content" style="max-height: calc(100vh - 200px); overflow-y: auto; overflow-x: hidden;">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 style="margin-top: 0; color: #3b82f6;">System Configuration</h3>
                        
                        <!-- System Settings Section (Collapsible) -->
                        <div class="workflow-section" id="system-settings-section" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="toggleSystemSettingsSection()">
                                <h4 class="workflow-section-title">System Settings</h4>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">Log Retention</h4>
                                    <div style="margin-bottom: 20px;">
                                        <label style="display: block; margin-bottom: 5px; color: #ccc;">System Log Retention (days)</label>
                                        <input type="number" id="systemLogRetentionDays" min="1" max="365" value="7" 
                                               style="width: 250px; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                        <small style="display: block; margin-top: 5px; color: #888;">System logs older than this will be automatically deleted</small>
                                    </div>
                                    <div style="margin-bottom: 20px;">
                                        <label style="display: block; margin-bottom: 5px; color: #ccc;">Persona Log Retention (days)</label>
                                        <input type="number" id="personaLogRetentionDays" min="1" max="365" value="7" 
                                               style="width: 250px; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                        <small style="display: block; margin-top: 5px; color: #888;">Persona logs older than this will be automatically deleted</small>
                                    </div>
                                    <div style="display: flex; gap: 10px;">
                                        <button id="saveSystemSettingsBtn" class="save-btn" onclick="saveSystemSettings()">Save Settings</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- System Prompt Section (Collapsible like workflows) -->
                        <div class="workflow-section" id="system-prompt-section" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="toggleSystemPromptSection()">
                                <h4 class="workflow-section-title">System Prompt</h4>
                                <span class="workflow-section-count">Version <span id="systemPromptVersionHeader">1.0.0</span></span>
                                <span class="workflow-section-toggle">&#9660;</span>
                                <div style="flex: 1;"></div>
                                <div class="workflow-actions" onclick="event.stopPropagation()">
                                    <button class="btn-icon" onclick="editSystemPromptName()" title="Edit prompt name">
                                        &#9998;
                                    </button>
                                </div>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">System Prompt Definition</h4>
                                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <small style="color: #888;">Base prompt for all AI personas. Individual persona prompts will build on top of this.</small>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="viewSystemPromptHistory()">
                                                <span style="margin-right: 5px;">&#128220;</span>History
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="exportSystemPrompt()">
                                                <span style="margin-right: 5px;">&#128228;</span>Export
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="importSystemPrompt()">
                                                <span style="margin-right: 5px;">&#128229;</span>Import
                                            </button>
                                        </div>
                                    </div>
                                    <textarea id="systemPrompt" rows="20" 
                                              onchange="trackSystemPromptChange()" 
                                              oninput="onSystemPromptEdit()"
                                              style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                                     border-radius: 4px; color: #e0e0e0; font-size: 14px; font-family: 'Courier New', monospace;
                                                     resize: vertical; min-height: 400px;">
                                    </textarea>
                                    <div id="system-prompt-validation" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    <div style="margin-top: 10px;">
                                        <input type="text" id="systemPromptChangeNotes" 
                                               placeholder="Change notes (optional)" 
                                               onchange="trackSystemPromptChange()"
                                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                    </div>
                                    <div style="margin-top: 15px; color: #888; font-size: 12px;">
                                        <div style="display: flex; justify-content: space-between;">
                                            <div style="display: flex; gap: 10px;">
                                                <button class="btn-save system-prompt-save-btn" 
                                                        onclick="saveSystemPrompt()" 
                                                        style="padding: 8px 20px;" disabled>
                                                    Save System Prompt
                                                </button>
                                            </div>
                                            <span>Version: <span id="systemPromptVersion" style="color: #3b82f6;">1.0.0</span> | Last updated: <span id="systemPromptUpdated" style="color: #3b82f6;">Never</span></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        
                        <div id="systemSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
                
                <!-- Repository Tab -->
                <div id="repository-tab" class="tab-content" style="max-height: calc(100vh - 200px); overflow-y: auto; overflow-x: hidden;">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 style="margin-top: 0; color: #3b82f6;">Repository Configuration</h3>
                        
                        <!-- Repository Structure Section (Collapsible like system prompt) -->
                        <div class="workflow-section" id="repository-structure-section" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="toggleRepositoryStructureSection()">
                                <h4 class="workflow-section-title">Repository Structure</h4>
                                <span class="workflow-section-count">Version <span id="repositoryStructureVersionHeader">1</span></span>
                                <span class="workflow-section-toggle">&#9660;</span>
                                <div style="flex: 1;"></div>
                                <div class="workflow-actions" onclick="event.stopPropagation()">
                                    <button class="btn-icon" onclick="editRepositoryStructureName()" title="Edit structure name">
                                        &#9998;
                                    </button>
                                </div>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">Repository Structure Definition</h4>
                                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <small style="color: #888;">Define the entire directory structure for Enterprise DevSecOps projects.</small>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" onclick="viewRepositoryStructureHistory()" title="View version history">
                                                History
                                            </button>
                                            <button class="btn-secondary" onclick="exportRepositoryStructure()" title="Export structure">
                                                Export
                                            </button>
                                            <button class="btn-secondary" onclick="importRepositoryStructure()" title="Import structure">
                                                Import
                                            </button>
                                        </div>
                                    </div>
                                    <textarea id="repositoryStructure" 
                                             placeholder="Enter your repository structure definition here..." 
                                             onchange="trackRepositoryStructureChange()"
                                             oninput="trackRepositoryStructureChange(); validateRepositoryStructure()"
                                             style="width: 100%; padding: 15px; background: #2a2a2a; border: 1px solid #444; 
                                                    border-radius: 4px; color: #e0e0e0; font-family: 'Consolas', 'Monaco', monospace; 
                                                    font-size: 14px; line-height: 1.5; resize: vertical; min-height: 400px;">
                                    </textarea>
                                    <div id="repository-structure-validation" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    <div style="margin-top: 10px;">
                                        <input type="text" id="repositoryStructureChangeNotes" 
                                               placeholder="Change notes (optional)" 
                                               onchange="trackRepositoryStructureChange()"
                                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; margin-bottom: 10px;">
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <div style="display: flex; justify-content: space-between;">
                                            <div style="display: flex; gap: 10px;">
                                                <button class="btn-save repository-structure-save-btn" 
                                                        onclick="saveRepositoryStructure()" 
                                                        style="padding: 8px 20px;" disabled>
                                                    Save Repository Structure
                                                </button>
                                            </div>
                                            <span>Version: <span id="repositoryStructureVersion" style="color: #3b82f6;">1</span> | Last updated: <span id="repositoryStructureUpdated" style="color: #3b82f6;">Never</span></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Branching Strategy Section (Collapsible like system prompt) -->
                        <div class="workflow-section" id="branching-strategy-section" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="toggleBranchingStrategySection()">
                                <h4 class="workflow-section-title">Branching Strategy</h4>
                                <span class="workflow-section-count">Version <span id="branchingStrategyVersionHeader">1</span></span>
                                <span class="workflow-section-toggle">&#9660;</span>
                                <div style="flex: 1;"></div>
                                <div class="workflow-actions" onclick="event.stopPropagation()">
                                    <button class="btn-icon" onclick="editBranchingStrategyName()" title="Edit strategy name">
                                        &#9998;
                                    </button>
                                </div>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">Branching Strategy Definition</h4>
                                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <small style="color: #888;">Define the branching structure and strategy for AI Personas repository operations.</small>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" onclick="viewBranchingStrategyHistory()" title="View version history">
                                                History
                                            </button>
                                            <button class="btn-secondary" onclick="exportBranchingStrategy()" title="Export strategy">
                                                Export
                                            </button>
                                            <button class="btn-secondary" onclick="importBranchingStrategy()" title="Import strategy">
                                                Import
                                            </button>
                                        </div>
                                    </div>
                                    <textarea id="branchingStrategy" 
                                             placeholder="Enter your branching strategy definition here..." 
                                             onchange="trackBranchingStrategyChange()"
                                             oninput="trackBranchingStrategyChange(); validateBranchingStrategy()"
                                             style="width: 100%; padding: 15px; background: #2a2a2a; border: 1px solid #444; 
                                                    border-radius: 4px; color: #e0e0e0; font-family: 'Consolas', 'Monaco', monospace; 
                                                    font-size: 14px; line-height: 1.5; resize: vertical; min-height: 400px;">
                                    </textarea>
                                    <div id="branching-strategy-validation" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    <div style="margin-top: 10px;">
                                        <input type="text" id="branchingStrategyChangeNotes" 
                                               placeholder="Change notes (optional)" 
                                               onchange="trackBranchingStrategyChange()"
                                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; margin-bottom: 10px;">
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <div style="display: flex; justify-content: space-between;">
                                            <div style="display: flex; gap: 10px;">
                                                <button class="btn-save branching-strategy-save-btn" 
                                                        onclick="saveBranchingStrategy()" 
                                                        style="padding: 8px 20px;" disabled>
                                                    Save Branching Strategy
                                                </button>
                                            </div>
                                            <span>Version: <span id="branchingStrategyVersion" style="color: #3b82f6;">1</span> | Last updated: <span id="branchingStrategyUpdated" style="color: #3b82f6;">Never</span></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="repositoryMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
                
                <!-- Workflows Tab -->
                <div id="workflows-tab" class="tab-content">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 id="workflowsTitle" style="margin-top: 0; color: #3b82f6;">Workflow Definitions</h3>
                        
                        <p style="color: #999; margin-bottom: 20px;">
                            Manage YAML workflow definitions for the AI Personas system. Workflows are organized into
                            Master (orchestration), Core (primary tasks), and Support (utility) categories.
                        </p>
                        
                        <div id="workflowsList" class="workflows-container" style="max-height: 640px; overflow-y: auto; margin-bottom: 20px;">
                            <!-- Master Workflows Section -->
                            <div class="workflow-section" id="masterSection">
                                <div class="workflow-section-header" onclick="toggleWorkflowSection('masterSection')">
                                    <h4 class="workflow-section-title">Master Workflows</h4>
                                    <span class="workflow-section-count" id="masterCount">0</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                </div>
                                <div class="workflow-section-content" id="masterWorkflows">
                                    <div class="workflow-section-empty">Loading workflows...</div>
                                </div>
                            </div>
                            
                            <!-- Core Workflows Section -->
                            <div class="workflow-section" id="coreSection">
                                <div class="workflow-section-header" onclick="toggleWorkflowSection('coreSection')">
                                    <h4 class="workflow-section-title">Core Workflows</h4>
                                    <span class="workflow-section-count" id="coreCount">0</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                </div>
                                <div class="workflow-section-content" id="coreWorkflows">
                                    <div class="workflow-section-empty">Loading workflows...</div>
                                </div>
                            </div>
                            
                            <!-- Support Workflows Section -->
                            <div class="workflow-section" id="supportSection">
                                <div class="workflow-section-header" onclick="toggleWorkflowSection('supportSection')">
                                    <h4 class="workflow-section-title">Support Workflows</h4>
                                    <span class="workflow-section-count" id="supportCount">0</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                </div>
                                <div class="workflow-section-content" id="supportWorkflows">
                                    <div class="workflow-section-empty">Loading workflows...</div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="border-top: 1px solid #333; padding-top: 20px; flex-shrink: 0;">
                            <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                                <button type="button" class="btn-primary" onclick="addNewWorkflow()">
                                    <span style="font-size: 16px;">&plus;</span> Workflow
                                </button>
                                <button type="button" class="btn-primary" onclick="addNewWorkflowCategory()">
                                    <span style="font-size: 16px;">&plus;</span> Workflow Category
                                </button>
                            </div>
                            
                            <div style="display: flex; gap: 10px;">
                                <button id="saveWorkflowsBtn" class="save-btn" onclick="saveWorkflows()">Save Workflows</button>
                            </div>
                            
                            <div id="workflowsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Personas Tab -->
                <div id="personas-tab" class="tab-content" style="max-height: calc(100vh - 200px); overflow-y: auto; overflow-x: hidden;">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; max-width: 100%; box-sizing: border-box;">
                        <h3 style="margin-top: 0; color: #3b82f6;">Persona Management</h3>
                        
                        <div style="margin-bottom: 20px;">
                            <p style="color: #999; margin-bottom: 15px;">
                                Manage AI Persona instances. Create multiple instances of each persona type with customized configurations.
                            </p>
                            
                            <button id="createPersonaBtn" class="btn-primary" onclick="showCreatePersonaModal()">
                                <span style="font-size: 16px;">&plus;</span> Persona Type
                            </button>
                        </div>
                        
                        <!-- Persona Types Overview -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Available Persona Types (25)</h4>
                            <div id="personaTypesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                                <!-- Persona type cards will be loaded here -->
                            </div>
                        </div>
                        
                        <div id="personasSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
                
                <!-- MCP Servers Tab -->
                <div id="mcp-servers-tab" class="tab-content">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 style="margin-top: 0; color: #3b82f6;">MCP Server Configuration</h3>
                        
                        <p style="color: #999; margin-bottom: 20px;">
                            Configure Model Context Protocol (MCP) servers that personas can access. Enable or disable servers globally and manage permissions.
                        </p>
                        
                        <div id="mcpServersList">
                            <!-- MCP server cards will be loaded here -->
                            <div class="mcp-server-card" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h4 style="margin: 0; color: #e0e0e0;">Memory Server</h4>
                                        <p style="margin: 5px 0; color: #999; font-size: 14px;">Knowledge graph for persistent memory across sessions</p>
                                        <div style="margin-top: 10px;">
                                            <span style="color: #888; font-size: 12px;">Used by: 15 personas</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 15px;">
                                        <label class="toggle-switch">
                                            <input type="checkbox" checked onchange="toggleMCPServer('memory', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <button class="btn-secondary" onclick="configureMCPServer('memory')">Configure</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mcp-server-card" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h4 style="margin: 0; color: #e0e0e0;">Context7 Server</h4>
                                        <p style="margin: 5px 0; color: #999; font-size: 14px;">Up-to-date library documentation and code examples</p>
                                        <div style="margin-top: 10px;">
                                            <span style="color: #888; font-size: 12px;">Used by: 12 personas</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 15px;">
                                        <label class="toggle-switch">
                                            <input type="checkbox" checked onchange="toggleMCPServer('context7', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <button class="btn-secondary" onclick="configureMCPServer('context7')">Configure</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mcp-server-card" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h4 style="margin: 0; color: #e0e0e0;">Serena Server</h4>
                                        <p style="margin: 5px 0; color: #999; font-size: 14px;">Semantic code navigation and editing</p>
                                        <div style="margin-top: 10px;">
                                            <span style="color: #888; font-size: 12px;">Used by: 20 personas</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 15px;">
                                        <label class="toggle-switch">
                                            <input type="checkbox" checked onchange="toggleMCPServer('serena', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <button class="btn-secondary" onclick="configureMCPServer('serena')">Configure</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <button id="saveMCPSettingsBtn" class="save-btn" onclick="saveMCPSettings()">Save MCP Settings</button>
                        </div>
                        
                        <div id="mcpSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
                
                <!-- Tools Tab -->
                <div id="tools-tab" class="tab-content">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <h3 style="margin-top: 0; color: #3b82f6;">Tools Configuration</h3>
                        
                        <p style="color: #999; margin-bottom: 20px;">
                            Manage tools available to AI Personas. Tools are organized by category and can be enabled/disabled individually.
                        </p>
                        
                        <!-- Tool Management Buttons -->
                        <div style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center;">
                            <button class="btn-secondary" onclick="addToolCategory()">&plus; Add Category</button>
                            <button class="btn-secondary" onclick="importToolsFromMD()">Import from MD</button>
                            <button class="btn-secondary" onclick="exportToolsToMD()">Export to MD</button>
                            <div style="border-left: 1px solid #444; height: 20px; margin: 0 5px;"></div>
                            <button class="btn-secondary" onclick="expandAllCategories()">Expand All</button>
                            <button class="btn-secondary" onclick="collapseAllCategories()">Collapse All</button>
                            <div style="border-left: 1px solid #444; height: 20px; margin: 0 5px;"></div>
                            <button class="btn-secondary" id="allToolsBtn" onclick="setToolsFilter('all')" style="background: #3b82f6;">All Tools</button>
                            <button class="btn-secondary" id="enabledToolsBtn" onclick="setToolsFilter('enabled')">Enabled Tools</button>
                            <div style="flex-grow: 1; text-align: right;">
                                <input type="text" id="toolsSearchInput" placeholder="Search tools..." 
                                       onkeyup="searchTools()" 
                                       style="width: 300px; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                              border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                            </div>
                        </div>
                        
                        <!-- Tool Categories Container -->
                        <div id="toolCategoriesList" class="workflows-container" style="max-height: 640px; overflow-y: auto; margin-bottom: 20px;">
                            <!-- Tool categories will be loaded dynamically -->
                            <div class="workflow-section-empty">Loading tool categories...</div>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <button id="saveToolsSettingsBtn" class="save-btn" onclick="saveToolsSettings()">Save Tools Settings</button>
                        </div>
                        
                        <div id="toolsSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
                
                <!-- Agents Tab -->
                <div id="agents-tab" class="tab-content" style="max-height: calc(100vh - 200px); overflow-y: auto; overflow-x: hidden;">
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <div>
                                <h3 style="margin-top: 0; color: #3b82f6;">AI Agent Configuration</h3>
                                <p style="color: #999; margin: 5px 0 0 0;">
                                    Configure AI providers and select models for your multi-agent system. Click refresh to check for new models.
                                </p>
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button class="btn-secondary" onclick="addNewProvider()">
                                    <span style="font-size: 16px;">&plus;</span> Add Provider
                                </button>
                                <div style="border-left: 1px solid #444; height: 20px; margin: 0 5px;"></div>
                                <button class="btn-primary" onclick="refreshAllProviders()">
                                    Check for New Models
                                </button>
                                <button class="btn-secondary" onclick="exportModelConfig()">
                                    Export Config
                                </button>
                                <button class="btn-secondary" onclick="importModelConfig()">
                                    Import Config
                                </button>
                            </div>
                        </div>

                        <!-- Provider Sections -->
                        <div id="providersList" class="workflows-container" style="overflow-y: auto;">
                            
                            <!-- OpenAI Provider -->
                            <div class="workflow-section" id="provider-section-openai">
                                <div class="workflow-section-header" onclick="toggleProviderSection('openai')">
                                    <h4 class="workflow-section-title">OpenAI</h4>
                                    <span class="workflow-section-count">5</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                    <div style="margin-left: auto; display: flex; gap: 10px;">
                                        <button class="btn-icon" onclick="event.stopPropagation(); editProvider('openai')" title="Edit Provider">
                                            <span style="font-size: 16px;">&#9998;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); deleteProvider('openai')" title="Delete Provider">
                                            <span style="font-size: 16px;">&#128465;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); refreshProvider('openai')" title="Check for new models">
                                            Refresh
                                        </button>
                                        <label class="toggle-switch" onclick="event.stopPropagation();">
                                            <input type="checkbox" id="provider-openai" onchange="toggleProvider('openai', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </div>
                                </div>
                                <div class="workflow-section-content" id="openai-config">
                                    <div style="padding: 15px;">
                                        <p style="margin: 0 0 15px 0; color: #999; font-size: 14px;">GPT-5 unified system with up to 2M token context windows</p>
                                        <small id="openai-last-update" style="color: #666; display: none;"></small>
                                        
                                        <div style="margin-bottom: 15px;">
                                            <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 14px;">API Key</label>
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <input type="password" id="openai-api-key" placeholder="sk-..." 
                                                       style="flex: 1; padding: 8px; background: #1a1a1a; border: 1px solid #444; 
                                                              border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                                <span id="openai-api-key-status" style="color: #4CAF50; font-size: 14px; display: none;"></span>
                                            </div>
                                        </div>
                                        
                                        <div style="margin-bottom: 10px;">
                                            <label style="color: #ccc; font-size: 14px;">Select Models:</label>
                                        </div>
                                        
                                        <div id="openai-models" class="models-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                                        
                                        <!-- GPT-5 -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; position: relative;">
                                            <div style="position: absolute; top: 15px; right: 50px; background: #ef4444; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">NEW</div>
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">GPT-5</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Unified Intelligence</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Agentic Coding</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Architecture</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">74.9% on SWE-bench. 94.6% on AIME 2025. 45% fewer errors than GPT-4o.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: Dynamic (auto-routing)</div>
                                                        <div>Price: TBD (API launching)</div>
                                                        <div style="color: #22c55e;">&#10003; Unified System | &#10003; Extended Thinking</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-openai-gpt-5" value="gpt-5" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- GPT-5 Pro -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; position: relative;">
                                            <div style="position: absolute; top: 15px; right: 50px; background: #ef4444; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">NEW</div>
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">GPT-5 Pro</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Extended Reasoning</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Complex Analysis</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">88.4% on GPQA. 50-80% fewer tokens than o3.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: Extended reasoning</div>
                                                        <div>Price: Premium tier</div>
                                                        <div style="color: #3b82f6;">&#9889; Replaces o3-pro</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-openai-gpt-5-pro" value="gpt-5-pro" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- GPT-5 Mini -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; position: relative;">
                                            <div style="position: absolute; top: 15px; right: 50px; background: #ef4444; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">NEW</div>
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">GPT-5 Mini</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Cost-Effective</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">High Volume</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Efficient variant for high-volume applications.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: Optimized for speed</div>
                                                        <div>Price: Lower tier</div>
                                                        <div style="color: #22c55e;">&#10003; Fast Response</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-openai-gpt-5-mini" value="gpt-5-mini" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- GPT-4 Turbo -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">GPT-4 Turbo</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">General Purpose</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">128K Context</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Previous flagship model. Still excellent for most tasks.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 128,000 tokens</div>
                                                        <div>Price: $10/$30 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; JSON Mode | &#10003; Function Calling</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-openai-gpt-4-turbo" value="gpt-4-turbo" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- o3 -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">o3 (Legacy)</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Security Analysis</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Complex Reasoning</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Advanced reasoning. Being replaced by GPT-5 Pro.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $60/$240 per 1M</div>
                                                        <div style="color: #f59e0b;">&#9888; Deprecating soon</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-openai-o3" value="o3" style="margin-left: 10px;">
                                            </div>
                                        </div>
                                        
                                        </div>
                                        
                                        <!-- Provider action buttons -->
                                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                                            <button class="save-btn" onclick="saveProviderSettings('openai')">Save Provider</button>
                                            <button class="btn-secondary" onclick="testProviderConnection('openai')">Test Connection</button>
                                        </div>
                                        <div id="openai-provider-message" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Anthropic Provider -->
                            <div class="workflow-section" id="provider-section-anthropic">
                                <div class="workflow-section-header" onclick="toggleProviderSection('anthropic')">
                                    <h4 class="workflow-section-title">Anthropic</h4>
                                    <span class="workflow-section-count">5</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                    <div style="margin-left: auto; display: flex; gap: 10px;">
                                        <button class="btn-icon" onclick="event.stopPropagation(); editProvider('anthropic')" title="Edit Provider">
                                            <span style="font-size: 16px;">&#9998;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); deleteProvider('anthropic')" title="Delete Provider">
                                            <span style="font-size: 16px;">&#128465;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); refreshProvider('anthropic')" title="Check for new models">
                                            Refresh
                                        </button>
                                        <label class="toggle-switch" onclick="event.stopPropagation();">
                                            <input type="checkbox" id="provider-anthropic" onchange="toggleProvider('anthropic', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </div>
                                </div>
                                <div class="workflow-section-content" id="anthropic-config">
                                    <div style="padding: 15px;">
                                        <p style="margin: 0 0 15px 0; color: #999; font-size: 14px;">Claude 4 series - Best real-world coding performance with native MCP support</p>
                                        <small id="anthropic-last-update" style="color: #666; display: none;"></small>
                                        
                                        <div style="margin-bottom: 15px;">
                                            <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 14px;">API Key</label>
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <input type="password" id="anthropic-api-key" placeholder="sk-ant-..." 
                                                       style="flex: 1; padding: 8px; background: #1a1a1a; border: 1px solid #444; 
                                                              border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                                <span id="anthropic-api-key-status" style="color: #4CAF50; font-size: 14px; display: none;"></span>
                                            </div>
                                        </div>
                                        
                                        <div style="margin-bottom: 10px;">
                                            <label style="color: #ccc; font-size: 14px;">Select Models:</label>
                                        </div>
                                        
                                        <div id="anthropic-models" class="models-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                                        
                                        <!-- Claude Opus 4.1 -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; position: relative;">
                                            <div style="position: absolute; top: 15px; right: 50px; background: #22c55e; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">LATEST</div>
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Claude Opus 4.1</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Complex Reasoning</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Architecture</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Latest</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Latest Opus version. Enhanced performance for agent workflows.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $15/$75 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Native MCP | &#10003; Tool Use | &#10003; Computer Use</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-anthropic-claude-opus-4-1" value="claude-opus-4-1-20250805" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Claude 4 Opus -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Claude 4 Opus</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Complex Reasoning</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Debugging</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">72.5% on SWE-bench. Industry-leading for multi-hour workflows.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $15/$75 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Native MCP | &#10003; Tool Use</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-anthropic-claude-4-opus" value="claude-4-opus" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Claude 4 Sonnet -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Claude 4 Sonnet</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Code Generation</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Testing</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Documentation</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">72.7% on SWE-bench. Optimal balance with 64K output.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $3/$15 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Native MCP | &#10003; 64K Output</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-anthropic-claude-4-sonnet" value="claude-4-sonnet" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Claude 3.7 Sonnet -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Claude 3.7 Sonnet</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Analysis</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Problem Solving</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Toggleable extended thinking for complex analysis.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $3/$15 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Native MCP | &#10003; Extended Thinking</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-anthropic-claude-3-7-sonnet" value="claude-3-7-sonnet" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Claude 3.5 Haiku -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Claude 3.5 Haiku</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Rapid Prototyping</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Quick Tasks</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Blazing-fast. 40.6% on SWE-bench despite being smallest.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 200,000 tokens</div>
                                                        <div>Price: $0.80/$4 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Native MCP | &#10003; Fastest</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-anthropic-claude-3-5-haiku" value="claude-3-5-haiku" style="margin-left: 10px;">
                                            </div>
                                        </div>
                                        
                                        </div>
                                        
                                        <!-- Provider action buttons -->
                                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                                            <button class="save-btn" onclick="saveProviderSettings('anthropic')">Save Provider</button>
                                            <button class="btn-secondary" onclick="testProviderConnection('anthropic')">Test Connection</button>
                                        </div>
                                        <div id="anthropic-provider-message" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Google Gemini Provider -->
                            <div class="workflow-section" id="provider-section-gemini">
                                <div class="workflow-section-header" onclick="toggleProviderSection('gemini')">
                                    <h4 class="workflow-section-title">Google Gemini</h4>
                                    <span class="workflow-section-count">3</span>
                                    <span class="workflow-section-toggle">&#9660;</span>
                                    <div style="margin-left: auto; display: flex; gap: 10px;">
                                        <button class="btn-icon" onclick="event.stopPropagation(); editProvider('gemini')" title="Edit Provider">
                                            <span style="font-size: 16px;">&#9998;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); deleteProvider('gemini')" title="Delete Provider">
                                            <span style="font-size: 16px;">&#128465;</span>
                                        </button>
                                        <button class="btn-icon" onclick="event.stopPropagation(); refreshProvider('gemini')" title="Check for new models">
                                            Refresh
                                        </button>
                                        <label class="toggle-switch" onclick="event.stopPropagation();">
                                            <input type="checkbox" id="provider-gemini" onchange="toggleProvider('gemini', this.checked)">
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </div>
                                </div>
                                <div class="workflow-section-content" id="gemini-config">
                                    <div style="padding: 15px;">
                                        <p style="margin: 0 0 15px 0; color: #999; font-size: 14px;">Largest context windows (2M tokens) with native Python execution</p>
                                        <small id="gemini-last-update" style="color: #666; display: none;"></small>
                                        
                                        <div style="margin-bottom: 15px;">
                                            <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 14px;">API Key</label>
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <input type="password" id="gemini-api-key" placeholder="AI..." 
                                                       style="flex: 1; padding: 8px; background: #1a1a1a; border: 1px solid #444; 
                                                              border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                                <span id="gemini-api-key-status" style="color: #4CAF50; font-size: 14px; display: none;"></span>
                                            </div>
                                        </div>
                                        
                                        <div style="margin-bottom: 10px;">
                                            <label style="color: #ccc; font-size: 14px;">Select Models:</label>
                                        </div>
                                        
                                        <div id="gemini-models" class="models-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                                        
                                        <!-- Gemini 2.0 Pro Experimental -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Gemini 2.0 Pro Experimental</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Large Context</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Multimodal</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Largest context at 2M tokens. Experimental features.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 2,000,000 tokens</div>
                                                        <div>Price: Variable</div>
                                                        <div style="color: #f59e0b;">&#9888; MCP: Coming Apr 2025</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-gemini-2-0-pro-experimental" value="gemini-2.0-pro-experimental" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Gemini 2.5 Pro -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Gemini 2.5 Pro</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Python Execution</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Architecture</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Native Python execution in 30-second sandbox.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 1,000,000 tokens</div>
                                                        <div>Price: $1.25-$2.50/$10-$15 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; Python Sandbox | &#10003; JSON Schema</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-gemini-2-5-pro" value="gemini-2.5-pro" style="margin-left: 10px;">
                                            </div>
                                        </div>

                                        <!-- Gemini 2.5 Flash -->
                                        <div class="model-card" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                                <div style="flex: 1;">
                                                    <h5 style="margin: 0 0 8px 0; color: #3b82f6;">Gemini 2.5 Flash</h5>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px;">
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Cost-Effective</span>
                                                        <span class="tag" style="background: #374151; color: #9ca3af; padding: 2px 8px; border-radius: 12px; font-size: 11px;">Rapid Tasks</span>
                                                    </div>
                                                    <p style="margin: 0 0 8px 0; color: #999; font-size: 13px;">Best price-performance ratio. 22% efficiency gain.</p>
                                                    <div style="font-size: 12px; color: #888;">
                                                        <div>Context: 1,000,000 tokens</div>
                                                        <div>Price: $0.30/$2.50 per 1M</div>
                                                        <div style="color: #22c55e;">&#10003; JSON Schema</div>
                                                    </div>
                                                </div>
                                                <input type="checkbox" id="model-gemini-2-5-flash" value="gemini-2.5-flash" style="margin-left: 10px;">
                                            </div>
                                        </div>
                                        
                                        </div>
                                        
                                        <!-- Provider action buttons -->
                                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                                            <button class="save-btn" onclick="saveProviderSettings('gemini')">Save Provider</button>
                                            <button class="btn-secondary" onclick="testProviderConnection('gemini')">Test Connection</button>
                                        </div>
                                        <div id="gemini-provider-message" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Additional providers can be added here -->

                        </div>

                        <!-- Removed global save button - each provider now has its own Save/Test buttons -->
                        <!--
                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                            <button id="saveAgentsSettingsBtn" class="save-btn" onclick="saveAgentsSettings()">Save Agent Configuration</button>
                            <button class="btn-secondary" onclick="testSelectedModels()">Test Selected Models</button>
                        </div>
                        -->

                        <div id="agentsSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
            `;
            
            // Load settings and personas when Settings is opened
            loadSettings().catch(console.error);
            loadPersonaTypes().catch(console.error);
            loadPersonaInstances().catch(console.error);
            loadWorkflows().catch(console.error);
            loadMCPServers().catch(console.error);
            loadToolCategories().catch(console.error);
            
            // Add change tracking for settings inputs
            const orgUrlInput = document.getElementById('orgUrl');
            
            // Initialize tracking variables as global to persist across function calls
            window.originalOrgUrl = orgUrlInput.value;
            window.hasExistingPat = false;
            window.originalSystemLogRetention = '7';
            window.originalPersonaLogRetention = '7';
            
            // Function to update Test Connection button state
            window.updateTestButtonState = () => {
                const testBtn = document.getElementById('testConnectionBtn');
                // Since PAT is now from environment, button is always enabled
                testBtn.disabled = false;
                testBtn.textContent = 'Test Connection';
                testBtn.title = 'Test connection (uses AZURE_DEVOPS_PAT env variable)';
            };
            
            // Track changes for Azure DevOps tab
            window.trackAzureSettingsChanges = () => {
                const saveBtn = document.getElementById('saveSettingsBtn');
                
                const hasChanges = (orgUrlInput.value !== window.originalOrgUrl);
                
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                }
                
                // Also update test button state
                window.updateTestButtonState();
            };
            
            // Track changes for System tab
            window.trackSystemSettingsChanges = () => {
                const saveBtn = document.getElementById('saveSystemSettingsBtn');
                const systemLogRetention = document.getElementById('systemLogRetentionDays');
                const personaLogRetention = document.getElementById('personaLogRetentionDays');
                const systemPrompt = document.getElementById('systemPrompt');
                
                const hasChanges = (systemLogRetention && systemLogRetention.value !== window.originalSystemLogRetention) ||
                                 (personaLogRetention && personaLogRetention.value !== window.originalPersonaLogRetention) ||
                                 (systemPrompt && window.originalSystemPrompt !== undefined && 
                                  systemPrompt.value !== window.originalSystemPrompt);
                
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                }
            };
            
            orgUrlInput.addEventListener('input', window.trackAzureSettingsChanges);
            
            // Add listener for PAT token input
            const patTokenInput = document.getElementById('patToken');
            if (patTokenInput) {
                patTokenInput.addEventListener('input', window.trackAzureSettingsChanges);
            }
            
            // Add listeners for log retention settings
            const systemLogRetentionInput = document.getElementById('systemLogRetentionDays');
            const personaLogRetentionInput = document.getElementById('personaLogRetentionDays');
            const systemPromptTextarea = document.getElementById('systemPrompt');
            if (systemLogRetentionInput) {
                systemLogRetentionInput.addEventListener('input', window.trackSystemSettingsChanges);
            }
            if (personaLogRetentionInput) {
                personaLogRetentionInput.addEventListener('input', window.trackSystemSettingsChanges);
            }
            if (systemPromptTextarea) {
                systemPromptTextarea.addEventListener('input', window.trackSystemSettingsChanges);
            }
            
            // Initial test button state
            window.updateTestButtonState();
        }
        
        // Initialize log sort state
        window.currentLogSort = 'newest';
        
        function toggleLogSort() {
            window.currentLogSort = window.currentLogSort === 'newest' ? 'oldest' : 'newest';
            const sortBtn = document.getElementById('sortBtn');
            sortBtn.innerHTML = window.currentLogSort === 'newest' ? '&#9660;' : '&#9650;';
            loadSystemLogs();
        }
        
        function filterLogs(level) {
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => {
                if (!btn.id || btn.id !== 'sortBtn') {
                    btn.classList.remove('active');
                }
            });
            event.target.classList.add('active');
            
            // Filter log entries
            const logEntries = document.querySelectorAll('.log-entry');
            logEntries.forEach(entry => {
                if (level === 'all' || entry.dataset.level === level) {
                    entry.style.display = 'flex';
                } else {
                    entry.style.display = 'none';
                }
            });
            
            // Scroll based on sort order after filtering
            const logViewer = document.getElementById('logViewer');
            if (logViewer) {
                const scrollableArea = logViewer.querySelector('div[style*="overflow-y: auto"]');
                if (scrollableArea) {
                    if (window.currentLogSort === 'newest') {
                        // Newest at bottom (down arrow), scroll to bottom
                        scrollableArea.scrollTop = scrollableArea.scrollHeight;
                    } else {
                        // Oldest at bottom (up arrow), scroll to top
                        scrollableArea.scrollTop = 0;
                    }
                }
            }
        }
        
        async function loadSettings() {
            try {
                // First try to load from backend
                const settings = await fetchAPI('/api/settings');
                console.log('Loaded settings from backend:', settings);
                
                if (settings && settings.orgUrl) {
                    document.getElementById('orgUrl').value = settings.orgUrl;
                    
                    // Load log retention settings
                    if (settings.systemLogRetentionDays !== undefined) {
                        const systemLogInput = document.getElementById('systemLogRetentionDays');
                        if (systemLogInput) {
                            systemLogInput.value = settings.systemLogRetentionDays;
                            window.originalSystemLogRetention = String(settings.systemLogRetentionDays);
                        }
                    }
                    if (settings.personaLogRetentionDays !== undefined) {
                        const personaLogInput = document.getElementById('personaLogRetentionDays');
                        if (personaLogInput) {
                            personaLogInput.value = settings.personaLogRetentionDays;
                            window.originalPersonaLogRetention = String(settings.personaLogRetentionDays);
                        }
                    }
                    
                    // Handle PAT status display
                    const patInput = document.getElementById('patToken');
                    const patStatus = document.getElementById('patTokenStatus');
                    if (settings.hasPatToken) {
                        patInput.placeholder = 'PAT token saved (enter new value to change)';
                        patInput.value = ''; // Never show the actual token
                        if (patStatus) {
                            patStatus.innerHTML = '<span style="color: #4CAF50;">&#10003; Saved</span>';
                            if (settings.patTokenHint) {
                                patStatus.innerHTML += ` <span style="color: #888;">${settings.patTokenHint}</span>`;
                            }
                        }
                        
                        // Show a loading message
                        showSettingsMessage('Loading project configuration...', 'info');
                        
                        // Delay slightly to ensure DOM is ready
                        setTimeout(() => testConnection(true), 100);
                    } else {
                        if (patStatus) {
                            patStatus.innerHTML = '<span style="color: #f59e0b;">Not configured</span>';
                        }
                    }
                }
                
                // Store original values for change tracking
                if (window.originalOrgUrl !== undefined) {
                    window.originalOrgUrl = document.getElementById('orgUrl').value;
                    window.originalPatToken = '';
                }
                
                // Update test button state if we're in the settings view
                if (window.updateTestButtonState) {
                    window.updateTestButtonState();
                }
            } catch (error) {
                console.error('Failed to load settings from backend:', error);
                // Fallback to localStorage if backend not available
                const localSettings = localStorage.getItem('azureDevOpsSettings');
                if (localSettings) {
                    const { orgUrl } = JSON.parse(localSettings);
                    if (orgUrl) document.getElementById('orgUrl').value = orgUrl;
                }
            }
        }
        
        function switchSettingsTab(tabName) {
            // Check for unsaved changes if leaving persona type edit
            if (personaTypeHasUnsavedChanges && !checkUnsavedPersonaTypeChanges()) {
                return;
            }
            
            // Check for unsaved changes in any workflow
            if (window.workflowStates) {
                for (const workflowId in window.workflowStates) {
                    if (window.workflowStates[workflowId].hasChanges) {
                        const confirmLeave = confirm('You have unsaved changes in workflows. Are you sure you want to leave?');
                        if (!confirmLeave) {
                            return;
                        }
                        break;
                    }
                }
            }
            
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Add active class to selected tab and button
            const tabButton = document.querySelector(`[onclick="switchSettingsTab('${tabName}')"]`);
            const tabContent = document.getElementById(`${tabName}-tab`);
            
            if (tabButton) tabButton.classList.add('active');
            if (tabContent) tabContent.classList.add('active');
            
            // Load tab-specific data when tab is shown
            switch(tabName) {
                case 'personas':
                    loadPersonaTypes().catch(console.error);
                    break;
                case 'mcp-servers':
                    loadMCPServers().catch(console.error);
                    break;
                case 'tools':
                    loadToolCategories().catch(console.error);
                    break;
                case 'agents':
                    loadAgentConfiguration();
                    break;
                case 'workflows':
                    // Workflows are already loaded on settings open
                    break;
                case 'system':
                    // System settings are already loaded on settings open
                    // Always load system prompt to ensure it's current
                    loadSystemPrompt();
                    break;
                case 'repository':
                    // Load repository structure and branching strategy
                    loadRepositoryStructure();
                    loadBranchingStrategy();
                    break;
                case 'azure-devops':
                    // Azure DevOps settings are already loaded on settings open
                    break;
            }
        }
        
        async function saveSettings() {
            const orgUrl = document.getElementById('orgUrl').value.trim();
            const patTokenInput = document.getElementById('patToken');
            let patToken = patTokenInput ? patTokenInput.value.trim() : '';
            
            if (!orgUrl) {
                showSettingsMessage('Please enter the Organization URL', 'error');
                return;
            }
            
            try {
                // Prepare data
                const data = { orgUrl };
                
                // Add PAT token if provided
                if (patToken) {
                    data.patToken = patToken;
                }
                
                // Add log retention settings
                const systemLogRetention = document.getElementById('systemLogRetentionDays');
                const personaLogRetention = document.getElementById('personaLogRetentionDays');
                if (systemLogRetention) {
                    data.systemLogRetentionDays = parseInt(systemLogRetention.value) || 7;
                }
                if (personaLogRetention) {
                    data.personaLogRetentionDays = parseInt(personaLogRetention.value) || 7;
                }
                
                // Save to backend API
                const response = await fetchAPI('/api/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response.status === 'success') {
                    // Clear PAT from memory immediately
                    if (patToken) {
                        patTokenInput.value = '';
                        // Overwrite the variable to clear from memory
                        patToken = Array(patToken.length + 1).join('*');
                        patToken = null;
                        
                        // Update PAT status display
                        const patStatus = document.getElementById('patTokenStatus');
                        if (patStatus) {
                            patStatus.innerHTML = '<span style="color: #4CAF50;">&#10003; Saved</span>';
                        }
                        patTokenInput.placeholder = 'PAT token saved (enter new value to change)';
                    }
                    
                    // Also save to localStorage as backup (without PAT)
                    const storageData = { orgUrl };
                    localStorage.setItem('azureDevOpsSettings', JSON.stringify(storageData));
                    showSettingsMessage(response.message || 'Settings saved successfully!', 'success');
                    
                    // Update original values and reset button state
                    window.originalOrgUrl = orgUrl;
                    if (systemLogRetention) {
                        window.originalSystemLogRetention = systemLogRetention.value;
                    }
                    if (personaLogRetention) {
                        window.originalPersonaLogRetention = personaLogRetention.value;
                    }
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    saveBtn.classList.remove('has-changes');
                    
                    // Update test button state
                    if (window.updateTestButtonState) {
                        window.updateTestButtonState();
                    }
                    
                    // Test connection and load projects
                    setTimeout(() => {
                        testConnection();
                    }, 500);
                } else {
                    showSettingsMessage(response.error || 'Failed to save settings', 'error');
                }
            } catch (error) {
                showSettingsMessage('Error saving settings: ' + error.message, 'error');
            }
        }
        
        async function saveSystemSettings() {
            try {
                const systemLogRetention = document.getElementById('systemLogRetentionDays');
                const personaLogRetention = document.getElementById('personaLogRetentionDays');
                
                // Get the current orgUrl from the input field
                const orgUrl = document.getElementById('orgUrl').value.trim();
                
                if (!orgUrl) {
                    // If no org URL is set, we can't save settings
                    showSettingsMessage('Please configure Organization URL in Azure DevOps tab first', 'error');
                    return;
                }
                
                const data = {
                    orgUrl: orgUrl,  // Include the existing org URL
                    systemLogRetentionDays: parseInt(systemLogRetention.value) || 7,
                    personaLogRetentionDays: parseInt(personaLogRetention.value) || 7
                };
                
                // Save system prompt if it has changed
                const promptTextarea = document.getElementById('systemPrompt');
                let promptSaved = true;
                if (promptTextarea && window.originalSystemPrompt !== undefined && 
                    promptTextarea.value !== window.originalSystemPrompt) {
                    promptSaved = await saveSystemPrompt();
                }
                
                // Save to backend API
                const response = await fetchAPI('/api/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response.status === 'success' && promptSaved) {
                    showSettingsMessage(response.message || 'System settings saved successfully!', 'success');
                    
                    // Update tracking variables
                    window.originalSystemLogRetention = systemLogRetention.value;
                    window.originalPersonaLogRetention = personaLogRetention.value;
                    
                    // Reset button state
                    const saveBtn = document.getElementById('saveSystemSettingsBtn');
                    saveBtn.classList.remove('has-changes');
                    
                    // Emit event for other components
                    const event = new CustomEvent('settingsUpdated', {
                        detail: { 
                            source: 'system',
                            settings: data
                        }
                    });
                    window.dispatchEvent(event);
                } else {
                    showSettingsMessage(response.error || 'Failed to save system settings', 'error');
                }
            } catch (error) {
                showSettingsMessage('Error saving system settings: ' + error.message, 'error');
            }
        }
        
        // Initialize system prompt state
        let systemPromptState = {
            hasChanges: false,
            originalPrompt: '',
            currentVersion: '1.0.0',
            isExpanded: true,
            isValid: false
        };
        
        // Toggle system prompt section
        function toggleSystemPromptSection() {
            const section = document.getElementById('system-prompt-section');
            const content = section.querySelector('.workflow-section-content');
            const toggle = section.querySelector('.workflow-section-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.innerHTML = '&#9660;';
                systemPromptState.isExpanded = true;
            } else {
                content.classList.add('collapsed');
                toggle.innerHTML = '&#9650;';
                systemPromptState.isExpanded = false;
            }
        }
        
        function toggleSystemSettingsSection() {
            const section = document.getElementById('system-settings-section');
            const content = section.querySelector('.workflow-section-content');
            const toggle = section.querySelector('.workflow-section-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.innerHTML = '&#9660;';
            } else {
                content.classList.add('collapsed');
                toggle.innerHTML = '&#9650;';
            }
        }
        
        // Track system prompt changes
        function trackSystemPromptChange() {
            const textarea = document.getElementById('systemPrompt');
            const currentPrompt = textarea ? textarea.value : '';
            const hasChanges = currentPrompt !== systemPromptState.originalPrompt;
            
            systemPromptState.hasChanges = hasChanges;
            
            // Reset validation state when changes are made
            if (hasChanges && systemPromptState.isValid) {
                systemPromptState.isValid = false;
                const validationDiv = document.getElementById('system-prompt-validation');
                if (validationDiv) {
                    validationDiv.style.display = 'none';
                }
            }
            
            updateSystemPromptSaveButton(hasChanges);
        }
        
        // Real-time validation on edit
        let systemPromptValidationTimeout;
        function onSystemPromptEdit() {
            trackSystemPromptChange();
            
            const textarea = document.getElementById('systemPrompt');
            const validationDiv = document.getElementById('system-prompt-validation');
            
            if (!textarea || !validationDiv) return;
            
            // Clear previous timeout
            if (systemPromptValidationTimeout) {
                clearTimeout(systemPromptValidationTimeout);
            }
            
            // Set new timeout for automatic validation
            systemPromptValidationTimeout = setTimeout(async () => {
                try {
                    const promptContent = textarea.value;
                    
                    // Basic validation - just check it's not empty
                    if (!promptContent.trim()) {
                        throw new Error('System prompt cannot be empty');
                    }
                    
                    // Show success
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#1a4d1a';
                    validationDiv.style.border = '1px solid #2d7a2d';
                    validationDiv.innerHTML = '<span style="color: #4ade80;">&#10003; System prompt is valid</span>';
                    
                    // Enable save button
                    const saveBtn = document.querySelector('.system-prompt-save-btn');
                    if (saveBtn && systemPromptState.hasChanges) {
                        saveBtn.disabled = false;
                    }
                    
                    systemPromptState.isValid = true;
                    
                } catch (error) {
                    // Show error message
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#4d1a1a';
                    validationDiv.style.border = '1px solid #7a2d2d';
                    validationDiv.innerHTML = `<span style="color: #f87171;">&#10007; ${escapeHtml(error.message)}</span>`;
                    
                    // Disable save button
                    const saveBtn = document.querySelector('.system-prompt-save-btn');
                    if (saveBtn) {
                        saveBtn.disabled = true;
                    }
                    
                    systemPromptState.isValid = false;
                }
            }, 500);
        }
        
        // Update save button state
        function updateSystemPromptSaveButton(hasChanges) {
            const saveBtn = document.querySelector('.system-prompt-save-btn');
            
            if (saveBtn) {
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                    // Don't change disabled state here - let validation handle it
                } else {
                    saveBtn.classList.remove('has-changes');
                    saveBtn.disabled = true;
                }
            }
        }
        
        // Edit system prompt name
        async function editSystemPromptName() {
            const titleElement = document.querySelector('#system-prompt-section .workflow-section-title');
            const currentName = titleElement.textContent;
            
            const newName = prompt('Enter new name for the system prompt:', currentName);
            if (newName && newName !== currentName) {
                titleElement.textContent = newName;
                showNotification('System prompt name updated', 'success');
            }
        }
        
        // View system prompt history
        async function viewSystemPromptHistory() {
            try {
                const response = await fetchAPI('/api/prompts/system/history');
                
                if (!response || response.error) {
                    showNotification('Failed to load system prompt history', 'error');
                    return;
                }
                
                const history = response.history || [];
                
                if (history.length === 0) {
                    showNotification('No system prompt history available', 'info');
                    return;
                }
                
                // Build history modal content
                let historyHtml = `
                    <div style="max-height: 500px; overflow-y: auto;">
                        ${history.map((version) => {
                            const date = new Date(version.created_at);
                            const formattedDate = date.toLocaleString();
                            
                            return `
                                <div style="padding: 15px; margin-bottom: 10px; background: #2a2a2a; border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <strong>Version ${String(version.version).includes('.') ? version.version : '1.0.' + version.version}</strong>
                                            <span style="color: #3b82f6; margin-left: 10px;">${formattedDate}</span>
                                        </div>
                                        <button class="btn-secondary" onclick="restoreSystemPromptVersion(${version.version})" 
                                                style="padding: 5px 10px; font-size: 12px;">
                                            Restore
                                        </button>
                                    </div>
                                    ${version.change_notes ? `<div style="margin-top: 5px; color: #888; font-size: 12px;">${escapeHtml(version.change_notes)}</div>` : ''}
                                    <div style="margin-top: 10px;">
                                        <textarea readonly 
                                                  style="width: 100%; height: 100px; padding: 8px; 
                                                         background: #1a1a1a; border: 1px solid #444; 
                                                         border-radius: 4px; color: #e0e0e0; 
                                                         font-family: 'Courier New', monospace; 
                                                         font-size: 12px; resize: vertical;">
${escapeHtml(version.prompt)}
                                        </textarea>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                showModal('System Prompt History', historyHtml);
                
            } catch (error) {
                console.error('Error loading system prompt history:', error);
                showNotification('Error loading history: ' + error.message, 'error');
            }
        }
        
        // Export system prompt
        function exportSystemPrompt() {
            try {
                const promptTextarea = document.getElementById('systemPrompt');
                const version = document.getElementById('systemPromptVersion').textContent;
                
                const exportData = {
                    type: 'system_prompt',
                    version: version,
                    prompt: promptTextarea.value,
                    exported_at: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `system_prompt_v${version}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('System prompt exported successfully', 'success');
            } catch (error) {
                showNotification('Error exporting system prompt: ' + error.message, 'error');
            }
        }
        
        // Restore system prompt version
        async function restoreSystemPromptVersion(version) {
            try {
                const response = await fetchAPI(`/api/prompts/system/restore/${version}`, {
                    method: 'POST'
                });
                
                if (response && response.prompt) {
                    // Update the textarea
                    const promptTextarea = document.getElementById('systemPrompt');
                    if (promptTextarea) {
                        promptTextarea.value = response.prompt;
                        systemPromptState.originalPrompt = response.prompt;
                        systemPromptState.currentVersion = response.version;
                    }
                    
                    // Update version displays
                    const displayVersion = String(response.version).includes('.') ? String(response.version) : `1.0.${response.version}`;
                    const versionSpan = document.getElementById('systemPromptVersion');
                    const versionHeaderSpan = document.getElementById('systemPromptVersionHeader');
                    
                    if (versionSpan) {
                        versionSpan.textContent = displayVersion;
                    }
                    if (versionHeaderSpan) {
                        versionHeaderSpan.textContent = displayVersion;
                    }
                    
                    // Update timestamp
                    const updatedSpan = document.getElementById('systemPromptUpdated');
                    if (updatedSpan) {
                        updatedSpan.textContent = new Date().toLocaleString();
                    }
                    
                    // Close modal
                    const modal = document.getElementById('modal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                    
                    // Reset change tracking
                    systemPromptState.hasChanges = false;
                    updateSystemPromptSaveButton(false);
                    
                    showNotification('System prompt restored to version ' + displayVersion, 'success');
                } else {
                    showNotification('Failed to restore system prompt version', 'error');
                }
            } catch (error) {
                console.error('Error restoring system prompt version:', error);
                showNotification('Error restoring version: ' + error.message, 'error');
            }
        }
        
        // Import system prompt
        async function importSystemPrompt() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const content = await file.text();
                    const data = JSON.parse(content);
                    
                    if (data.type !== 'system_prompt') {
                        throw new Error('Invalid file type - not a system prompt export');
                    }
                    
                    const promptTextarea = document.getElementById('systemPrompt');
                    if (promptTextarea) {
                        promptTextarea.value = data.prompt;
                        trackSystemPromptChange();
                        showNotification('System prompt imported successfully', 'success');
                    }
                    
                } catch (error) {
                    console.error('Error importing system prompt:', error);
                    showNotification('Failed to import system prompt - invalid format', 'error');
                }
            };
            
            input.click();
        }
        
        // System Prompt Functions
        async function loadSystemPrompt() {
            try {
                const response = await fetchAPI('/api/prompts/system');
                if (response && response.prompt) {
                    const promptTextarea = document.getElementById('systemPrompt');
                    const versionSpan = document.getElementById('systemPromptVersion');
                    const versionHeaderSpan = document.getElementById('systemPromptVersionHeader');
                    const updatedSpan = document.getElementById('systemPromptUpdated');
                    
                    if (promptTextarea) {
                        promptTextarea.value = response.prompt;
                        systemPromptState.originalPrompt = response.prompt;
                    }
                    
                    // Convert simple integer version to semantic version for display
                    const rawVersion = response.version || '1.0.0';
                    const version = String(rawVersion).includes('.') ? String(rawVersion) : `1.0.${rawVersion}`;
                    systemPromptState.currentVersion = rawVersion; // Store raw version for backend
                    
                    if (versionSpan) {
                        versionSpan.textContent = version;
                    }
                    if (versionHeaderSpan) {
                        versionHeaderSpan.textContent = version;
                    }
                    if (updatedSpan && response.updated_at) {
                        const date = new Date(response.updated_at);
                        updatedSpan.textContent = date.toLocaleString();
                    }
                }
            } catch (error) {
                console.error('Error loading system prompt:', error);
            }
        }
        
        async function saveSystemPrompt() {
            try {
                const promptTextarea = document.getElementById('systemPrompt');
                const changeNotes = document.getElementById('systemPromptChangeNotes');
                
                if (!promptTextarea) {
                    showNotification('System prompt textarea not found', 'error');
                    return;
                }
                
                const prompt = promptTextarea.value.trim();
                
                if (!prompt) {
                    showNotification('System prompt cannot be empty', 'error');
                    return;
                }
                
                // Update version - increment from state
                const currentVersion = String(systemPromptState.currentVersion || '1.0.0');
                let newVersion;
                
                // Check if version is a simple number or semantic version
                if (currentVersion.includes('.')) {
                    // Semantic version (e.g., "1.0.3")
                    const versionParts = currentVersion.split('.');
                    versionParts[2] = (parseInt(versionParts[2]) + 1).toString();
                    newVersion = versionParts.join('.');
                } else {
                    // Simple integer version
                    newVersion = String(parseInt(currentVersion) + 1);
                }
                
                const response = await fetchAPI('/api/prompts/system', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        prompt: prompt,
                        version: newVersion,
                        change_notes: changeNotes ? changeNotes.value : ''
                    })
                });
                
                if (response && response.version) {
                    showNotification(response.message || 'System prompt saved successfully', 'success');
                    
                    // Update state
                    systemPromptState.hasChanges = false;
                    systemPromptState.originalPrompt = prompt;
                    systemPromptState.currentVersion = response.version; // Use the version from response
                    systemPromptState.isValid = false;
                    
                    // Hide validation message
                    const validationDiv = document.getElementById('system-prompt-validation');
                    if (validationDiv) {
                        validationDiv.style.display = 'none';
                    }
                    
                    // Update UI version displays
                    const versionSpan = document.getElementById('systemPromptVersion');
                    const versionHeaderSpan = document.getElementById('systemPromptVersionHeader');
                    // Convert to semantic version for display
                    const displayVersion = String(response.version).includes('.') ? String(response.version) : `1.0.${response.version}`;
                    if (versionSpan) {
                        versionSpan.textContent = displayVersion;
                    }
                    if (versionHeaderSpan) {
                        versionHeaderSpan.textContent = displayVersion;
                    }
                    
                    // Update timestamp
                    const updatedSpan = document.getElementById('systemPromptUpdated');
                    if (updatedSpan) {
                        updatedSpan.textContent = new Date().toLocaleString();
                    }
                    
                    // Clear change notes
                    if (changeNotes) {
                        changeNotes.value = '';
                    }
                    
                    // Update save button state
                    updateSystemPromptSaveButton(false);
                    
                } else {
                    showNotification(response?.error || 'Failed to save system prompt', 'error');
                }
            } catch (error) {
                console.error('Error saving system prompt:', error);
                showNotification('Error saving system prompt: ' + error.message, 'error');
            }
        }
        
        
        async function exportSystemPrompt() {
            try {
                const promptTextarea = document.getElementById('systemPrompt');
                if (!promptTextarea) return;
                
                const blob = new Blob([promptTextarea.value], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `system_prompt_v${document.getElementById('promptVersion')?.textContent || '1'}_${new Date().toISOString().split('T')[0]}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                showNotification('System prompt exported successfully', 'success');
            } catch (error) {
                showNotification('Error exporting system prompt: ' + error.message, 'error');
            }
        }
        
        async function importSystemPrompt() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.txt,.md';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const content = event.target.result;
                        const promptTextarea = document.getElementById('systemPrompt');
                        
                        if (promptTextarea && content) {
                            promptTextarea.value = content;
                            // Mark as changed
                            trackSystemSettingsChanges();
                            showNotification('System prompt imported. Remember to save!', 'info');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            } catch (error) {
                showNotification('Error importing system prompt: ' + error.message, 'error');
            }
        }
        
        async function testConnection(isAutoLoad = false) {
            const orgUrl = document.getElementById('orgUrl').value.trim();
            
            if (!orgUrl) {
                showSettingsMessage('Please enter the Organization URL', 'error');
                return;
            }
            
            // Only show testing message if not auto-loading
            if (!isAutoLoad) {
                showSettingsMessage('Testing connection...', 'info');
            }
            
            try {
                // Prepare data
                const data = { orgUrl };
                
                // Test connection via backend API
                const response = await fetchAPI('/api/test-connection', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response.status === 'success') {
                    // Show success message or clear loading message
                    if (isAutoLoad) {
                        // Clear the loading message
                        const messageEl = document.getElementById('settingsMessage');
                        messageEl.style.display = 'none';
                    } else {
                        showSettingsMessage(response.message, 'success');
                    }
                    
                    document.getElementById('projectsSection').style.display = 'block';
                    
                    // Display available projects sorted alphabetically
                    if (response.projects && response.projects.length > 0) {
                        const sortedProjects = response.projects.sort((a, b) => 
                            a.name.toLowerCase().localeCompare(b.name.toLowerCase())
                        );
                        displayProjects(sortedProjects);
                    }
                } else {
                    showSettingsMessage(response.message || 'Connection failed', 'error');
                }
            } catch (error) {
                showSettingsMessage('Connection test failed: ' + error.message, 'error');
            }
        }
        
        function showSettingsMessage(message, type, tab = null) {
            // Try to find the active message element based on which tab is active
            let messageEl = document.getElementById('settingsMessage');
            const systemTab = document.getElementById('system-tab');
            const personasTab = document.getElementById('personas-tab');
            
            if (tab === 'personas' || (personasTab && personasTab.classList.contains('active'))) {
                messageEl = document.getElementById('personasSettingsMessage');
            } else if (tab === 'system' || (systemTab && systemTab.classList.contains('active'))) {
                messageEl = document.getElementById('systemSettingsMessage');
            }
            
            if (messageEl) {
                messageEl.innerHTML = message.replace(/\n/g, '<br>') + '<span class="message-close" onclick="closeSettingsMessage()">&times;</span>';
                messageEl.style.display = 'block';
                messageEl.style.background = type === 'error' ? '#dc2626' : 
                                           type === 'success' ? '#22c55e' : 
                                           type === 'warning' ? '#f59e0b' : '#3b82f6';
                messageEl.style.whiteSpace = 'pre-wrap';
            }
        }
        
        function closeSettingsMessage() {
            // Close all message elements
            const settingsMessage = document.getElementById('settingsMessage');
            const systemSettingsMessage = document.getElementById('systemSettingsMessage');
            const personasSettingsMessage = document.getElementById('personasSettingsMessage');
            
            if (settingsMessage) settingsMessage.style.display = 'none';
            if (systemSettingsMessage) systemSettingsMessage.style.display = 'none';
            if (personasSettingsMessage) personasSettingsMessage.style.display = 'none';
        }
        
        async function displayProjects(projects) {
            const projectsList = document.getElementById('projectsList');
            
            if (!projects || projects.length === 0) {
                projectsList.innerHTML = '<p style="color: #888;">No projects found in this organization.</p>';
                return;
            }
            
            // Create project list with simple toggle for AI personas
            let html = '<h4 style="margin-bottom: 15px;">Select Projects for AI Personas:</h4>';
            html += '<div style="max-height: 400px; overflow-y: auto;">';
            
            projects.forEach(project => {
                // Get org URL for team settings link
                const orgUrl = document.getElementById('orgUrl').value.trim();
                const teamSettingsUrl = `${orgUrl}/${encodeURIComponent(project.name)}/_settings/teams`;
                
                html += `
                    <div class="project-item">
                        <div class="project-header">
                            <div>
                                <h5 style="margin: 0; color: #3b82f6;">${project.name}</h5>
                                <p style="margin: 5px 0 0 0; color: #888; font-size: 0.9em;">Project ID: ${project.id}</p>
                            </div>
                            <div class="project-controls">
                                <div id="warning-${project.id}" class="project-warning">
                                    <span class="project-warning-icon">!</span>
                                    <span>Team setup required</span>
                                </div>
                                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                    <span style="color: #ccc;">Enable AI Personas</span>
                                    <div class="toggle-switch">
                                        <input type="checkbox" 
                                               id="project-${project.id}" 
                                               data-project-id="${project.id}"
                                               data-project-name="${project.name}"
                                               onchange="toggleProjectAI(this)">
                                        <span class="toggle-slider"></span>
                                    </div>
                                </label>
                            </div>
                        </div>
                        <div id="team-link-${project.id}" class="team-setup-link">
                            <strong>&#9888; Manual setup required:</strong> AI Personas need to be added as team members.
                            <br>Go to: <a href="${teamSettingsUrl}" target="_blank">${teamSettingsUrl}</a>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '<button id="saveConfigBtn" class="save-btn" onclick="saveProjectConfiguration()" style="margin-top: 15px;">Save Configuration</button>';
            
            projectsList.innerHTML = html;
            
            // Load and apply saved configuration
            try {
                const configResponse = await fetchAPI('/api/project-configuration');
                if (configResponse.status === 'success' && configResponse.enabledProjects) {
                    // Apply saved configuration and check team membership for enabled projects
                    for (const projectId of configResponse.enabledProjects) {
                        const checkbox = document.getElementById(`project-${projectId}`);
                        if (checkbox) {
                            checkbox.checked = true;
                            
                            // Check team membership for this project
                            try {
                                const response = await fetchAPI('/api/check-team-membership', {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({
                                        projectId: checkbox.dataset.projectId,
                                        projectName: checkbox.dataset.projectName
                                    })
                                });
                                
                                if (response.status === 'success') {
                                    const membership = response.personaMembership;
                                    const memberCount = Object.keys(membership).length;
                                    const warningEl = document.getElementById(`warning-${projectId}`);
                                    const teamLinkEl = document.getElementById(`team-link-${projectId}`);
                                    
                                    if (memberCount === 0) {
                                        // Show warning for projects without team members
                                        warningEl.classList.add('visible');
                                        teamLinkEl.classList.add('visible');
                                    }
                                } else {
                                    // Show warning on error
                                    const warningEl = document.getElementById(`warning-${projectId}`);
                                    const teamLinkEl = document.getElementById(`team-link-${projectId}`);
                                    warningEl.classList.add('visible');
                                    teamLinkEl.classList.add('visible');
                                }
                            } catch (error) {
                                console.error('Failed to check team membership on load:', error);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load project configuration:', error);
            }
            
            // Store original configuration state for change tracking
            window.originalProjectConfig = [];
            const checkboxes = document.querySelectorAll('input[type="checkbox"][data-project-id]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    window.originalProjectConfig.push(checkbox.dataset.projectId);
                }
            });
        }
        
        async function toggleProjectAI(checkbox) {
            // Log project toggle
            console.log(`Toggled AI Personas for project ${checkbox.dataset.projectName}: ${checkbox.checked}`);
            
            // If enabling, check team membership
            if (checkbox.checked) {
                try {
                    const response = await fetchAPI('/api/check-team-membership', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            projectId: checkbox.dataset.projectId,
                            projectName: checkbox.dataset.projectName
                        })
                    });
                    
                    if (response.status === 'success') {
                        const membership = response.personaMembership;
                        const memberCount = Object.keys(membership).length;
                        const warningEl = document.getElementById(`warning-${checkbox.dataset.projectId}`);
                        const teamLinkEl = document.getElementById(`team-link-${checkbox.dataset.projectId}`);
                        
                        if (memberCount > 0) {
                            // Show which personas are already members
                            const memberList = Object.entries(membership).map(([persona, teams]) => 
                                `- ${persona} (in ${teams.length} team${teams.length > 1 ? 's' : ''})`
                            ).join('\n');
                            
                            showSettingsMessage(
                                `Found ${memberCount} AI Persona${memberCount > 1 ? 's' : ''} already in project teams:\n${memberList}`,
                                'info'
                            );
                            
                            // Hide warning if personas are members
                            warningEl.classList.remove('visible');
                            teamLinkEl.classList.remove('visible');
                        } else {
                            showSettingsMessage(
                                'No AI Personas found in project teams. They will need to be added manually.',
                                'warning'
                            );
                            
                            // Show warning indicator and setup link
                            warningEl.classList.add('visible');
                            teamLinkEl.classList.add('visible');
                        }
                    } else {
                        showSettingsMessage(
                            'Could not check team membership: ' + (response.error || 'Unknown error'),
                            'error'
                        );
                        
                        // Show warning on error too
                        const warningEl = document.getElementById(`warning-${checkbox.dataset.projectId}`);
                        const teamLinkEl = document.getElementById(`team-link-${checkbox.dataset.projectId}`);
                        warningEl.classList.add('visible');
                        teamLinkEl.classList.add('visible');
                    }
                } catch (error) {
                    console.error('Failed to check team membership:', error);
                    showSettingsMessage('Failed to check team membership', 'error');
                }
            } else {
                // If unchecking, hide the warning
                const warningEl = document.getElementById(`warning-${checkbox.dataset.projectId}`);
                const teamLinkEl = document.getElementById(`team-link-${checkbox.dataset.projectId}`);
                if (warningEl) warningEl.classList.remove('visible');
                if (teamLinkEl) teamLinkEl.classList.remove('visible');
            }
            
            // Check if configuration has changed
            const currentConfig = [];
            const checkboxes = document.querySelectorAll('input[type="checkbox"][data-project-id]');
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    currentConfig.push(cb.dataset.projectId);
                }
            });
            
            // Compare with original configuration
            const hasChanges = JSON.stringify(currentConfig.sort()) !== JSON.stringify(window.originalProjectConfig.sort());
            const saveBtn = document.getElementById('saveConfigBtn');
            if (saveBtn) {
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                }
            }
        }
        
        async function saveProjectConfiguration() {
            // Collect all enabled projects
            const enabledProjects = [];
            const checkboxes = document.querySelectorAll('input[type="checkbox"][data-project-id]');
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    enabledProjects.push({
                        projectId: checkbox.dataset.projectId,
                        projectName: checkbox.dataset.projectName
                    });
                }
            });
            
            // Show saving message
            const settingsMessage = document.getElementById('settingsMessage');
            settingsMessage.textContent = 'Saving configuration...';
            settingsMessage.style.display = 'block';
            settingsMessage.style.background = '#3b82f6';
            
            try {
                const response = await fetchAPI('/api/project-configuration', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ enabledProjects })
                });
                
                if (response.status === 'success') {
                    // Update message with success
                    settingsMessage.textContent = `&#10003; ${response.message}`;
                    settingsMessage.style.background = '#22c55e';
                    
                    // Update original configuration and reset button state
                    window.originalProjectConfig = enabledProjects.map(p => p.projectId);
                    const saveBtn = document.getElementById('saveConfigBtn');
                    if (saveBtn) {
                        saveBtn.classList.remove('has-changes');
                    }
                    
                    // Keep message visible for longer
                    setTimeout(() => {
                        settingsMessage.style.display = 'none';
                    }, 5000);
                } else {
                    showSettingsMessage(response.error || 'Failed to save configuration', 'error');
                }
            } catch (error) {
                showSettingsMessage('Error saving configuration: ' + error.message, 'error');
            }
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const personaModal = document.getElementById('personaEditModal');
            const workflowModal = document.getElementById('workflowEditModal');
            const yamlModal = document.getElementById('yamlEditModal');
            const categoryModal = document.getElementById('categoryModal');
            const toolModal = document.getElementById('toolModal');
            
            if (event.target === personaModal) {
                closePersonaModal();
            } else if (event.target === workflowModal) {
                closeWorkflowModal();
            } else if (event.target === yamlModal) {
                closeYamlEditModal();
            } else if (event.target === categoryModal) {
                closeCategoryModal();
            } else if (event.target === toolModal) {
                closeToolModal();
            }
        }
        
        // Initialize and start auto-refresh
        updateDashboard();
        loadSystemLogs();
        setInterval(updateDashboard, 2000);
        
        // Persona Management Functions
        async function loadPersonaTypes() {
            // Check for unsaved changes before loading
            if (personaTypeHasUnsavedChanges && !checkUnsavedPersonaTypeChanges()) {
                return;
            }
            
            try {
                const response = await fetchAPI('/api/personas/types');
                const typesGrid = document.getElementById('personaTypesGrid');
                if (!typesGrid) {
                    console.error('personaTypesGrid element not found');
                    return;
                }
                
                // Extract the types array from the response object
                const types = response.types || [];
                
                if (!types || types.length === 0) {
                    typesGrid.innerHTML = '<p style="color: #888;">No persona types available</p>';
                    return;
                }
                
                typesGrid.innerHTML = types.map(type => `
                    <div class="persona-type-card" onclick="showPersonaTypeDetails('${type.type || type.persona_type}')" style="background: #2a2a2a; padding: 15px; border-radius: 8px; cursor: pointer; transition: all 0.2s; position: relative;">
                        <button class="delete-button" onclick="event.stopPropagation(); deletePersonaType('${type.type || type.persona_type}')" 
                                title="Delete persona type" 
                                style="position: absolute; top: 10px; right: 10px; background: transparent; border: none; color: #ef4444; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s;">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                            </svg>
                        </button>
                        <h5 style="margin: 0 0 8px 0; color: #e0e0e0;">${type.display_name}</h5>
                        <p style="margin: 0 0 10px 0; color: #999; font-size: 13px;">${type.description}</p>
                        <div style="font-size: 12px; color: #888;">
                            <div>Category: ${type.category}</div>
                            <div>Default Name: ${type.default_first_name || 'N/A'}</div>
                            <div>Instances: ${type.instance_count || 0}</div>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading persona types:', error);
                document.getElementById('personaTypesGrid').innerHTML = 
                    '<p style="color: #ef4444;">Error loading persona types</p>';
            }
        }
        
        async function showPersonaTypeDetails(personaType) {
            try {
                // Always use the list endpoint until individual endpoints are implemented
                // This avoids 404 errors in production
                const listResponse = await fetchAPI('/api/personas/types');
                
                // Validate API response
                if (!listResponse || typeof listResponse !== 'object') {
                    throw new Error('Invalid API response format');
                }
                
                const types = listResponse.types || [];
                if (!Array.isArray(types)) {
                    throw new Error('Expected types array in API response');
                }
                
                let type = types.find(t => t && t.type === personaType);
                
                if (!type) {
                    showNotification('Persona type not found', 'error');
                    return;
                }
                
                // Note: Data is read-only until backend save endpoint is implemented
                
                console.log('Persona type data:', type);
                
                // Add default values if missing from API
                if (!type.default_last_name) type.default_last_name = 'Bot';
                if (!type.default_skills) {
                    // Provide some default skills based on type
                    const defaultSkillsMap = {
                        'devsecops-engineer': ['Threat modeling and risk assessment', 'CI/CD pipeline automation', 'Infrastructure as Code', 'Container security', 'SAST/DAST/IAST tool implementation'],
                        'software-architect': ['Cloud platform expertise', 'Microservices architecture design', 'Security architecture and compliance', 'API design and management', 'Distributed systems design'],
                        'developer-software-engineer': ['Version control (Git)', 'Unit testing', 'API development', 'Database design', 'Code review practices'],
                        'front-end-developer': ['React/Angular/Vue.js', 'HTML5/CSS3/JavaScript', 'Responsive design', 'State management', 'Performance optimization'],
                        'back-end-developer': ['RESTful API design', 'Database optimization', 'Authentication/Authorization', 'Microservices', 'Message queues'],
                        'qa-test-engineer': ['Test automation frameworks', 'Security testing', 'Performance testing', 'Test planning', 'Defect tracking'],
                        'scrum-master': ['Agile methodologies', 'Sprint planning', 'Conflict resolution', 'Team facilitation', 'Metrics tracking'],
                        'project-manager': ['Project planning', 'Risk management', 'Stakeholder communication', 'Budget management', 'Resource allocation'],
                        'product-owner': ['Product vision', 'Backlog management', 'User story writing', 'Market analysis', 'Stakeholder management'],
                        'business-analyst': ['Requirements gathering', 'Process modeling', 'Data analysis', 'Documentation', 'Stakeholder communication'],
                        'security-engineer': ['Security architecture', 'Vulnerability assessment', 'Penetration testing', 'Security monitoring', 'Incident response'],
                        'data-engineer': ['ETL/ELT pipelines', 'Big data technologies', 'Data warehousing', 'SQL/NoSQL', 'Data modeling'],
                        'database-administrator': ['Database optimization', 'Backup and recovery', 'Performance tuning', 'Security management', 'High availability'],
                        'mobile-developer': ['iOS/Android development', 'Cross-platform frameworks', 'Mobile UI/UX', 'App performance', 'Mobile security'],
                        'site-reliability-engineer': ['Infrastructure automation', 'Monitoring and alerting', 'Incident management', 'Capacity planning', 'Chaos engineering'],
                        'systems-architect': ['Enterprise architecture', 'Integration patterns', 'System design', 'Technology strategy', 'Solution architecture'],
                        'integration-engineer': ['API integration', 'Middleware technologies', 'Message brokers', 'ETL processes', 'System integration'],
                        'cloud-architect': ['Cloud platforms (AWS/Azure/GCP)', 'Cloud security', 'Cost optimization', 'Migration strategies', 'Multi-cloud architecture'],
                        'ai-engineer': ['Machine learning algorithms', 'Deep learning frameworks', 'Model deployment', 'Data preprocessing', 'MLOps practices'],
                        'requirements-analyst': ['Requirements elicitation', 'Use case development', 'Requirements traceability', 'Validation techniques', 'Documentation standards'],
                        'configuration-release-engineer': ['Release management', 'CI/CD pipelines', 'Version control', 'Deployment automation', 'Environment management'],
                        'engineering-manager': ['Team leadership', 'Performance management', 'Technical strategy', 'Process improvement', 'Cross-team collaboration'],
                        'security-architect': ['Security frameworks', 'Threat modeling', 'Security patterns', 'Compliance requirements', 'Zero-trust architecture'],
                        'technical-writer': ['Technical documentation', 'API documentation', 'User guides', 'Content management', 'Documentation tools']
                    };
                    type.default_skills = defaultSkillsMap[type.type] || ['Problem Solving', 'Communication'];
                }
                if (!type.default_tools) {
                    // Provide default tools based on persona type from recommendations
                    const defaultToolsMap = {
                        'devsecops-engineer': ['jenkins', 'gitlab', 'terraform', 'docker', 'kubernetes', 'sonarqube', 'vault', 'ansible'],
                        'software-architect': ['draw.io', 'confluence', 'aws', 'kubernetes', 'kafka', 'redis', 'datadog'],
                        'developer-software-engineer': ['vscode', 'git', 'docker', 'maven', 'junit', 'sonarqube', 'postman', 'jenkins'],
                        'front-end-developer': ['vscode', 'git', 'webpack', 'babel', 'jest', 'cypress', 'storybook', 'figma'],
                        'back-end-developer': ['vscode', 'git', 'docker', 'postman', 'redis', 'postgresql', 'kafka', 'jenkins'],
                        'qa-test-engineer': ['selenium', 'jmeter', 'postman', 'jenkins', 'jira', 'browserstack', 'cypress', 'sonarqube'],
                        'scrum-master': ['jira', 'confluence', 'miro', 'slack', 'teams', 'azure-devops'],
                        'project-manager': ['jira', 'ms-project', 'confluence', 'slack', 'ganttproject', 'azure-devops'],
                        'product-owner': ['jira', 'confluence', 'miro', 'figma', 'amplitude', 'mixpanel'],
                        'business-analyst': ['jira', 'confluence', 'visio', 'lucidchart', 'excel', 'power-bi'],
                        'security-engineer': ['burp-suite', 'nessus', 'metasploit', 'wireshark', 'nmap', 'splunk', 'qualys'],
                        'data-engineer': ['airflow', 'spark', 'kafka', 'dbt', 'snowflake', 'databricks', 'python'],
                        'database-administrator': ['mysql', 'postgresql', 'oracle', 'mongodb', 'redis', 'datadog'],
                        'mobile-developer': ['android-studio', 'xcode', 'flutter', 'react-native', 'firebase', 'appium'],
                        'site-reliability-engineer': ['prometheus', 'grafana', 'kubernetes', 'terraform', 'datadog', 'pagerduty'],
                        'systems-architect': ['visio', 'archimate', 'confluence', 'lucidchart', 'aws', 'azure'],
                        'integration-engineer': ['mulesoft', 'apache-camel', 'kafka', 'rabbitmq', 'postman', 'soapui'],
                        'cloud-architect': ['aws', 'azure', 'gcp', 'terraform', 'cloudformation', 'draw.io'],
                        'ai-engineer': ['tensorflow', 'pytorch', 'jupyter', 'mlflow', 'kubeflow', 'python'],
                        'requirements-analyst': ['jira', 'confluence', 'visio', 'balsamiq', 'lucidchart', 'doors'],
                        'configuration-release-engineer': ['jenkins', 'ansible', 'terraform', 'git', 'nexus', 'artifactory'],
                        'engineering-manager': ['jira', 'confluence', 'github', 'datadog', 'slack', 'okrs-tool'],
                        'security-architect': ['threat-modeler', 'archimate', 'visio', 'owasp', 'nist-tools'],
                        'technical-writer': ['confluence', 'madcap-flare', 'swagger', 'markdown', 'asciidoc', 'readthedocs']
                    };
                    type.default_tools = defaultToolsMap[type.type] || ['git', 'vscode', 'docker'];
                }
                
                // Get MCP servers HTML first
                const mcpServersHtml = await renderPersonaMCPServers(type.default_mcp_servers || []);
                
                // Update the personas tab content to show the detail view
                const personasTab = document.getElementById('personas-tab');
                if (!personasTab) return;
                
                // Initialize section expanded states
                if (!window.personaTypeSectionExpanded) {
                    window.personaTypeSectionExpanded = {};
                }
                
                // Reset unsaved changes flag and store original data
                personaTypeHasUnsavedChanges = false;
                personaTypeOriginalData = JSON.parse(JSON.stringify(type));
                
                personasTab.innerHTML = `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; max-width: 100%; box-sizing: border-box;">
                        <!-- Header with back button -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center;">
                                <button class="btn-secondary" onclick="if(checkUnsavedPersonaTypeChanges()) restorePersonasTab()" style="margin-right: 20px;">
                                    &larr; Back to Personas
                                </button>
                                <h3 style="margin: 0; color: #3b82f6;">Edit Persona Type: ${type.display_name}</h3>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn-cancel persona-type-cancel-btn" onclick="if(checkUnsavedPersonaTypeChanges()) loadPersonaTypes()" style="padding: 10px 30px;" disabled>
                                    Cancel
                                </button>
                                <button class="btn-save persona-type-save-btn" onclick="savePersonaType('${personaType}')" style="padding: 10px 30px;" disabled>
                                    Save Changes
                                </button>
                            </div>
                        </div>
                        
                        <!-- Basic Info Section -->
                        <!-- Expand/Collapse All Buttons -->
                        <div style="margin-bottom: 20px; display: flex; justify-content: flex-end; gap: 10px;">
                            <button class="btn-secondary" onclick="expandAllPersonaSections()" style="padding: 6px 16px;">
                                Expand All
                            </button>
                            <button class="btn-secondary" onclick="collapseAllPersonaSections()" style="padding: 6px 16px;">
                                Collapse All
                            </button>
                        </div>
                        
                        <div class="workflow-section" id="section-basic-info" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-basic-info', 'basic-info')">
                                <h4 class="workflow-section-title">Basic Information</h4>
                                <span class="workflow-section-count"></span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px;">
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Persona Type Name</label>
                                            <input type="text" id="personaTypeName" value="${type.type}" 
                                                   onchange="trackPersonaTypeChanges()"
                                                   style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                          border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        </div>
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Display Name</label>
                                            <input type="text" id="personaDisplayName" value="${type.display_name || ''}" 
                                                   onchange="trackPersonaTypeChanges()"
                                                   style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                          border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        </div>
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Default First Name</label>
                                            <input type="text" id="defaultFirstName" value="${type.default_first_name || ''}" 
                                                   onchange="trackPersonaTypeChanges()"
                                                   style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                          border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        </div>
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Default Last Name</label>
                                            <input type="text" id="defaultLastName" value="${type.default_last_name || 'Bot'}" 
                                                   onchange="trackPersonaTypeChanges()"
                                                   style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                          border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        </div>
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Category</label>
                                            <select id="personaCategory" onchange="trackPersonaTypeChanges()" style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                    border: 1px solid #444; color: #fff; border-radius: 4px;">
                                                <option value="development" ${type.category === 'development' ? 'selected' : ''}>Development</option>
                                                <option value="security" ${type.category === 'security' ? 'selected' : ''}>Security</option>
                                                <option value="operations" ${type.category === 'operations' ? 'selected' : ''}>Operations</option>
                                                <option value="quality" ${type.category === 'quality' ? 'selected' : ''}>Quality</option>
                                                <option value="management" ${type.category === 'management' ? 'selected' : ''}>Management</option>
                                                <option value="analysis" ${type.category === 'analysis' ? 'selected' : ''}>Analysis</option>
                                                <option value="data" ${type.category === 'data' ? 'selected' : ''}>Data</option>
                                                <option value="infrastructure" ${type.category === 'infrastructure' ? 'selected' : ''}>Infrastructure</option>
                                                <option value="product" ${type.category === 'product' ? 'selected' : ''}>Product</option>
                                                <option value="agile" ${type.category === 'agile' ? 'selected' : ''}>Agile</option>
                                                <option value="architecture" ${type.category === 'architecture' ? 'selected' : ''}>Architecture</option>
                                                <option value="integration" ${type.category === 'integration' ? 'selected' : ''}>Integration</option>
                                                <option value="ai" ${type.category === 'ai' ? 'selected' : ''}>AI</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label style="display: block; color: #888; margin-bottom: 5px;">Default Email Domain</label>
                                            <input type="text" id="defaultEmailDomain" value="${type.default_email_domain || '@company.com'}" 
                                                   placeholder="@company.com"
                                                   onchange="trackPersonaTypeChanges()"
                                                   style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                          border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        </div>
                                    </div>
                                    <div style="margin-top: 15px; margin-bottom: 15px;">
                                        <label style="display: block; color: #888; margin-bottom: 5px;">Short Description</label>
                                        <input type="text" id="personaDescription" value="${type.description || ''}" 
                                               onchange="trackPersonaTypeChanges()"
                                               style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                      border: 1px solid #444; color: #fff; border-radius: 4px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Persona Prompt Section -->
                        <div class="workflow-section" id="section-persona-prompt" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-persona-prompt', 'persona-prompt')">
                                <h4 class="workflow-section-title">Persona Prompt</h4>
                                <span class="workflow-section-count">Version ${type.external_version || '1.0'}</span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">Persona Prompt</h4>
                                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <small style="color: #888;">Base prompt for all AI personas. Individual persona prompts will build on top of this.</small>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="viewPersonaPromptHistory('${personaType}')">
                                                <span style="margin-right: 5px;">&#128220;</span>History
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="exportPersonaPrompt('${personaType}')">
                                                <span style="margin-right: 5px;">&#128228;</span>Export
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="importPersonaPrompt('${personaType}')">
                                                <span style="margin-right: 5px;">&#128229;</span>Import
                                            </button>
                                        </div>
                                    </div>
                                    <textarea id="personaPrompt" rows="20" 
                                              onchange="trackPersonaTypeChanges()" oninput="trackPersonaTypeChanges()"
                                              style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                                     border-radius: 4px; color: #e0e0e0; font-size: 14px; font-family: 'Courier New', monospace;
                                                     resize: vertical; min-height: 400px;">
${type.prompt || ''}
                                    </textarea>
                                    <div style="margin-top: 10px;">
                                        <input type="text" id="personaPromptChangeNotes" placeholder="Change notes (optional)" 
                                               onchange="trackPersonaTypeChanges()"
                                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                    </div>
                                    <div style="margin-top: 5px; color: #888; font-size: 12px;">
                                        Version: <span id="personaPromptVersion" style="color: #3b82f6;">${type.external_version || '1'}</span> | 
                                        Last updated: <span id="personaPromptUpdated" style="color: #3b82f6;">${type.prompt_last_updated ? new Date(type.prompt_last_updated).toLocaleString() : 'Never'}</span>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                                        <button id="savePersonaPromptBtn" class="save-btn" onclick="savePersonaPrompt('${personaType}')">Save Prompt</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- MCP Servers Section -->
                        <div class="workflow-section" id="section-mcp-servers" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-mcp-servers', 'mcp-servers')">
                                <h4 class="workflow-section-title">MCP Servers</h4>
                                <span class="workflow-section-count" id="mcp-servers-count">${(type.default_mcp_servers || []).length} selected</span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                            <div id="personaMCPServers" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                                ${mcpServersHtml}
                            </div>
                            <div style="display: flex; gap: 10px; margin-top: 20px;">
                                <button id="savePersonaMCPServersBtn" class="save-btn" onclick="savePersonaMCPServers('${personaType}')">Save MCP Servers</button>
                            </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Skills Section -->
                        <div class="workflow-section" id="section-skills" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-skills', 'skills')">
                                <h4 class="workflow-section-title">Default Skills</h4>
                                <span class="workflow-section-count">${(type.default_skills || []).length} skills</span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                <div id="personaTypeSkillsList" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                                    ${(type.default_skills || []).map((skill, index) => `
                                        <span class="skill-tag" data-skill="${skill}" style="background: #2a2a2a; padding: 5px 12px; 
                                              border-radius: 4px; border: 1px solid #444; color: #ccc; font-size: 13px; 
                                              display: flex; align-items: center; gap: 8px;">
                                            ${skill}
                                            <button onclick="removeTypeSkill('${skill}')" style="background: none; border: none; 
                                                    color: #888; cursor: pointer; font-size: 16px; padding: 0; line-height: 1;">
                                                &times;
                                            </button>
                                        </span>
                                    `).join('')}
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="newTypeSkillInput" placeholder="Add a new skill..." 
                                           onkeypress="if(event.key === 'Enter') addTypeSkill()"
                                           style="flex: 1; padding: 8px 12px; background: #2a2a2a; 
                                                  border: 1px solid #444; color: #fff; border-radius: 4px;">
                                    <button class="btn-primary" onclick="addTypeSkill()" style="padding: 8px 20px;">
                                        Add Skill
                                    </button>
                                </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Tools Section -->
                        <div class="workflow-section" id="section-tools" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-tools', 'tools')">
                                <h4 class="workflow-section-title">Default Tools</h4>
                                <span class="workflow-section-count" id="default-tools-count">${(type.default_tools || []).length} selected</span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <input type="text" id="typeToolsSearchInput" placeholder="Search tools..." 
                                       onkeyup="filterTypeTools()" 
                                       style="flex: 1; padding: 8px 12px; background: #2a2a2a; 
                                              border: 1px solid #444; color: #fff; border-radius: 4px;">
                                <button class="btn-secondary" onclick="expandAllTypeToolCategories()">
                                    Expand All
                                </button>
                                <button class="btn-secondary" onclick="collapseAllTypeToolCategories()">
                                    Collapse All
                                </button>
                                <button class="btn-secondary" onclick="showAllTypeTools()" id="showAllTypeToolsBtn">
                                    All Tools
                                </button>
                                <button class="btn-secondary" onclick="showSelectedTypeTools()" id="showSelectedTypeToolsBtn">
                                    Selected Tools
                                </button>
                            </div>
                            <div id="personaTypeToolsList" class="workflows-container" style="max-height: 640px; overflow-y: auto;">
                                <!-- Tool categories will be loaded here with expandable sections -->
                            </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Persona Workflow Section -->
                        <div class="workflow-section" id="section-persona-workflow" style="margin-bottom: 15px;">
                            <div class="workflow-section-header" onclick="togglePersonaTypeSection('section-persona-workflow', 'persona-workflow')">
                                <h4 class="workflow-section-title">Persona Workflow</h4>
                                <span class="workflow-section-count">Version ${type.workflow_version || '1.0'}</span>
                                <span class="workflow-section-toggle">&#9660;</span>
                            </div>
                            <div class="workflow-section-content">
                                <div style="padding: 20px;">
                                    <h4 style="color: #ccc; margin-bottom: 15px;">Persona Workflow</h4>
                                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <small style="color: #888;">Define the workflow in YAML format. This workflow will orchestrate how this persona type processes work items.</small>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="viewPersonaWorkflowHistory('${personaType}')">
                                                <span style="margin-right: 5px;">&#128220;</span>History
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="exportPersonaWorkflow('${personaType}')">
                                                <span style="margin-right: 5px;">&#128228;</span>Export
                                            </button>
                                            <button class="btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="importPersonaWorkflow('${personaType}')">
                                                <span style="margin-right: 5px;">&#128229;</span>Import
                                            </button>
                                        </div>
                                    </div>
                                    <textarea id="personaWorkflow" rows="20" 
                                              onchange="trackPersonaTypeChanges()" oninput="trackPersonaTypeChanges()"
                                              style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; 
                                                     border-radius: 4px; color: #e0e0e0; font-size: 14px; font-family: 'Courier New', monospace;
                                                     resize: vertical; min-height: 400px;">
${type.workflow_yaml || ''}
                                    </textarea>
                                    <div style="margin-top: 10px;">
                                        <input type="text" id="personaWorkflowChangeNotes" placeholder="Change notes (optional)" 
                                               onchange="trackPersonaTypeChanges()"
                                               style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                                      border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                                    </div>
                                    <div style="margin-top: 5px; color: #888; font-size: 12px;">
                                        Version: <span id="personaWorkflowVersion" style="color: #3b82f6;">${type.workflow_version || '1.0'}</span> | 
                                        Last updated: <span id="personaWorkflowUpdated" style="color: #3b82f6;">${type.workflow_last_updated ? new Date(type.workflow_last_updated).toLocaleString() : 'Never'}</span>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                                        <button id="savePersonaWorkflowBtn" class="save-btn" onclick="savePersonaWorkflow('${personaType}')">Save Workflow</button>
                                    </div>
                                    
                                    <!-- Workflow Visualization Buttons -->
                                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #444;">
                                        <h5 style="color: #888; margin-bottom: 10px;">Workflow Visualizations</h5>
                                        <div style="display: flex; gap: 10px;">
                                            <button class="btn-secondary" onclick="showWorkflowDiagram('${personaType}', 'orchestration')" title="View orchestration diagram" disabled>
                                                <span style="margin-right: 5px;">&#128200;</span>Orchestration
                                            </button>
                                            <button class="btn-secondary" onclick="showWorkflowDiagram('${personaType}', 'interaction')" title="View interaction diagram" disabled>
                                                <span style="margin-right: 5px;">&#128101;</span>Interaction
                                            </button>
                                            <button class="btn-secondary" onclick="showWorkflowDiagram('${personaType}', 'raci')" title="View RACI matrix" disabled>
                                                <span style="margin-right: 5px;">&#128203;</span>RACI
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Save/Cancel Buttons -->
                        <div style="display: flex; justify-content: flex-end; gap: 10px;">
                            <button class="btn-cancel persona-type-cancel-btn" onclick="if(checkUnsavedPersonaTypeChanges()) loadPersonaTypes()" style="padding: 10px 30px;" disabled>
                                Cancel
                            </button>
                            <button class="btn-save persona-type-save-btn" onclick="savePersonaType('${personaType}')" style="padding: 10px 30px;" disabled>
                                Save Changes
                            </button>
                        </div>
                    </div>
                `;
                
                // Load tools for this persona type
                await loadPersonaTypeTools(type.default_tools || []);
                
                // Store type data globally for save function
                window.currentEditingType = type;
                
            } catch (error) {
                console.error('Error showing persona type details:', error);
                showNotification('Failed to load persona details', 'error');
            }
        }
        
        // Track unsaved changes for persona type edit
        function trackPersonaTypeChanges() {
            personaTypeHasUnsavedChanges = true;
            updatePersonaTypeSaveButtons();
        }
        
        // Update save/cancel button states
        function updatePersonaTypeSaveButtons() {
            const saveButtons = document.querySelectorAll('.persona-type-save-btn');
            const cancelButtons = document.querySelectorAll('.persona-type-cancel-btn');
            
            saveButtons.forEach(btn => {
                if (personaTypeHasUnsavedChanges) {
                    btn.classList.add('has-changes');
                    btn.disabled = false;
                } else {
                    btn.classList.remove('has-changes');
                    btn.disabled = true;
                }
            });
            
            cancelButtons.forEach(btn => {
                btn.disabled = !personaTypeHasUnsavedChanges;
            });
        }
        
        // Check for unsaved changes before navigation
        function checkUnsavedPersonaTypeChanges() {
            if (personaTypeHasUnsavedChanges) {
                return confirm('You have unsaved changes. Are you sure you want to leave?');
            }
            return true;
        }
        
        // Track unsaved changes for workflow edit
        function trackWorkflowChanges() {
            workflowHasUnsavedChanges = true;
            updateWorkflowSaveButtons();
        }
        
        // Update save/cancel button states for workflow
        function updateWorkflowSaveButtons() {
            const saveButtons = document.querySelectorAll('.workflow-save-btn');
            const cancelButtons = document.querySelectorAll('.workflow-cancel-btn');
            
            saveButtons.forEach(btn => {
                if (workflowHasUnsavedChanges) {
                    btn.classList.add('has-changes');
                    btn.disabled = false;
                } else {
                    btn.classList.remove('has-changes');
                    btn.disabled = true;
                }
            });
            
            cancelButtons.forEach(btn => {
                btn.disabled = !workflowHasUnsavedChanges;
            });
        }
        
        // Expand all persona sections
        function expandAllPersonaSections() {
            const sections = document.querySelectorAll('.workflow-section');
            sections.forEach(section => {
                section.classList.remove('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9660;';
            });
        }
        
        // Collapse all persona sections
        function collapseAllPersonaSections() {
            const sections = document.querySelectorAll('.workflow-section');
            sections.forEach(section => {
                section.classList.add('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9650;';
            });
        }
        
        // Toggle persona type section
        function togglePersonaTypeSection(sectionId, sectionName) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            
            const isExpanded = !section.classList.contains('collapsed');
            
            if (isExpanded) {
                section.classList.add('collapsed');
            } else {
                section.classList.remove('collapsed');
            }
            
            // Update toggle icon
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isExpanded ? '&#9650;' : '&#9660;';
            }
            
            // Store expanded state
            if (!window.personaTypeSectionExpanded) {
                window.personaTypeSectionExpanded = {};
            }
            window.personaTypeSectionExpanded[sectionName] = !isExpanded;
        }
        
        // Helper functions for persona type editing
        function removeTypeSkill(skill) {
            const skillsList = document.getElementById('personaTypeSkillsList');
            const skillTag = skillsList.querySelector(`[data-skill="${skill}"]`);
            if (skillTag) {
                skillTag.remove();
            }
        }
        
        function addTypeSkill() {
            const input = document.getElementById('newTypeSkillInput');
            const skill = input.value.trim();
            
            if (!skill) return;
            
            // Check if skill already exists
            const skillsList = document.getElementById('personaTypeSkillsList');
            const existingSkills = Array.from(skillsList.querySelectorAll('[data-skill]'))
                .map(el => el.getAttribute('data-skill'));
            
            if (existingSkills.includes(skill)) {
                showNotification('Skill already exists', 'error');
                return;
            }
            
            // Add new skill tag
            const skillTag = document.createElement('span');
            skillTag.className = 'skill-tag';
            skillTag.setAttribute('data-skill', skill);
            skillTag.style = 'background: #2a2a2a; padding: 5px 12px; border-radius: 4px; border: 1px solid #444; color: #ccc; font-size: 13px; display: flex; align-items: center; gap: 8px;';
            skillTag.innerHTML = `
                ${skill}
                <button onclick="removeTypeSkill('${skill}')" style="background: none; border: none; 
                        color: #888; cursor: pointer; font-size: 16px; padding: 0; line-height: 1;">
                    &times;
                </button>
            `;
            
            skillsList.appendChild(skillTag);
            input.value = '';
            trackPersonaTypeChanges();
        }
        
        async function loadPersonaTypeTools(selectedTools = []) {
            try {
                const response = await fetchAPI('/api/tools/categories');
                const categories = response.categories || [];
                
                window.allTypeTools = [];
                window.selectedTypeTools = selectedTools;
                window.currentTypeToolsFilter = 'all';
                
                // Load all tools from all categories
                for (const category of categories) {
                    const toolsResponse = await fetchAPI(`/api/tools/category/${category.name}`);
                    const tools = toolsResponse.tools || [];
                    tools.forEach(tool => {
                        window.allTypeTools.push({
                            ...tool,
                            category: category.name,
                            categoryDisplay: category.displayName || category.display_name
                        });
                    });
                }
                
                displayTypeTools();
            } catch (error) {
                console.error('Error loading tools:', error);
                document.getElementById('personaTypeToolsList').innerHTML = 
                    '<p style="color: #ef4444;">Failed to load tools</p>';
            }
        }
        
        function displayTypeTools() {
            const container = document.getElementById('personaTypeToolsList');
            if (!container) return;
            
            const searchInput = document.getElementById('typeToolsSearchInput');
            const searchQuery = searchInput ? searchInput.value.toLowerCase() : '';
            
            // Check if tools data is loaded
            if (!window.allTypeTools || !window.selectedTypeTools) {
                console.warn('Tools data not loaded yet');
                return;
            }
            
            let toolsToDisplay = window.currentTypeToolsFilter === 'selected' 
                ? window.allTypeTools.filter(tool => window.selectedTypeTools.includes(tool.name))
                : window.allTypeTools;
            
            // Apply search filter
            if (searchQuery) {
                toolsToDisplay = toolsToDisplay.filter(tool => 
                    tool.name.toLowerCase().includes(searchQuery) ||
                    tool.display_name.toLowerCase().includes(searchQuery) ||
                    tool.description.toLowerCase().includes(searchQuery)
                );
            }
            
            // Group by category
            const groupedTools = {};
            toolsToDisplay.forEach(tool => {
                if (!groupedTools[tool.category]) {
                    groupedTools[tool.category] = {
                        display: tool.categoryDisplay,
                        tools: []
                    };
                }
                groupedTools[tool.category].tools.push(tool);
            });
            
            // Initialize category expanded state if not exists
            if (!window.typeToolCategoryExpanded) {
                window.typeToolCategoryExpanded = {};
            }
            
            // Generate expandable categories HTML
            container.innerHTML = Object.entries(groupedTools).map(([category, data]) => {
                const categoryId = `type-tool-category-${category.replace(/[^a-z0-9]/g, '-')}`;
                const isExpanded = window.typeToolCategoryExpanded[category] !== false; // Default to expanded
                
                // Count selected tools in this category
                const selectedInCategory = data.tools.filter(tool => window.selectedTypeTools.includes(tool.name)).length;
                
                return `
                    <div class="workflow-section ${isExpanded ? '' : 'collapsed'}" id="${categoryId}" style="margin-bottom: 10px;">
                        <div class="workflow-section-header" onclick="toggleTypeToolCategory('${categoryId}', '${category}')" 
                             style="padding: 10px 15px; cursor: pointer;">
                            <h4 class="workflow-section-title" style="font-size: 14px; font-weight: 500;">${data.display}</h4>
                            <span class="workflow-section-count">${selectedInCategory} of ${data.tools.length} selected</span>
                            <span class="workflow-section-toggle">${isExpanded ? '&#9660;' : '&#9650;'}</span>
                        </div>
                        <div class="workflow-section-content">
                            <div style="padding: 15px;">
                                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px;">
                                    ${data.tools.map(tool => `
                                        <label style="display: flex; align-items: start; cursor: pointer; padding: 10px; 
                                               background: #1a1a1a; border-radius: 4px; border: 1px solid #333;
                                               transition: all 0.2s;">
                                            <input type="checkbox" value="${tool.name}" 
                                                   ${window.selectedTypeTools.includes(tool.name) ? 'checked' : ''}
                                                   onchange="toggleTypeTool('${tool.name}')"
                                                   style="margin-right: 10px; margin-top: 2px;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 500; color: #fff; margin-bottom: 2px;">
                                                    ${tool.displayName || tool.display_name}
                                                </div>
                                                <div style="font-size: 12px; color: #888; line-height: 1.4;">
                                                    ${tool.description}
                                                </div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Update tool count in header
            updateDefaultToolsCount();
            
            // Update button states
            document.getElementById('showAllTypeToolsBtn').style.background = 
                window.currentTypeToolsFilter === 'all' ? '#3b82f6' : '';
            document.getElementById('showSelectedTypeToolsBtn').style.background = 
                window.currentTypeToolsFilter === 'selected' ? '#3b82f6' : '';
        }
        
        function toggleTypeTool(toolName) {
            const index = window.selectedTypeTools.indexOf(toolName);
            if (index > -1) {
                window.selectedTypeTools.splice(index, 1);
            } else {
                window.selectedTypeTools.push(toolName);
            }
            
            // Update the selected tools count
            const countSpan = document.getElementById('default-tools-count');
            if (countSpan) {
                countSpan.textContent = `${window.selectedTypeTools.length} selected`;
            }
            
            displayTypeTools();
            trackPersonaTypeChanges();
        }
        
        function toggleTypeToolCategory(categoryId, categoryName) {
            const section = document.getElementById(categoryId);
            if (!section) return;
            
            const isExpanded = !section.classList.contains('collapsed');
            
            if (isExpanded) {
                section.classList.add('collapsed');
            } else {
                section.classList.remove('collapsed');
            }
            
            // Update toggle icon
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isExpanded ? '&#9650;' : '&#9660;';
            }
            
            // Store expanded state
            if (!window.typeToolCategoryExpanded) {
                window.typeToolCategoryExpanded = {};
            }
            window.typeToolCategoryExpanded[categoryName] = !isExpanded;
        }
        
        function expandAllTypeToolCategories() {
            const sections = document.querySelectorAll('#personaTypeToolsList .workflow-section');
            sections.forEach(section => {
                section.classList.remove('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9660;';
            });
            
            // Update all stored states
            if (window.typeToolCategoryExpanded) {
                Object.keys(window.typeToolCategoryExpanded).forEach(key => {
                    window.typeToolCategoryExpanded[key] = true;
                });
            }
        }
        
        function collapseAllTypeToolCategories() {
            const sections = document.querySelectorAll('#personaTypeToolsList .workflow-section');
            sections.forEach(section => {
                section.classList.add('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9650;';
            });
            
            // Update all stored states
            if (window.typeToolCategoryExpanded) {
                Object.keys(window.typeToolCategoryExpanded).forEach(key => {
                    window.typeToolCategoryExpanded[key] = false;
                });
            }
        }
        
        function updateDefaultToolsCount() {
            const countElement = document.getElementById('default-tools-count');
            if (countElement && window.selectedTypeTools) {
                countElement.textContent = `${window.selectedTypeTools.length} selected`;
            }
        }
        
        function updateMCPServersCount() {
            const countElement = document.getElementById('mcp-servers-count');
            if (countElement) {
                const checkedBoxes = document.querySelectorAll('#personaMCPServers input[type="checkbox"]:checked');
                countElement.textContent = `${checkedBoxes.length} selected`;
            }
        }
        
        function showAllTypeTools() {
            window.currentTypeToolsFilter = 'all';
            displayTypeTools();
        }
        
        function showSelectedTypeTools() {
            window.currentTypeToolsFilter = 'selected';
            displayTypeTools();
        }
        
        function filterTypeTools() {
            displayTypeTools();
        }
        
        async function savePersonaType(personaType) {
            const saveButton = event.target;
            const originalText = saveButton ? saveButton.textContent : 'Save Changes';
            
            try {
                // Show loading state if button exists
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = 'Saving...';
                }
                
                // Collect all the data
                const typeName = document.getElementById('personaTypeName').value;
                const displayName = document.getElementById('personaDisplayName').value;
                const firstName = document.getElementById('defaultFirstName').value;
                const lastName = document.getElementById('defaultLastName').value;
                const category = document.getElementById('personaCategory').value;
                const emailDomain = document.getElementById('defaultEmailDomain').value;
                const description = document.getElementById('personaDescription').value;
                const prompt = document.getElementById('personaPrompt')?.value || '';
                const versionSpan = document.getElementById('personaPromptVersion');
                const version = versionSpan ? versionSpan.textContent : '1';
                const changeNotes = document.getElementById('personaPromptChangeNotes')?.value || '';
                
                // Validate required fields
                if (!typeName || !displayName) {
                    throw new Error('Type name and display name are required');
                }
                
                // Get skills
                const skillsList = document.getElementById('personaTypeSkillsList');
                const skills = skillsList ? Array.from(skillsList.querySelectorAll('[data-skill]'))
                    .map(el => el.getAttribute('data-skill')) : [];
                
                // Get selected tools
                const selectedTools = window.selectedTypeTools || [];
                
                // Get MCP servers
                const mcpServers = [];
                document.querySelectorAll('#personaMCPServers input[type="checkbox"]:checked').forEach(checkbox => {
                    mcpServers.push(checkbox.value);
                });
                
                // Prepare save data
                const saveData = {
                    type: typeName,
                    display_name: displayName,
                    default_first_name: firstName || '',
                    default_last_name: lastName || 'Bot',
                    category: category || 'general',
                    default_email_domain: emailDomain || '',
                    description: description || '',
                    prompt: prompt || '',
                    external_version: version || '1.0.0',
                    prompt_change_notes: changeNotes || '',
                    default_skills: skills,
                    default_tools: selectedTools,
                    default_mcp_servers: mcpServers
                };
                
                // Call the backend API
                const response = await fetchAPI(`/api/personas/types/${personaType}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(saveData)
                });
                
                if (response && response.status === 'success') {
                    showNotification('Persona type saved successfully', 'success');
                    
                    // Reset unsaved changes flag and update button states
                    personaTypeHasUnsavedChanges = false;
                    updatePersonaTypeSaveButtons();
                } else {
                    throw new Error(response?.message || 'Failed to save persona type');
                }
                
            } catch (error) {
                console.error('Error in savePersonaType:', error);
                showNotification(`Error: ${error.message}`, 'error');
            } finally {
                // Restore button state
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                }
            }
        }
        
        async function savePersonaPrompt(personaType) {
            try {
                const prompt = document.getElementById('personaPrompt')?.value;
                const changeNotes = document.getElementById('personaPromptChangeNotes')?.value;
                
                // Get version from the span element, not input
                const versionSpan = document.getElementById('personaPromptVersion');
                let currentVersion = versionSpan ? versionSpan.textContent : '1.0';
                
                // Validate inputs
                if (!prompt || prompt.trim() === '') {
                    throw new Error('Prompt cannot be empty');
                }
                
                // Calculate new version
                let newVersion = currentVersion;
                if (versionSpan) {
                    const versionParts = currentVersion.split('.');
                    
                    // Ensure we have at least major.minor format
                    if (versionParts.length === 1) {
                        versionParts.push('0');
                    }
                    
                    // Increment the minor version
                    versionParts[1] = (parseInt(versionParts[1] || '0') + 1).toString();
                    newVersion = versionParts.join('.');
                    versionSpan.textContent = newVersion;
                }
                
                // Update last updated timestamp
                const updatedSpan = document.getElementById('personaPromptUpdated');
                if (updatedSpan) {
                    updatedSpan.textContent = new Date().toLocaleString();
                }
                
                // Call the backend API with the NEW version
                const response = await fetchAPI(`/api/personas/types/${personaType}/prompt`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        external_version: newVersion,  // Use the NEW version, not the old one
                        prompt_change_notes: changeNotes,
                        prompt_last_updated: new Date().toISOString()
                    })
                });
                
                if (response && response.status === 'success') {
                    // Clear change notes after successful save
                    const changeNotesInput = document.getElementById('personaPromptChangeNotes');
                    if (changeNotesInput) {
                        changeNotesInput.value = '';
                    }
                    
                    // Reset unsaved changes tracking for the main save button
                    personaTypeHasUnsavedChanges = false;
                    updatePersonaTypeSaveButtons();
                    
                    showNotification('Persona prompt saved successfully', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save persona prompt');
                }
                
            } catch (error) {
                console.error('Error saving persona prompt:', error);
                showNotification(`Failed to save persona prompt: ${error.message}`, 'error');
            }
        }
        
        async function generatePersonaPrompt(personaType) {
            try {
                // Call the backend API to generate prompt
                const response = await fetchAPI(`/api/personas/types/${personaType}/generate-prompt`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        persona_type: personaType
                    })
                });
                
                if (response && response.status === 'success' && response.prompt) {
                    document.getElementById('personaPrompt').value = response.prompt;
                    showNotification('Prompt template generated successfully', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to generate prompt');
                }
                
            } catch (error) {
                console.error('Error generating prompt:', error);
                showNotification('Failed to generate prompt', 'error');
            }
        }
        
        async function exportPersonaPrompt(personaType) {
            try {
                const promptTextarea = document.getElementById('personaPrompt');
                const versionSpan = document.getElementById('personaPromptVersion');
                const changeNotes = document.getElementById('personaPromptChangeNotes');
                
                const version = versionSpan ? versionSpan.textContent : '1';
                
                const exportData = {
                    persona_type: personaType,
                    version: version,
                    exported_at: new Date().toISOString(),
                    prompt: promptTextarea.value,
                    change_notes: changeNotes ? changeNotes.value : ''
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${personaType}_prompt_v${version}_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showNotification('Prompt exported successfully', 'success');
            } catch (error) {
                console.error('Error exporting prompt:', error);
                showNotification('Failed to export prompt', 'error');
            }
        }
        
        async function importPersonaPrompt(personaType) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.txt,.md';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const content = await file.text();
                    let promptData;
                    
                    if (file.name.endsWith('.json')) {
                        promptData = JSON.parse(content);
                        document.getElementById('personaPrompt').value = promptData.prompt || content;
                        if (promptData.version) {
                            const versionSpan = document.getElementById('personaPromptVersion');
                            if (versionSpan) {
                                versionSpan.textContent = promptData.version;
                            }
                        }
                        if (promptData.change_notes) {
                            const changeNotesInput = document.getElementById('personaPromptChangeNotes');
                            if (changeNotesInput) {
                                changeNotesInput.value = promptData.change_notes;
                            }
                        }
                    } else {
                        // Plain text or markdown
                        document.getElementById('personaPrompt').value = content;
                    }
                    
                    showNotification('Prompt imported successfully', 'success');
                } catch (error) {
                    console.error('Error importing prompt:', error);
                    showNotification('Failed to import prompt - invalid format', 'error');
                }
            };
            
            input.click();
        }
        
        async function viewPersonaPromptHistory(personaType) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/prompt/history`);
                const data = await response.json();
                
                if (data.status === 'success' && data.history && data.history.length > 0) {
                    const historyHtml = data.history.map(h => `
                        <div style="margin-bottom: 20px; padding: 15px; background: #2a2a2a; border-radius: 5px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                <strong>Version ${h.version}</strong>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn-secondary" onclick="viewPromptVersion('${personaType}', ${h.version})">View</button>
                                    <button class="btn-primary" onclick="restorePromptVersion('${personaType}', ${h.version})">Restore</button>
                                </div>
                            </div>
                            <div style="color: #888; font-size: 12px; margin-bottom: 10px;">
                                ${new Date(h.created_at).toLocaleString()} by ${h.created_by || 'system'}
                            </div>
                            <div style="color: #888; font-size: 12px; margin-bottom: 10px;">
                                Notes: ${h.change_notes || 'No change notes'}
                            </div>
                            <div style="color: #888; font-size: 12px;">
                                Prompt length: ${h.prompt_length} characters
                            </div>
                        </div>
                    `).join('');
                    
                    showModal('Prompt History', `
                        <div style="max-height: 60vh; overflow-y: auto;">
                            ${historyHtml}
                        </div>
                    `);
                } else {
                    showModal('Prompt History', `
                        <div style="padding: 20px; text-align: center; color: #888;">
                            <p>No history available for this persona type.</p>
                            <p style="margin-top: 10px; font-size: 14px;">History will be created when you save prompt changes.</p>
                        </div>
                    `);
                }
                
            } catch (error) {
                console.error('Error loading prompt history:', error);
                showNotification('Failed to load prompt history', 'error');
            }
        }
        
        async function showPromptHistory(personaType) {
            // Alias for backward compatibility
            return viewPersonaPromptHistory(personaType);
        }
        
        async function viewPromptVersion(personaType, version) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/prompt/history/${version}`);
                const data = await response.json();
                
                if (data.status === 'success' && data.version) {
                    showModal(`Prompt Version ${version}`, `
                        <div style="margin-bottom: 10px; color: #888;">
                            <strong>Created:</strong> ${new Date(data.version.created_at).toLocaleString()}<br>
                            <strong>Created by:</strong> ${data.version.created_by || 'system'}<br>
                            <strong>Change notes:</strong> ${data.version.change_notes || 'None'}
                        </div>
                        <pre style="background: #1a1a1a; padding: 15px; border-radius: 5px; overflow: auto; max-height: 400px; white-space: pre-wrap;">${escapeHtml(data.version.prompt)}</pre>
                        <div style="margin-top: 20px; text-align: right;">
                            <button class="btn-secondary" onclick="closeModal()">Close</button>
                            <button class="btn-primary" onclick="restorePromptVersion('${personaType}', ${version})">Restore This Version</button>
                        </div>
                    `);
                } else {
                    showNotification('Version not found', 'error');
                }
            } catch (error) {
                console.error('Error viewing prompt version:', error);
                showNotification('Failed to load prompt version', 'error');
            }
        }
        
        async function restorePromptVersion(personaType, version) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/prompt/history/${version}/revert`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    // Update the textarea with the restored prompt
                    const promptTextarea = document.getElementById('personaPrompt');
                    if (promptTextarea) {
                        // Fetch the restored version to get the prompt content
                        const versionResponse = await fetch(`http://localhost:8080/api/personas/types/${personaType}/prompt/history/${data.new_version}`);
                        const versionData = await versionResponse.json();
                        
                        if (versionData.status === 'success' && versionData.version) {
                            promptTextarea.value = versionData.version.prompt;
                            
                            // Update the version display
                            const versionSpan = document.getElementById('personaPromptVersion');
                            if (versionSpan) {
                                versionSpan.textContent = data.new_version;
                            }
                            
                            // Update last updated time
                            const updatedSpan = document.getElementById('personaPromptUpdated');
                            if (updatedSpan) {
                                updatedSpan.textContent = new Date().toLocaleString();
                            }
                        }
                    }
                    
                    // Close the modal
                    closeModal();
                    
                    showNotification(`Restored prompt to version ${version} (created new version ${data.new_version})`, 'success');
                    
                    // Reload the persona type to refresh UI
                    loadPersonaTypes();
                } else {
                    showNotification(data.message || 'Failed to restore prompt version', 'error');
                }
                
            } catch (error) {
                console.error('Error restoring prompt version:', error);
                showNotification('Failed to restore prompt version', 'error');
            }
        }

        // Persona Workflow management functions
        async function savePersonaWorkflow(personaType) {
            try {
                const workflow = document.getElementById('personaWorkflow')?.value;
                const changeNotes = document.getElementById('personaWorkflowChangeNotes')?.value;
                
                // Get version from the span element
                const versionSpan = document.getElementById('personaWorkflowVersion');
                let currentVersion = versionSpan ? versionSpan.textContent : '1.0';
                
                // Validate inputs
                if (!workflow || workflow.trim() === '') {
                    throw new Error('Workflow cannot be empty');
                }
                
                // Validate YAML syntax
                try {
                    // Basic YAML validation - check for common syntax errors
                    const lines = workflow.split('\n');
                    let indentLevel = 0;
                    for (const line of lines) {
                        if (line.trim() && !line.trim().startsWith('#')) {
                            // Check for basic YAML structure
                            if (line.includes(':') && !line.trim().endsWith(':')) {
                                // Key-value pair
                            } else if (line.trim().endsWith(':')) {
                                // Object declaration
                            } else if (line.trim().startsWith('-')) {
                                // Array item
                            } else if (line.trim().match(/^[a-zA-Z0-9_]+$/)) {
                                // Simple value
                            } else {
                                // More complex validation would go here
                            }
                        }
                    }
                } catch (e) {
                    throw new Error('Invalid YAML syntax: ' + e.message);
                }
                
                // Calculate new version
                let newVersion = currentVersion;
                if (versionSpan) {
                    const versionParts = currentVersion.split('.');
                    
                    // Ensure we have at least major.minor format
                    if (versionParts.length === 1) {
                        versionParts.push('0');
                    }
                    
                    // Increment minor version
                    const major = parseInt(versionParts[0]) || 1;
                    const minor = (parseInt(versionParts[1]) || 0) + 1;
                    
                    newVersion = `${major}.${minor}`;
                }
                
                // Show saving state
                const saveButton = document.querySelector(`button[onclick="savePersonaWorkflow('${personaType}')"]`);
                const originalText = saveButton.innerHTML;
                saveButton.innerHTML = '<span style="margin-right: 5px;">&#8987;</span>Saving...';
                saveButton.disabled = true;
                
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/workflow`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        workflow_yaml: workflow,
                        workflow_version: newVersion,
                        change_notes: changeNotes || `Updated to version ${newVersion}`
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save workflow');
                }
                
                const result = await response.json();
                
                // Update version display
                if (versionSpan) {
                    versionSpan.textContent = newVersion;
                }
                
                // Clear change notes
                if (document.getElementById('personaWorkflowChangeNotes')) {
                    document.getElementById('personaWorkflowChangeNotes').value = '';
                }
                
                // Reset unsaved changes tracking for the main save button
                personaTypeHasUnsavedChanges = false;
                updatePersonaTypeSaveButtons();
                
                showNotification('Workflow saved successfully', 'success');
                
                // Restore button
                saveButton.innerHTML = originalText;
                saveButton.disabled = false;
                
            } catch (error) {
                console.error('Error saving workflow:', error);
                showNotification(`Error: ${error.message}`, 'error');
                
                // Restore button on error
                const saveButton = document.querySelector(`button[onclick="savePersonaWorkflow('${personaType}')"]`);
                if (saveButton) {
                    saveButton.innerHTML = '<span style="margin-right: 5px;">&#128190;</span>Save Workflow';
                    saveButton.disabled = false;
                }
            }
        }

        async function viewPersonaWorkflowHistory(personaType) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/workflow/history`);
                
                let history = [];
                if (response.ok) {
                    const data = await response.json();
                    history = data.history || [];
                }
                
                const modal = createModal('Workflow Version History', `
                    <div style="max-height: 60vh; overflow-y: auto;">
                        ${history.length === 0 ? '<p style="color: #888; text-align: center; padding: 20px;">No workflow history available yet. Save a workflow to create history.</p>' :
                        history.map(version => `
                            <div style="border: 1px solid #444; border-radius: 4px; padding: 15px; margin-bottom: 15px; background: #2a2a2a;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <h4 style="margin: 0; color: #4a9eff;">Version ${version.version}</h4>
                                    <div>
                                        <button class="btn-secondary" onclick="viewWorkflowVersion('${personaType}', ${version.version})" 
                                                style="padding: 5px 15px; font-size: 12px;">
                                            View
                                        </button>
                                        <button class="btn-primary" onclick="restoreWorkflowVersion('${personaType}', ${version.version})" 
                                                style="padding: 5px 15px; font-size: 12px; margin-left: 5px;">
                                            Restore
                                        </button>
                                    </div>
                                </div>
                                <div style="color: #888; font-size: 12px; margin-bottom: 10px;">
                                    <div>Created: ${new Date(version.created_at).toLocaleString()}</div>
                                    <div>By: ${version.created_by || 'system'}</div>
                                    <div>Notes: ${version.change_notes || 'No notes'}</div>
                                </div>
                                <pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; overflow-x: auto; 
                                           font-size: 12px; max-height: 200px; overflow-y: auto;">${escapeHtml(version.yaml_content)}</pre>
                            </div>
                        `).join('')}
                    </div>
                `);
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Error loading workflow history:', error);
                showNotification('Failed to load workflow history', 'error');
            }
        }

        async function exportPersonaWorkflow(personaType) {
            try {
                const workflowTextarea = document.getElementById('personaWorkflow');
                const versionSpan = document.getElementById('personaWorkflowVersion');
                const changeNotes = document.getElementById('personaWorkflowChangeNotes');
                
                const version = versionSpan ? versionSpan.textContent : '1';
                
                const exportData = {
                    persona_type: personaType,
                    version: version,
                    exported_at: new Date().toISOString(),
                    workflow_yaml: workflowTextarea.value,
                    change_notes: changeNotes ? changeNotes.value : ''
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${personaType}_workflow_v${version}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Workflow exported successfully', 'success');
            } catch (error) {
                console.error('Error exporting workflow:', error);
                showNotification('Failed to export workflow', 'error');
            }
        }

        async function importPersonaWorkflow(personaType) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.yaml,.yml';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const content = await file.text();
                    let workflowData;
                    
                    if (file.name.endsWith('.json')) {
                        workflowData = JSON.parse(content);
                        document.getElementById('personaWorkflow').value = workflowData.workflow_yaml || content;
                        if (workflowData.version) {
                            const versionSpan = document.getElementById('personaWorkflowVersion');
                            if (versionSpan) {
                                versionSpan.textContent = workflowData.version;
                            }
                        }
                    } else {
                        // Direct YAML import
                        document.getElementById('personaWorkflow').value = content;
                    }
                    
                    // Mark as changed
                    trackPersonaTypeChanges();
                    
                    showNotification('Workflow imported successfully', 'success');
                } catch (error) {
                    console.error('Error importing workflow:', error);
                    showNotification('Failed to import workflow', 'error');
                }
            };
            
            input.click();
        }

        async function viewWorkflowVersion(personaType, versionNumber) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/workflow/history/${versionNumber}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch workflow version');
                }
                
                const versionData = await response.json();
                
                // Create a modal to view the version
                const modal = createModal(`Workflow Version ${versionData.version}`, `
                    <div style="max-height: 60vh; overflow-y: auto;">
                        <div style="margin-bottom: 15px;">
                            <div style="color: #888; font-size: 14px;">
                                <div>Created: ${new Date(versionData.created_at).toLocaleString()}</div>
                                <div>By: ${versionData.created_by || 'system'}</div>
                                <div>Notes: ${versionData.change_notes || 'No notes'}</div>
                            </div>
                        </div>
                        <pre style="background: #1a1a1a; padding: 15px; border-radius: 4px; overflow-x: auto; 
                                   font-size: 14px; color: #e0e0e0; font-family: 'Courier New', monospace;">${escapeHtml(versionData.yaml_content)}</pre>
                    </div>
                `);
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Error viewing workflow version:', error);
                showNotification('Failed to load workflow version', 'error');
            }
        }

        async function restoreWorkflowVersion(personaType, versionNumber) {
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}/workflow/history/${versionNumber}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch workflow version');
                }
                
                const versionData = await response.json();
                
                // Update the workflow textarea
                const workflowTextarea = document.getElementById('personaWorkflow');
                if (workflowTextarea) {
                    workflowTextarea.value = versionData.yaml_content;
                }
                
                // Update version display
                const versionSpan = document.querySelector('.workflow-section-count');
                if (versionSpan) {
                    versionSpan.textContent = `Version ${versionData.version}`;
                }
                
                // Add a note about the restoration
                const changeNotesInput = document.getElementById('personaWorkflowChangeNotes');
                if (changeNotesInput) {
                    changeNotesInput.value = `Restored from version ${versionData.version}`;
                }
                
                // Mark as changed
                trackPersonaTypeChanges();
                
                // Close the modal
                const modals = document.querySelectorAll('.modal-overlay');
                modals.forEach(modal => modal.remove());
                
                showNotification(`Restored workflow version ${versionData.version}`, 'success');
                
            } catch (error) {
                console.error('Error restoring workflow version:', error);
                showNotification('Failed to restore workflow version', 'error');
            }
        }
        
        // Helper function to render MCP servers for persona
        async function renderPersonaMCPServers(selectedServers) {
            try {
                // Get all available MCP servers
                const response = await fetchAPI('/api/mcp-servers');
                if (!response || !response.servers) {
                    return '<p style="color: #888;">Unable to load MCP servers</p>';
                }
                
                const servers = response.servers;
                
                // Render checkboxes for each server
                return servers.map(server => `
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #444;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="mcp-server-${server.name}" value="${server.name}" 
                                   ${selectedServers.includes(server.name) ? 'checked' : ''}
                                   onchange="updateMCPServersCount(); trackPersonaTypeChanges()"
                                   style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; color: #fff;">${server.displayName}</div>
                                <div style="font-size: 12px; color: #888; margin-top: 4px;">${server.description}</div>
                            </div>
                        </label>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading MCP servers:', error);
                return '<p style="color: #ef4444;">Error loading MCP servers</p>';
            }
        }
        
        // Save persona MCP server selection
        async function savePersonaMCPServers(personaType) {
            const saveButton = event.target;
            const originalText = saveButton ? saveButton.textContent : 'Save MCP Server Selection';
            
            try {
                // Show loading state
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = 'Saving...';
                }
                
                // Get all checked MCP servers
                const checkedServers = [];
                document.querySelectorAll('#personaMCPServers input[type="checkbox"]:checked').forEach(checkbox => {
                    checkedServers.push(checkbox.value);
                });
                
                // Call the backend API
                const response = await fetchAPI(`/api/personas/types/${personaType}/mcp-servers`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        default_mcp_servers: checkedServers
                    })
                });
                
                if (response && response.status === 'success') {
                    // Reset unsaved changes tracking for the main save button
                    personaTypeHasUnsavedChanges = false;
                    updatePersonaTypeSaveButtons();
                    
                    showNotification('MCP servers configuration saved successfully', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save MCP servers configuration');
                }
                
                console.log('MCP servers saved:', {
                    personaType,
                    default_mcp_servers: checkedServers
                });
                
                // Provide guidance
                console.log(`Missing backend endpoint: PUT /api/personas/types/${personaType}`);
                
            } catch (error) {
                console.error('Error saving MCP servers:', error);
                showNotification('Failed to save MCP server selection', 'error');
            } finally {
                // Restore button state
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                }
            }
        }
        
        // Function to restore the personas tab to its original state
        function restorePersonasTab() {
            // Check for unsaved changes before restoring
            if (personaTypeHasUnsavedChanges && !checkUnsavedPersonaTypeChanges()) {
                return;
            }
            
            const personasTab = document.getElementById('personas-tab');
            if (!personasTab) return;
            
            // Restore the original HTML structure
            personasTab.innerHTML = `
                <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; max-width: 100%; box-sizing: border-box;">
                    <h3 style="margin-top: 0; color: #3b82f6;">Persona Management</h3>
                    
                    <div style="margin-bottom: 20px;">
                        <p style="color: #999; margin-bottom: 15px;">
                            Manage AI Persona instances. Create multiple instances of each persona type with customized configurations.
                        </p>
                        
                        <button id="createPersonaBtn" class="btn-primary" onclick="showCreatePersonaModal()">
                            <span style="font-size: 16px;">&plus;</span> Create New Persona Type
                        </button>
                    </div>
                    
                    <!-- Persona Types Overview -->
                    <div style="margin-bottom: 30px;">
                        <h4 style="color: #ccc; margin-bottom: 15px;">Available Persona Types (25)</h4>
                        <div id="personaTypesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                            <!-- Persona type cards will be loaded here -->
                        </div>
                    </div>
                    
                    <div id="personasSettingsMessage" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
                </div>
            `;
            
            // Now load the persona types
            loadPersonaTypes().catch(console.error);
        }
        
        async function loadPersonaInstances() {
            console.log('Loading persona instances...');
            try {
                const response = await fetchAPI('/api/personas/instances');
                console.log('Persona instances response:', response);
                const instancesList = document.getElementById('personaInstancesList');
                
                // Exit early if element doesn't exist (since instances are managed from left panel now)
                if (!instancesList) {
                    console.log('personaInstancesList element not found - instances managed from left panel');
                    return;
                }
                
                // Extract the instances array from the response object
                const instances = response.instances || [];
                
                if (!instances || instances.length === 0) {
                    instancesList.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px; color: #888;">No persona instances created yet</td></tr>';
                    return;
                }
                
                instancesList.innerHTML = instances.map(instance => `
                    <tr style="border-bottom: 1px solid #333;">
                        <td style="padding: 10px; color: #e0e0e0;">${instance.full_name}</td>
                        <td style="padding: 10px; color: #999;">${instance.display_name || instance.persona_type}</td>
                        <td style="padding: 10px;">
                            <span style="color: ${instance.is_active ? '#22c55e' : '#888'};">
                                ${instance.is_active ? 'Active' : 'Inactive'}
                            </span>
                        </td>
                        <td style="padding: 10px; color: #999;">
                            ${instance.work_items_processed || 0} processed
                        </td>
                        <td style="padding: 10px;">
                            <button class="btn-secondary" onclick="editPersonaInstance('${instance.instance_id}')">Edit</button>
                            <button class="btn-secondary" onclick="togglePersonaInstance('${instance.instance_id}')" 
                                    style="margin-left: 5px;">
                                ${instance.is_active ? 'Disable' : 'Enable'}
                            </button>
                            <button class="btn-secondary" onclick="deletePersonaInstance('${instance.instance_id}')" 
                                    style="margin-left: 5px; background: #dc2626;">
                                Delete
                            </button>
                        </td>
                    </tr>
                `).join('');
            } catch (error) {
                console.error('Error loading persona instances:', error);
                document.getElementById('personaInstancesList').innerHTML = 
                    '<tr><td colspan="5" style="text-align: center; padding: 20px; color: #ef4444;">Error loading persona instances</td></tr>';
            }
        }
        
        async function loadMCPServers() {
            try {
                const response = await fetchAPI('/api/mcp-servers');
                console.log('Loaded MCP servers:', response);
                
                const container = document.getElementById('mcpServersList');
                if (!container) return;
                
                // Extract the servers array from the response object
                const servers = response.servers || [];
                
                container.innerHTML = servers.map(server => `
                    <div class="mcp-server-item" style="padding: 10px; border-bottom: 1px solid #333;">
                        <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold; color: #e0e0e0;">${server.displayName}</div>
                                <div style="font-size: 0.85em; color: #999; margin-top: 2px;">${server.description}</div>
                                ${server.in_use_by > 0 ? `<div style="font-size: 0.8em; color: #3b82f6; margin-top: 4px;">Used by ${server.in_use_by} personas</div>` : ''}
                            </div>
                            <div class="toggle-switch">
                                <input type="checkbox" id="mcp-${server.name}" ${server.enabled ? 'checked' : ''} 
                                       onchange="toggleMCPServer('${server.name}')">
                                <span class="toggle-slider"></span>
                            </div>
                        </label>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading MCP servers:', error);
                const container = document.getElementById('mcpServersList');
                if (container) {
                    container.innerHTML = '<div style="color: #ef4444; padding: 10px;">Failed to load MCP servers</div>';
                }
            }
        }
        
        // Repository Configuration Functions
        
        // State management for repository sections
        const repositoryStructureState = {
            hasChanges: false,
            isValid: true,
            originalStructure: '',
            currentVersion: 1
        };
        
        const branchingStrategyState = {
            hasChanges: false,
            isValid: true,
            originalStrategy: '',
            currentVersion: 1
        };
        
        let repositoryStructureValidationTimeout;
        let branchingStrategyValidationTimeout;
        
        // Toggle repository structure section
        function toggleRepositoryStructureSection() {
            const section = document.getElementById('repository-structure-section');
            const content = section.querySelector('.workflow-section-content');
            const toggle = section.querySelector('.workflow-section-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.innerHTML = '&#9660;';
                section.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.innerHTML = '&#9658;';
                section.classList.add('collapsed');
            }
        }
        
        // Toggle branching strategy section
        function toggleBranchingStrategySection() {
            const section = document.getElementById('branching-strategy-section');
            const content = section.querySelector('.workflow-section-content');
            const toggle = section.querySelector('.workflow-section-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.innerHTML = '&#9660;';
                section.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.innerHTML = '&#9658;';
                section.classList.add('collapsed');
            }
        }
        
        // Track repository structure changes
        function trackRepositoryStructureChange() {
            const textarea = document.getElementById('repositoryStructure');
            const hasChanges = textarea.value !== repositoryStructureState.originalStructure;
            
            repositoryStructureState.hasChanges = hasChanges;
            updateRepositoryStructureSaveButton(hasChanges);
            
            // Reset validation state when content changes
            if (hasChanges && repositoryStructureState.isValid) {
                repositoryStructureState.isValid = false;
                const validationDiv = document.getElementById('repository-structure-validation');
                if (validationDiv) {
                    validationDiv.style.display = 'none';
                }
            }
        }
        
        // Validate repository structure
        function validateRepositoryStructure() {
            const textarea = document.getElementById('repositoryStructure');
            const validationDiv = document.getElementById('repository-structure-validation');
            
            if (!textarea || !validationDiv) return;
            
            // Clear previous timeout
            if (repositoryStructureValidationTimeout) {
                clearTimeout(repositoryStructureValidationTimeout);
            }
            
            // Debounce validation
            repositoryStructureValidationTimeout = setTimeout(() => {
                const structure = textarea.value.trim();
                
                if (structure.length === 0) {
                    validationDiv.innerHTML = '<span style="color: #ef4444;">&#10008;</span> Repository structure cannot be empty';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#7f1d1d';
                    validationDiv.style.border = '1px solid #ef4444';
                    repositoryStructureState.isValid = false;
                } else if (structure.length < 50) {
                    validationDiv.innerHTML = '<span style="color: #f59e0b;">&#9888;</span> Repository structure seems too short. Please provide a complete directory structure.';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#78350f';
                    validationDiv.style.border = '1px solid #f59e0b';
                    repositoryStructureState.isValid = true;  // Allow save but show warning
                } else {
                    validationDiv.innerHTML = '<span style="color: #10b981;">&#10004;</span> Repository structure is valid';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#064e3b';
                    validationDiv.style.border = '1px solid #10b981';
                    repositoryStructureState.isValid = true;
                }
                
                // Enable/disable save button based on validation
                const saveBtn = document.querySelector('.repository-structure-save-btn');
                if (saveBtn && repositoryStructureState.hasChanges) {
                    saveBtn.disabled = !repositoryStructureState.isValid;
                }
            }, 500);
        }
        
        // Update repository structure save button state
        function updateRepositoryStructureSaveButton(hasChanges) {
            const saveBtn = document.querySelector('.repository-structure-save-btn');
            
            if (saveBtn) {
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                    saveBtn.disabled = true;
                }
            }
        }
        
        // Edit repository structure name
        async function editRepositoryStructureName() {
            const titleElement = document.querySelector('#repository-structure-section .workflow-section-title');
            const currentName = titleElement.textContent;
            
            const newName = prompt('Enter new name for the repository structure:', currentName);
            if (newName && newName !== currentName) {
                titleElement.textContent = newName;
                showNotification('Repository structure name updated', 'success');
            }
        }
        
        // Load repository structure
        async function loadRepositoryStructure() {
            try {
                const response = await fetchAPI('/api/repository/structure');
                if (response && response.structure) {
                    const textarea = document.getElementById('repositoryStructure');
                    const versionSpan = document.getElementById('repositoryStructureVersion');
                    const versionHeaderSpan = document.getElementById('repositoryStructureVersionHeader');
                    const updatedSpan = document.getElementById('repositoryStructureUpdated');
                    
                    if (textarea) {
                        textarea.value = response.structure;
                        repositoryStructureState.originalStructure = response.structure;
                    }
                    
                    repositoryStructureState.currentVersion = response.version || 1;
                    
                    if (versionSpan) {
                        versionSpan.textContent = response.version || 1;
                    }
                    if (versionHeaderSpan) {
                        versionHeaderSpan.textContent = response.version || 1;
                    }
                    if (updatedSpan && response.updated_at) {
                        const date = new Date(response.updated_at);
                        updatedSpan.textContent = date.toLocaleString();
                    }
                }
            } catch (error) {
                console.error('Error loading repository structure:', error);
                showNotification('Failed to load repository structure', 'error');
            }
        }
        
        // Save repository structure
        async function saveRepositoryStructure() {
            try {
                const textarea = document.getElementById('repositoryStructure');
                const changeNotes = document.getElementById('repositoryStructureChangeNotes');
                
                if (!textarea) {
                    showNotification('Repository structure textarea not found', 'error');
                    return;
                }
                
                const structure = textarea.value.trim();
                
                if (!structure) {
                    showNotification('Repository structure cannot be empty', 'error');
                    return;
                }
                
                const data = {
                    structure: structure,
                    change_notes: changeNotes?.value || ''
                };
                
                const response = await fetchAPI('/api/repository/structure', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response && response.version) {
                    repositoryStructureState.originalStructure = structure;
                    repositoryStructureState.hasChanges = false;
                    repositoryStructureState.currentVersion = response.version;
                    
                    // Update version displays
                    const versionSpan = document.getElementById('repositoryStructureVersion');
                    const versionHeaderSpan = document.getElementById('repositoryStructureVersionHeader');
                    if (versionSpan) versionSpan.textContent = response.version;
                    if (versionHeaderSpan) versionHeaderSpan.textContent = response.version;
                    
                    // Update last updated
                    const updatedSpan = document.getElementById('repositoryStructureUpdated');
                    if (updatedSpan) {
                        updatedSpan.textContent = new Date(response.updated_at).toLocaleString();
                    }
                    
                    // Clear change notes
                    if (changeNotes) changeNotes.value = '';
                    
                    // Hide validation message
                    const validationDiv = document.getElementById('repository-structure-validation');
                    if (validationDiv) validationDiv.style.display = 'none';
                    
                    // Update button state
                    updateRepositoryStructureSaveButton(false);
                    
                    showNotification('Repository structure saved successfully', 'success');
                } else {
                    showNotification('Failed to save repository structure', 'error');
                }
            } catch (error) {
                console.error('Error saving repository structure:', error);
                showNotification('Failed to save repository structure: ' + error.message, 'error');
            }
        }
        
        // View repository structure history
        async function viewRepositoryStructureHistory() {
            try {
                const response = await fetchAPI('/api/repository/structure/history');
                if (!response || !response.history || response.history.length === 0) {
                    showNotification('No history available', 'info');
                    return;
                }
                
                let historyHtml = `
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid #444;">
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Version</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Date</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Change Notes</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                response.history.forEach(entry => {
                    const date = new Date(entry.created_at);
                    historyHtml += `
                        <tr style="border-bottom: 1px solid #333;">
                            <td style="padding: 10px; color: #e0e0e0;">${entry.version}</td>
                            <td style="padding: 10px; color: #888;">${date.toLocaleString()}</td>
                            <td style="padding: 10px; color: #ccc;">${entry.change_notes || '-'}</td>
                            <td style="padding: 10px;">
                                <button class="btn-secondary" onclick="viewRepositoryStructureVersion(${entry.version})" style="margin-right: 5px;">View</button>
                                <button class="btn-secondary" onclick="restoreRepositoryStructureVersion(${entry.version})">Restore</button>
                            </td>
                        </tr>
                    `;
                });
                
                historyHtml += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                showModal('Repository Structure History', historyHtml);
                
            } catch (error) {
                console.error('Error loading repository structure history:', error);
                showNotification('Error loading history: ' + error.message, 'error');
            }
        }
        
        // View specific repository structure version
        async function viewRepositoryStructureVersion(version) {
            try {
                const response = await fetchAPI(`/api/repository/structure/version/${version}`);
                if (response && response.structure) {
                    const data = response.structure;
                    const modalContent = `
                        <div>
                            <h4 style="color: #3b82f6; margin-bottom: 10px;">Version ${data.version}</h4>
                            <p style="color: #888; margin-bottom: 15px;">Created: ${new Date(data.created_at).toLocaleString()}</p>
                            ${data.change_notes ? `<p style="color: #ccc; margin-bottom: 15px;">Notes: ${data.change_notes}</p>` : ''}
                            <pre style="background: #1a1a1a; padding: 15px; border-radius: 4px; overflow-x: auto; max-height: 400px; color: #e0e0e0; font-family: 'Consolas', 'Monaco', monospace;">${data.structure}</pre>
                        </div>
                    `;
                    showModal(`Repository Structure - Version ${version}`, modalContent);
                }
            } catch (error) {
                showNotification('Error loading version: ' + error.message, 'error');
            }
        }
        
        // Restore repository structure version
        async function restoreRepositoryStructureVersion(version) {
            if (!confirm(`Are you sure you want to restore repository structure to version ${version}?`)) {
                return;
            }
            
            try {
                const response = await fetchAPI(`/api/repository/structure/version/${version}`);
                if (response && response.structure) {
                    const data = response.structure;
                    const textarea = document.getElementById('repositoryStructure');
                    if (textarea) {
                        textarea.value = data.structure;
                        repositoryStructureState.originalStructure = data.structure;
                        repositoryStructureState.hasChanges = false;
                        
                        // Update version displays
                        const versionSpan = document.getElementById('repositoryStructureVersion');
                        const versionHeaderSpan = document.getElementById('repositoryStructureVersionHeader');
                        if (versionSpan) versionSpan.textContent = data.version;
                        if (versionHeaderSpan) versionHeaderSpan.textContent = data.version;
                        
                        // Trigger save with restoration note
                        const changeNotes = document.getElementById('repositoryStructureChangeNotes');
                        if (changeNotes) {
                            changeNotes.value = `Restored from version ${version}`;
                        }
                        
                        // Mark as changed to enable save
                        repositoryStructureState.hasChanges = true;
                        updateRepositoryStructureSaveButton(true);
                        
                        // Close any open modals
                        closeModal();
                        
                        showNotification(`Repository structure restored from version ${version}. Click Save to apply.`, 'success');
                    }
                }
            } catch (error) {
                showNotification('Error restoring version: ' + error.message, 'error');
            }
        }
        
        // Export repository structure
        function exportRepositoryStructure() {
            try {
                const textarea = document.getElementById('repositoryStructure');
                const version = document.getElementById('repositoryStructureVersion').textContent;
                
                const exportData = {
                    type: 'repository_structure',
                    version: version,
                    structure: textarea.value,
                    exported_at: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `repository_structure_v${version}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Repository structure exported successfully', 'success');
            } catch (error) {
                showNotification('Error exporting repository structure: ' + error.message, 'error');
            }
        }
        
        // Import repository structure
        function importRepositoryStructure() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,.txt';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const content = event.target.result;
                            let structure = '';
                            
                            // Try to parse as JSON first
                            try {
                                const data = JSON.parse(content);
                                if (data.structure) {
                                    structure = data.structure;
                                } else if (typeof data === 'string') {
                                    structure = data;
                                }
                            } catch {
                                // If not JSON, treat as plain text
                                structure = content;
                            }
                            
                            const textarea = document.getElementById('repositoryStructure');
                            if (textarea && structure) {
                                textarea.value = structure;
                                trackRepositoryStructureChange();
                                validateRepositoryStructure();
                                showNotification('Repository structure imported. Remember to save!', 'info');
                            }
                        } catch (error) {
                            showNotification('Error parsing imported file: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            } catch (error) {
                showNotification('Error importing repository structure: ' + error.message, 'error');
            }
        }
        
        // Branching Strategy Functions
        
        // Track branching strategy changes
        function trackBranchingStrategyChange() {
            const textarea = document.getElementById('branchingStrategy');
            const hasChanges = textarea.value !== branchingStrategyState.originalStrategy;
            
            branchingStrategyState.hasChanges = hasChanges;
            updateBranchingStrategySaveButton(hasChanges);
            
            // Reset validation state when content changes
            if (hasChanges && branchingStrategyState.isValid) {
                branchingStrategyState.isValid = false;
                const validationDiv = document.getElementById('branching-strategy-validation');
                if (validationDiv) {
                    validationDiv.style.display = 'none';
                }
            }
        }
        
        // Validate branching strategy
        function validateBranchingStrategy() {
            const textarea = document.getElementById('branchingStrategy');
            const validationDiv = document.getElementById('branching-strategy-validation');
            
            if (!textarea || !validationDiv) return;
            
            // Clear previous timeout
            if (branchingStrategyValidationTimeout) {
                clearTimeout(branchingStrategyValidationTimeout);
            }
            
            // Debounce validation
            branchingStrategyValidationTimeout = setTimeout(() => {
                const strategy = textarea.value.trim();
                
                if (strategy.length === 0) {
                    validationDiv.innerHTML = '<span style="color: #ef4444;">&#10008;</span> Branching strategy cannot be empty';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#7f1d1d';
                    validationDiv.style.border = '1px solid #ef4444';
                    branchingStrategyState.isValid = false;
                } else if (strategy.length < 50) {
                    validationDiv.innerHTML = '<span style="color: #f59e0b;">&#9888;</span> Branching strategy seems too short. Please provide complete branching guidelines.';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#78350f';
                    validationDiv.style.border = '1px solid #f59e0b';
                    branchingStrategyState.isValid = true;  // Allow save but show warning
                } else {
                    validationDiv.innerHTML = '<span style="color: #10b981;">&#10004;</span> Branching strategy is valid';
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = '#064e3b';
                    validationDiv.style.border = '1px solid #10b981';
                    branchingStrategyState.isValid = true;
                }
                
                // Enable/disable save button based on validation
                const saveBtn = document.querySelector('.branching-strategy-save-btn');
                if (saveBtn && branchingStrategyState.hasChanges) {
                    saveBtn.disabled = !branchingStrategyState.isValid;
                }
            }, 500);
        }
        
        // Update branching strategy save button state
        function updateBranchingStrategySaveButton(hasChanges) {
            const saveBtn = document.querySelector('.branching-strategy-save-btn');
            
            if (saveBtn) {
                if (hasChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                    saveBtn.disabled = true;
                }
            }
        }
        
        // Edit branching strategy name
        async function editBranchingStrategyName() {
            const titleElement = document.querySelector('#branching-strategy-section .workflow-section-title');
            const currentName = titleElement.textContent;
            
            const newName = prompt('Enter new name for the branching strategy:', currentName);
            if (newName && newName !== currentName) {
                titleElement.textContent = newName;
                showNotification('Branching strategy name updated', 'success');
            }
        }
        
        // Load branching strategy
        async function loadBranchingStrategy() {
            try {
                const response = await fetchAPI('/api/repository/branching');
                if (response && response.strategy) {
                    const textarea = document.getElementById('branchingStrategy');
                    const versionSpan = document.getElementById('branchingStrategyVersion');
                    const versionHeaderSpan = document.getElementById('branchingStrategyVersionHeader');
                    const updatedSpan = document.getElementById('branchingStrategyUpdated');
                    
                    if (textarea) {
                        textarea.value = response.strategy;
                        branchingStrategyState.originalStrategy = response.strategy;
                    }
                    
                    branchingStrategyState.currentVersion = response.version || 1;
                    
                    if (versionSpan) {
                        versionSpan.textContent = response.version || 1;
                    }
                    if (versionHeaderSpan) {
                        versionHeaderSpan.textContent = response.version || 1;
                    }
                    if (updatedSpan && response.updated_at) {
                        const date = new Date(response.updated_at);
                        updatedSpan.textContent = date.toLocaleString();
                    }
                }
            } catch (error) {
                console.error('Error loading branching strategy:', error);
                showNotification('Failed to load branching strategy', 'error');
            }
        }
        
        // Save branching strategy
        async function saveBranchingStrategy() {
            try {
                const textarea = document.getElementById('branchingStrategy');
                const changeNotes = document.getElementById('branchingStrategyChangeNotes');
                
                if (!textarea) {
                    showNotification('Branching strategy textarea not found', 'error');
                    return;
                }
                
                const strategy = textarea.value.trim();
                
                if (!strategy) {
                    showNotification('Branching strategy cannot be empty', 'error');
                    return;
                }
                
                const data = {
                    strategy: strategy,
                    change_notes: changeNotes?.value || ''
                };
                
                const response = await fetchAPI('/api/repository/branching', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response && response.version) {
                    branchingStrategyState.originalStrategy = strategy;
                    branchingStrategyState.hasChanges = false;
                    branchingStrategyState.currentVersion = response.version;
                    
                    // Update version displays
                    const versionSpan = document.getElementById('branchingStrategyVersion');
                    const versionHeaderSpan = document.getElementById('branchingStrategyVersionHeader');
                    if (versionSpan) versionSpan.textContent = response.version;
                    if (versionHeaderSpan) versionHeaderSpan.textContent = response.version;
                    
                    // Update last updated
                    const updatedSpan = document.getElementById('branchingStrategyUpdated');
                    if (updatedSpan) {
                        updatedSpan.textContent = new Date(response.updated_at).toLocaleString();
                    }
                    
                    // Clear change notes
                    if (changeNotes) changeNotes.value = '';
                    
                    // Hide validation message
                    const validationDiv = document.getElementById('branching-strategy-validation');
                    if (validationDiv) validationDiv.style.display = 'none';
                    
                    // Update button state
                    updateBranchingStrategySaveButton(false);
                    
                    showNotification('Branching strategy saved successfully', 'success');
                } else {
                    showNotification('Failed to save branching strategy', 'error');
                }
            } catch (error) {
                console.error('Error saving branching strategy:', error);
                showNotification('Failed to save branching strategy: ' + error.message, 'error');
            }
        }
        
        // View branching strategy history
        async function viewBranchingStrategyHistory() {
            try {
                const response = await fetchAPI('/api/repository/branching/history');
                if (!response || !response.history || response.history.length === 0) {
                    showNotification('No history available', 'info');
                    return;
                }
                
                let historyHtml = `
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid #444;">
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Version</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Date</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Change Notes</th>
                                    <th style="padding: 10px; text-align: left; color: #3b82f6;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                response.history.forEach(entry => {
                    const date = new Date(entry.created_at);
                    historyHtml += `
                        <tr style="border-bottom: 1px solid #333;">
                            <td style="padding: 10px; color: #e0e0e0;">${entry.version}</td>
                            <td style="padding: 10px; color: #888;">${date.toLocaleString()}</td>
                            <td style="padding: 10px; color: #ccc;">${entry.change_notes || '-'}</td>
                            <td style="padding: 10px;">
                                <button class="btn-secondary" onclick="viewBranchingStrategyVersion(${entry.version})" style="margin-right: 5px;">View</button>
                                <button class="btn-secondary" onclick="restoreBranchingStrategyVersion(${entry.version})">Restore</button>
                            </td>
                        </tr>
                    `;
                });
                
                historyHtml += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                showModal('Branching Strategy History', historyHtml);
                
            } catch (error) {
                console.error('Error loading branching strategy history:', error);
                showNotification('Error loading history: ' + error.message, 'error');
            }
        }
        
        // View specific branching strategy version
        async function viewBranchingStrategyVersion(version) {
            try {
                const response = await fetchAPI(`/api/repository/branching/version/${version}`);
                if (response && response.strategy) {
                    const data = response.strategy;
                    const modalContent = `
                        <div>
                            <h4 style="color: #3b82f6; margin-bottom: 10px;">Version ${data.version}</h4>
                            <p style="color: #888; margin-bottom: 15px;">Created: ${new Date(data.created_at).toLocaleString()}</p>
                            ${data.change_notes ? `<p style="color: #ccc; margin-bottom: 15px;">Notes: ${data.change_notes}</p>` : ''}
                            <pre style="background: #1a1a1a; padding: 15px; border-radius: 4px; overflow-x: auto; max-height: 400px; color: #e0e0e0; font-family: 'Consolas', 'Monaco', monospace;">${data.strategy}</pre>
                        </div>
                    `;
                    showModal(`Branching Strategy - Version ${version}`, modalContent);
                }
            } catch (error) {
                showNotification('Error loading version: ' + error.message, 'error');
            }
        }
        
        // Restore branching strategy version
        async function restoreBranchingStrategyVersion(version) {
            if (!confirm(`Are you sure you want to restore branching strategy to version ${version}?`)) {
                return;
            }
            
            try {
                const response = await fetchAPI(`/api/repository/branching/version/${version}`);
                if (response && response.strategy) {
                    const data = response.strategy;
                    const textarea = document.getElementById('branchingStrategy');
                    if (textarea) {
                        textarea.value = data.strategy;
                        branchingStrategyState.originalStrategy = data.strategy;
                        branchingStrategyState.hasChanges = false;
                        
                        // Update version displays
                        const versionSpan = document.getElementById('branchingStrategyVersion');
                        const versionHeaderSpan = document.getElementById('branchingStrategyVersionHeader');
                        if (versionSpan) versionSpan.textContent = data.version;
                        if (versionHeaderSpan) versionHeaderSpan.textContent = data.version;
                        
                        // Trigger save with restoration note
                        const changeNotes = document.getElementById('branchingStrategyChangeNotes');
                        if (changeNotes) {
                            changeNotes.value = `Restored from version ${version}`;
                        }
                        
                        // Mark as changed to enable save
                        branchingStrategyState.hasChanges = true;
                        updateBranchingStrategySaveButton(true);
                        
                        // Close any open modals
                        closeModal();
                        
                        showNotification(`Branching strategy restored from version ${version}. Click Save to apply.`, 'success');
                    }
                }
            } catch (error) {
                showNotification('Error restoring version: ' + error.message, 'error');
            }
        }
        
        // Export branching strategy
        function exportBranchingStrategy() {
            try {
                const textarea = document.getElementById('branchingStrategy');
                const version = document.getElementById('branchingStrategyVersion').textContent;
                
                const exportData = {
                    type: 'branching_strategy',
                    version: version,
                    strategy: textarea.value,
                    exported_at: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `branching_strategy_v${version}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Branching strategy exported successfully', 'success');
            } catch (error) {
                showNotification('Error exporting branching strategy: ' + error.message, 'error');
            }
        }
        
        // Import branching strategy
        function importBranchingStrategy() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,.txt';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const content = event.target.result;
                            let strategy = '';
                            
                            // Try to parse as JSON first
                            try {
                                const data = JSON.parse(content);
                                if (data.strategy) {
                                    strategy = data.strategy;
                                } else if (typeof data === 'string') {
                                    strategy = data;
                                }
                            } catch {
                                // If not JSON, treat as plain text
                                strategy = content;
                            }
                            
                            const textarea = document.getElementById('branchingStrategy');
                            if (textarea && strategy) {
                                textarea.value = strategy;
                                trackBranchingStrategyChange();
                                validateBranchingStrategy();
                                showNotification('Branching strategy imported. Remember to save!', 'info');
                            }
                        } catch (error) {
                            showNotification('Error parsing imported file: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            } catch (error) {
                showNotification('Error importing branching strategy: ' + error.message, 'error');
            }
        }
        
        async function loadToolCategories() {
            try {
                const response = await fetchAPI('/api/tools/categories');
                console.log('Loaded tool categories:', response);
                
                const container = document.getElementById('toolCategoriesList');
                if (!container) return;
                
                // Extract the categories array from the response object
                const categories = response.categories || [];
                
                if (categories.length === 0) {
                    container.innerHTML = '<div class="workflow-section-empty">No tool categories configured</div>';
                    return;
                }
                
                // Store categories globally for search functionality
                window.toolCategories = categories;
                
                // If filtering by enabled tools, load all tools data first
                let filteredCategories = categories;
                if (currentToolsFilter === 'enabled') {
                    // Load tools for all categories to count enabled ones
                    const categoriesWithEnabledCount = await Promise.all(categories.map(async (category) => {
                        const toolsResponse = await fetchAPI(`/api/tools/category/${category.name}`);
                        const tools = toolsResponse.tools || [];
                        const enabledTools = tools.filter(tool => tool.enabled);
                        return {
                            ...category,
                            tool_count: enabledTools.length,
                            hasEnabledTools: enabledTools.length > 0
                        };
                    }));
                    
                    // Filter out categories with no enabled tools
                    filteredCategories = categoriesWithEnabledCount.filter(cat => cat.hasEnabledTools);
                    
                    if (filteredCategories.length === 0) {
                        container.innerHTML = '<div class="workflow-section-empty">No enabled tools found</div>';
                        return;
                    }
                }
                
                container.innerHTML = filteredCategories.map((category, index) => {
                    const categoryId = `category-${category.name.replace(/[^a-z0-9]/g, '-')}`;
                    // Default to collapsed unless explicitly expanded
                    const isExpanded = window.toolCategoryExpanded && window.toolCategoryExpanded[category.name] === true;
                    
                    return `
                        <div class="workflow-section ${isExpanded ? '' : 'collapsed'}" id="${categoryId}">
                            <div class="workflow-section-header" onclick="toggleToolCategory('${categoryId}', '${category.name}')">
                                <h4 class="workflow-section-title">${category.displayName}</h4>
                                <span class="workflow-section-count">${category.tool_count || 0}</span>
                                <span class="workflow-section-toggle">${isExpanded ? '&#9660;' : '&#9650;'}</span>
                                <div style="margin-left: auto; display: flex; gap: 10px;">
                                    <button class="btn-icon" onclick="event.stopPropagation(); editToolCategory('${category.name}')" title="Edit Category">
                                        <span style="font-size: 16px;">&#9998;</span>
                                    </button>
                                    <button class="btn-icon" onclick="event.stopPropagation(); deleteToolCategory('${category.name}')" title="Delete Category">
                                        <span style="font-size: 16px;">&#128465;</span>
                                    </button>
                                </div>
                            </div>
                            <div class="workflow-section-content" id="tools-${category.name}">
                                <div style="padding: 15px;">
                                    <div style="margin-bottom: 10px;">
                                        <button class="btn-secondary" onclick="addToolToCategory('${category.name}')">+ Add Tool</button>
                                        <button class="btn-secondary" onclick="toggleAllTools('${category.name}', true)">Enable All</button>
                                        <button class="btn-secondary" onclick="toggleAllTools('${category.name}', false)">Disable All</button>
                                    </div>
                                    <div id="tools-list-${category.name}" style="margin-top: 10px;">
                                        <div style="color: #666;">Loading tools...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Initialize expanded state tracking
                if (!window.toolCategoryExpanded) {
                    window.toolCategoryExpanded = {};
                }
                
                // Load tools for each category
                for (const category of categories) {
                    loadToolsForCategory(category.name);
                }
            } catch (error) {
                console.error('Error loading tool categories:', error);
                const container = document.getElementById('toolCategoriesList');
                if (container) {
                    container.innerHTML = '<div style="color: #ef4444; padding: 10px;">Failed to load tool categories</div>';
                }
            }
        }
        
        async function loadToolsForCategory(categoryName) {
            try {
                const response = await fetchAPI(`/api/tools/category/${categoryName}`);
                const container = document.getElementById(`tools-list-${categoryName}`);
                if (!container) return;
                
                // Extract the tools array from the response object
                let tools = response.tools || [];
                
                // Filter tools if in enabled mode
                if (currentToolsFilter === 'enabled') {
                    tools = tools.filter(tool => tool.enabled);
                }
                
                if (tools.length === 0) {
                    const message = currentToolsFilter === 'enabled' ? 
                        'No enabled tools in this category' : 
                        'No tools in this category';
                    container.innerHTML = `<div style="color: #666; padding: 10px;">${message}</div>`;
                    return;
                }
                
                container.innerHTML = `
                    <div style="display: grid; gap: 10px;">
                        ${tools.map(tool => `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; 
                                        background: #2a2a2a; border-radius: 6px; border: 1px solid #333;">
                                <div style="flex-grow: 1;">
                                    <div style="color: #e0e0e0; font-weight: 500;">${tool.displayName}</div>
                                    <div style="font-size: 0.85em; color: #999; margin-top: 2px;">${tool.description}</div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <button class="btn-icon" 
                                            data-tool-name="${tool.name}"
                                            data-category-name="${categoryName}"
                                            onclick="editToolFromButton(this)" 
                                            title="Edit Tool">
                                        <span style="font-size: 14px;">&#9998;</span>
                                    </button>
                                    <button class="btn-icon" 
                                            data-tool-name="${tool.name}"
                                            data-category-name="${categoryName}"
                                            onclick="deleteToolFromButton(this)" 
                                            title="Delete Tool">
                                        <span style="font-size: 14px;">&#128465;</span>
                                    </button>
                                    <div class="toggle-switch">
                                        <input type="checkbox" id="tool-${tool.name}" ${tool.enabled ? 'checked' : ''} 
                                               data-tool-name="${tool.name}" 
                                               data-category-name="${categoryName}"
                                               onchange="handleIndividualToolToggle(event)">
                                        <span class="toggle-slider"></span>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // Store tools data for search functionality
                if (!window.toolsData) window.toolsData = {};
                window.toolsData[categoryName] = tools;
            } catch (error) {
                console.error(`Error loading tools for category ${categoryName}:`, error);
                const container = document.getElementById(`tools-list-${categoryName}`);
                if (container) {
                    container.innerHTML = '<div style="color: #ef4444;">Failed to load tools</div>';
                }
            }
        }
        
        async function toggleMCPServer(serverName) {
            try {
                await fetchAPI(`/api/mcp-servers/${serverName}/toggle`, {
                    method: 'POST'
                });
                showMessage('mcpSettingsMessage', `Toggled ${serverName} server`, 'success');
            } catch (error) {
                console.error('Error toggling MCP server:', error);
                showMessage('mcpSettingsMessage', 'Failed to toggle server', 'error');
            }
        }
        
        async function toggleTool(toolName, enabled, categoryName) {
            try {
                console.log(`Toggling tool: ${toolName} to ${enabled ? 'enabled' : 'disabled'}`);
                const response = await fetchAPI(`/api/tools/${toolName}/toggle`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });
                
                console.log('Toggle response:', response);
                
                if (response.status === 'success') {
                    showMessage('toolsSettingsMessage', `Tool ${enabled ? 'enabled' : 'disabled'}: ${toolName}`, 'success');
                    return true;
                } else {
                    showMessage('toolsSettingsMessage', `Failed to toggle tool: ${response.message || 'Unknown error'}`, 'error');
                    return false;
                }
            } catch (error) {
                console.error('Error toggling tool:', error);
                showMessage('toolsSettingsMessage', `Error toggling tool: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Persona Instance Management
        async function showCreatePersonaModal() {
            // Create modal HTML for creating a new persona type
            const modalHtml = `
                <div id="createPersonaModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 500px;">
                        <div class="modal-header">
                            <h2>Create New Persona Type</h2>
                            <span class="close" onclick="document.getElementById('createPersonaModal').remove()">&times;</span>
                        </div>
                        <div class="modal-body">
                            <form id="createPersonaForm">
                                <div class="form-group">
                                    <label for="newPersonaTypeName">Persona Type Name:</label>
                                    <input type="text" id="newPersonaTypeName" class="form-control" 
                                           placeholder="e.g., Data Scientist, DevOps Engineer, etc." 
                                           required autofocus>
                                </div>
                                
                                <div class="form-actions" style="margin-top: 20px;">
                                    <button type="submit" class="btn-primary">Create</button>
                                    <button type="button" class="btn-secondary" onclick="document.getElementById('createPersonaModal').remove()">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Add form submit handler
            document.getElementById('createPersonaForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                await createNewPersonaType();
            });
        }
        
        async function createNewPersonaType() {
            try {
                const personaTypeName = document.getElementById('newPersonaTypeName').value.trim();
                
                if (!personaTypeName) {
                    showNotification('Please enter a persona type name', 'error');
                    return;
                }
                
                // Convert name to a type identifier (lowercase, replace spaces with underscores)
                const typeId = personaTypeName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
                
                // Call API to create new persona type
                const response = await fetchAPI('/api/personas/types', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: typeId,
                        display_name: personaTypeName,
                        description: `${personaTypeName} persona type`,
                        category: 'custom',
                        default_first_name: personaTypeName.split(' ')[0],
                        default_last_name: 'Bot',
                        default_email: `${typeId}@company.com`,
                        default_skills: [],
                        prompts: {
                            prompt: `You are a ${personaTypeName}.`,
                            version: 1,
                            last_updated: new Date().toISOString()
                        },
                        mcp_servers: {},
                        default_tools: [],
                        custom_tools: []
                    })
                });
                
                if (response && (response.status === 'success' || response.success)) {
                    showNotification('Persona type created successfully!', 'success');
                    document.getElementById('createPersonaModal').remove();
                    // Reload persona types to show the new one
                    loadPersonaTypes();
                } else {
                    throw new Error(response?.message || response?.error || 'Failed to create persona type');
                }
            } catch (error) {
                console.error('Error creating persona type:', error);
                showNotification(error.message || 'Failed to create persona type', 'error');
            }
        }
        
        async function deletePersonaType(personaType) {
            // Confirm deletion
            const confirmed = confirm(`Are you sure you want to delete the persona type "${personaType}"?\n\nThis action cannot be undone.`);
            
            if (!confirmed) {
                return;
            }
            
            try {
                const response = await fetch(`http://localhost:8080/api/personas/types/${personaType}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to delete persona type');
                }
                
                const result = await response.json();
                
                // Show success notification
                showNotification(`Persona type "${personaType}" deleted successfully`, 'success');
                
                // Reload the persona types grid
                await loadPersonaTypes();
                
            } catch (error) {
                console.error('Error deleting persona type:', error);
                showNotification(`Failed to delete persona type: ${error.message}`, 'error');
            }
        }
        
        function addNewPersonaSkill() {
            const input = document.getElementById('newPersonaSkillInput');
            const skill = input.value.trim();
            
            if (!skill || window.newPersonaSkills.includes(skill)) return;
            
            window.newPersonaSkills.push(skill);
            displayNewPersonaSkills();
            input.value = '';
        }
        
        function displayNewPersonaSkills() {
            const container = document.getElementById('newPersonaSkillsTags');
            container.innerHTML = window.newPersonaSkills.map(skill => `
                <span class="skill-tag">
                    ${skill}
                    <span class="remove-skill" onclick="removeNewPersonaSkill('${skill.replace(/'/g, "\\'")}')">&times;</span>
                </span>
            `).join('');
        }
        
        function removeNewPersonaSkill(skill) {
            window.newPersonaSkills = window.newPersonaSkills.filter(s => s !== skill);
            displayNewPersonaSkills();
        }
        
        async function createNewPersona() {
            try {
                const personaType = document.getElementById('newPersonaType').value;
                const firstName = document.getElementById('newPersonaFirstName').value;
                const lastName = document.getElementById('newPersonaLastName').value;
                const email = document.getElementById('newPersonaEmail').value;
                const role = document.getElementById('newPersonaRole').value;
                const skills = window.newPersonaSkills.join(', ');
                
                // Call API to create new persona instance
                const response = await fetchAPI('/api/personas/instances', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        persona_type: personaType,
                        first_name: firstName,
                        last_name: lastName,
                        email: email,
                        role: role,
                        skills: skills
                    })
                });
                
                if (response && response.status === 'success') {
                    showNotification('Persona created successfully!', 'success');
                    document.getElementById('createPersonaModal').remove();
                    updateDashboard(); // Refresh the dashboard
                } else {
                    throw new Error(response?.message || 'Failed to create persona');
                }
            } catch (error) {
                console.error('Error creating persona:', error);
                showNotification(`Failed to create persona: ${error.message}`, 'error');
            }
        }
        
        async function editPersonaInstance(instanceId) {
            console.log('editPersonaInstance called with:', instanceId);
            try {
                // Fetch persona instance details
                const response = await fetchAPI(`/api/personas/instances/${instanceId}`);
                if (!response || !response.instance) {
                    showNotification('Persona instance not found', 'error');
                    return;
                }
                
                const instance = response.instance;
                
                // Get all persona types for the type dropdown
                const typesResponse = await fetchAPI('/api/personas/types');
                const types = typesResponse.types || [];
                
                // Update the personas tab content to show the edit view
                const personasTab = document.getElementById('personas-tab');
                if (!personasTab) return;
                
                personasTab.innerHTML = `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; max-width: 100%; box-sizing: border-box;">
                        <!-- Header with back button -->
                        <div style="display: flex; align-items: center; margin-bottom: 20px;">
                            <button class="btn-secondary" onclick="restorePersonasTab()" style="margin-right: 20px;">
                                &larr; Back to Personas
                            </button>
                            <h3 style="margin: 0; color: #3b82f6;">Edit Persona Instance: ${instance.full_name}</h3>
                        </div>
                        
                        <!-- Basic Info Section -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Basic Information</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                                <div>
                                    <label style="display: block; color: #888; margin-bottom: 5px;">Persona Type</label>
                                    <select id="personaType" style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                            border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        ${types.map(type => `
                                            <option value="${type.type}" ${type.type === instance.persona_type ? 'selected' : ''}>
                                                ${type.display_name}
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; color: #888; margin-bottom: 5px;">Email</label>
                                    <input type="email" id="personaEmail" value="${instance.email || ''}" 
                                           style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                  border: 1px solid #444; color: #fff; border-radius: 4px;">
                                </div>
                                <div>
                                    <label style="display: block; color: #888; margin-bottom: 5px;">First Name</label>
                                    <input type="text" id="personaFirstName" value="${instance.first_name || ''}" 
                                           style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                  border: 1px solid #444; color: #fff; border-radius: 4px;">
                                </div>
                                <div>
                                    <label style="display: block; color: #888; margin-bottom: 5px;">Last Name</label>
                                    <input type="text" id="personaLastName" value="${instance.last_name || ''}" 
                                           style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                                  border: 1px solid #444; color: #fff; border-radius: 4px;">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Persona Prompt Section -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Persona Prompt</h4>
                            <textarea id="instancePrompt" style="width: 100%; height: 300px; padding: 15px; background: #2a2a2a; 
                                      border: 1px solid #444; color: #fff; font-family: 'Monaco', 'Menlo', monospace; 
                                      font-size: 14px; line-height: 1.5; border-radius: 4px; overflow-y: auto; resize: none;"
                                      placeholder="Enter the persona-specific prompt here...">${instance.prompt || ''}</textarea>
                        </div>
                        
                        <!-- Skills Section -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Skills</h4>
                            <div style="margin-bottom: 15px;">
                                <div id="personaSkillsList" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                                    ${(instance.skills || []).map((skill, index) => `
                                        <span class="skill-tag" data-skill="${skill}" style="background: #2a2a2a; padding: 5px 12px; 
                                              border-radius: 4px; border: 1px solid #444; color: #ccc; font-size: 13px; 
                                              display: flex; align-items: center; gap: 8px;">
                                            ${skill}
                                            <button onclick="removeSkill('${skill}')" style="background: none; border: none; 
                                                    color: #888; cursor: pointer; font-size: 16px; padding: 0; line-height: 1;">
                                                &times;
                                            </button>
                                        </span>
                                    `).join('')}
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="newSkillInput" placeholder="Add a new skill..." 
                                           onkeypress="if(event.key === 'Enter') addSkill()"
                                           style="flex: 1; padding: 8px 12px; background: #2a2a2a; 
                                                  border: 1px solid #444; color: #fff; border-radius: 4px;">
                                    <button class="btn-primary" onclick="addSkill()" style="padding: 8px 20px;">
                                        Add Skill
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Tools Section -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">Tools</h4>
                            <div style="margin-bottom: 15px;">
                                <input type="text" id="toolsSearchInput" placeholder="Search tools..." 
                                       onkeyup="filterPersonaTools()" 
                                       style="width: 100%; padding: 8px 12px; background: #2a2a2a; 
                                              border: 1px solid #444; color: #fff; border-radius: 4px;">
                            </div>
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <button class="btn-secondary" onclick="showAllTools()" id="showAllToolsBtn">
                                    All Tools
                                </button>
                                <button class="btn-secondary" onclick="showSelectedTools()" id="showSelectedToolsBtn">
                                    Selected Tools
                                </button>
                            </div>
                            <div id="personaToolsList" style="max-height: 400px; overflow-y: auto; 
                                 background: #2a2a2a; padding: 15px; border-radius: 4px; border: 1px solid #444;">
                                <!-- Tools will be loaded here -->
                            </div>
                        </div>
                        
                        <!-- MCP Servers Section -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #ccc; margin-bottom: 15px;">MCP Servers</h4>
                            <div id="instanceMCPServers" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                                <!-- MCP servers will be loaded here -->
                            </div>
                        </div>
                        
                        <!-- Save/Cancel Buttons -->
                        <div style="display: flex; justify-content: flex-end; gap: 10px;">
                            <button class="btn-cancel" onclick="switchSettingsTab('personas')" style="padding: 10px 30px;">
                                Cancel
                            </button>
                            <button class="btn-save" onclick="savePersonaInstance('${instanceId}')" style="padding: 10px 30px;">
                                Save Changes
                            </button>
                        </div>
                    </div>
                `;
                
                // Load tools and MCP servers
                await loadPersonaTools(instance.tools || []);
                await loadInstanceMCPServers(instance.mcp_servers || []);
                
                // Store instance data globally for save function
                window.currentEditingInstance = instance;
                
            } catch (error) {
                console.error('Error loading persona instance:', error);
                console.error('Full error details:', error);
                showNotification(`Failed to load persona instance: ${error.message}`, 'error');
            }
        }
        
        // Helper functions for persona instance editing
        function removeSkill(skill) {
            const skillsList = document.getElementById('personaSkillsList');
            const skillTag = skillsList.querySelector(`[data-skill="${skill}"]`);
            if (skillTag) {
                skillTag.remove();
            }
        }
        
        function addSkill() {
            const input = document.getElementById('newSkillInput');
            const skill = input.value.trim();
            
            if (!skill) return;
            
            // Check if skill already exists
            const skillsList = document.getElementById('personaSkillsList');
            const existingSkills = Array.from(skillsList.querySelectorAll('[data-skill]'))
                .map(el => el.getAttribute('data-skill'));
            
            if (existingSkills.includes(skill)) {
                showNotification('Skill already exists', 'error');
                return;
            }
            
            // Add new skill tag
            const skillTag = document.createElement('span');
            skillTag.className = 'skill-tag';
            skillTag.setAttribute('data-skill', skill);
            skillTag.style = 'background: #2a2a2a; padding: 5px 12px; border-radius: 4px; border: 1px solid #444; color: #ccc; font-size: 13px; display: flex; align-items: center; gap: 8px;';
            skillTag.innerHTML = `
                ${skill}
                <button onclick="removeSkill('${skill}')" style="background: none; border: none; 
                        color: #888; cursor: pointer; font-size: 16px; padding: 0; line-height: 1;">
                    &times;
                </button>
            `;
            
            skillsList.appendChild(skillTag);
            input.value = '';
        }
        
        let currentToolsView = 'all'; // Track current view
        let allToolsData = []; // Store all tools
        
        async function loadPersonaTools(selectedTools = []) {
            try {
                // Load all tool categories
                const response = await fetchAPI('/api/tools/categories');
                const categories = response.categories || [];
                
                allToolsData = [];
                
                // Load tools from each category
                for (const category of categories) {
                    const toolsResponse = await fetchAPI(`/api/tools/category/${category.name}`);
                    const tools = toolsResponse.tools || [];
                    
                    tools.forEach(tool => {
                        allToolsData.push({
                            ...tool,
                            category: category.displayName,
                            selected: selectedTools.includes(tool.name)
                        });
                    });
                }
                
                // Display tools
                displayPersonaTools();
                
            } catch (error) {
                console.error('Error loading tools:', error);
                document.getElementById('personaToolsList').innerHTML = 
                    '<p style="color: #ef4444;">Error loading tools</p>';
            }
        }
        
        function displayPersonaTools() {
            const toolsList = document.getElementById('personaToolsList');
            const searchTerm = document.getElementById('toolsSearchInput').value.toLowerCase();
            
            // Filter tools based on view and search
            let toolsToDisplay = allToolsData;
            
            if (currentToolsView === 'selected') {
                toolsToDisplay = toolsToDisplay.filter(tool => tool.selected);
            }
            
            if (searchTerm) {
                toolsToDisplay = toolsToDisplay.filter(tool => 
                    tool.displayName.toLowerCase().includes(searchTerm) ||
                    tool.name.toLowerCase().includes(searchTerm) ||
                    tool.category.toLowerCase().includes(searchTerm)
                );
            }
            
            // Group by category
            const groupedTools = {};
            toolsToDisplay.forEach(tool => {
                if (!groupedTools[tool.category]) {
                    groupedTools[tool.category] = [];
                }
                groupedTools[tool.category].push(tool);
            });
            
            // Render tools
            let html = '';
            
            if (Object.keys(groupedTools).length === 0) {
                html = '<p style="color: #888; text-align: center; padding: 20px;">No tools found</p>';
            } else {
                for (const [category, tools] of Object.entries(groupedTools)) {
                    html += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #999; margin-bottom: 10px;">${category}</h5>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                                ${tools.map(tool => `
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" value="${tool.name}" 
                                               ${tool.selected ? 'checked' : ''}
                                               onchange="toggleToolSelection('${tool.name}')"
                                               style="margin-right: 8px;">
                                        <span style="color: #ccc;">${tool.displayName}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            }
            
            toolsList.innerHTML = html;
        }
        
        function toggleToolSelection(toolName) {
            const tool = allToolsData.find(t => t.name === toolName);
            if (tool) {
                tool.selected = !tool.selected;
            }
        }
        
        function filterPersonaTools() {
            displayPersonaTools();
        }
        
        function showAllTools() {
            currentToolsView = 'all';
            document.getElementById('showAllToolsBtn').style.background = '#3b82f6';
            document.getElementById('showSelectedToolsBtn').style.background = '#374151';
            displayPersonaTools();
        }
        
        function showSelectedTools() {
            currentToolsView = 'selected';
            document.getElementById('showSelectedToolsBtn').style.background = '#3b82f6';
            document.getElementById('showAllToolsBtn').style.background = '#374151';
            displayPersonaTools();
        }
        
        async function loadInstanceMCPServers(selectedServers = []) {
            try {
                const response = await fetchAPI('/api/mcp-servers');
                if (!response || !response.servers) {
                    return;
                }
                
                const servers = response.servers;
                const container = document.getElementById('instanceMCPServers');
                
                container.innerHTML = servers.map(server => `
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #444;">
                        <label style="display: flex; align-items: start; cursor: pointer;">
                            <input type="checkbox" id="instance-mcp-${server.name}" value="${server.name}" 
                                   ${selectedServers.includes(server.name) ? 'checked' : ''}
                                   style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; color: #fff;">${server.displayName}</div>
                                <div style="font-size: 12px; color: #888; margin-top: 4px;">${server.description}</div>
                            </div>
                        </label>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading MCP servers:', error);
            }
        }
        
        // Persona Workflow Management
        function togglePersonaWorkflowEdit() {
            const contentDiv = document.getElementById('persona-workflow-content');
            const defaultDiv = document.getElementById('persona-workflow-default');
            const toggleBtn = document.getElementById('persona-workflow-toggle-btn');
            
            if (contentDiv.style.display === 'none') {
                // Show edit mode
                contentDiv.style.display = 'block';
                defaultDiv.style.display = 'none';
                toggleBtn.textContent = 'Hide Editor';
                
                // Load workflow data if we have a workflow_id
                if (window.currentEditingType && window.currentEditingType.workflow_id) {
                    loadPersonaWorkflow(window.currentEditingType.workflow_id);
                }
            } else {
                // Hide edit mode
                contentDiv.style.display = 'none';
                defaultDiv.style.display = 'block';
                toggleBtn.textContent = 'Edit Workflow';
            }
        }
        
        async function loadPersonaWorkflow(workflowId) {
            try {
                const response = await fetchAPI(`/api/workflows/${workflowId}`);
                if (response && response.success && response.workflow) {
                    const workflow = response.workflow;
                    document.getElementById('persona-workflow-yaml').value = workflow.yaml;
                    document.getElementById('persona-workflow-count').textContent = `Version ${workflow.version}`;
                    document.getElementById('persona-workflow-status').innerHTML = '<span style="color: #10b981;">&#10003;</span> Loaded';
                } else {
                    throw new Error('Failed to load workflow');
                }
            } catch (error) {
                console.error('Failed to load persona workflow:', error);
                document.getElementById('persona-workflow-status').innerHTML = '<span style="color: #ef4444;">&#10007;</span> Failed to load';
                showNotification('Failed to load workflow', 'error');
            }
        }
        
        async function validatePersonaWorkflow() {
            try {
                const yamlContent = document.getElementById('persona-workflow-yaml').value;
                const response = await fetchAPI('/api/workflows/validate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ yaml: yamlContent })
                });
                
                const resultDiv = document.getElementById('persona-workflow-validation-result');
                if (response && response.success) {
                    resultDiv.innerHTML = '<div style="color: #10b981; margin-top: 10px;">&#10003; Workflow is valid</div>';
                } else {
                    resultDiv.innerHTML = `<div style="color: #ef4444; margin-top: 10px;">&#10007; Validation failed: ${response.error || 'Unknown error'}</div>`;
                }
            } catch (error) {
                console.error('Validation error:', error);
                showNotification('Failed to validate workflow', 'error');
            }
        }
        
        function exportPersonaWorkflow() {
            const yamlContent = document.getElementById('persona-workflow-yaml').value;
            const blob = new Blob([yamlContent], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `persona-workflow-${window.currentEditingType?.type || 'export'}.yaml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('Workflow exported successfully', 'success');
        }
        
        function importPersonaWorkflow() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.yaml,.yml';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const content = await file.text();
                        document.getElementById('persona-workflow-yaml').value = content;
                        trackPersonaTypeChanges();
                        showNotification('Workflow imported successfully', 'success');
                    } catch (error) {
                        console.error('Import error:', error);
                        showNotification('Failed to import workflow', 'error');
                    }
                }
            };
            input.click();
        }
        
        function showPersonaWorkflowDiagram(type) {
            showNotification(`${type} diagram view - to be implemented`, 'info');
        }
        
        function viewPersonaWorkflowHistory() {
            showNotification('Workflow history - to be implemented', 'info');
        }
        
        // MCP Server Management
        
        async function configureMCPServer(serverName) {
            try {
                // Get current MCP server configuration
                const response = await fetchAPI('/api/mcp-servers');
                const servers = response.servers || [];
                const server = servers.find(s => s.name === serverName);
                
                if (!server) {
                    showMessage('mcpSettingsMessage', `Server ${serverName} not found`, 'error');
                    return;
                }
                
                // Create configuration modal content
                const modalContent = `
                    <div style="margin-bottom: 15px;">
                        <h3 style="margin: 0 0 15px 0; color: #e0e0e0;">Configure ${serverName}</h3>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Enabled:</label>
                            <input type="checkbox" id="server-enabled" ${server.enabled ? 'checked' : ''} 
                                   style="margin-right: 10px;">
                            <span style="color: #ccc;">Enable this MCP server</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Command:</label>
                            <input type="text" id="server-command" value="${server.command || ''}" 
                                   style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                          border-radius: 4px; color: #e0e0e0; font-size: 14px;" 
                                   placeholder="e.g., uvx mcp-server-git --repository /path/to/repo">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Arguments:</label>
                            <textarea id="server-args" rows="3" 
                                      style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                             border-radius: 4px; color: #e0e0e0; font-size: 14px; resize: vertical;" 
                                      placeholder="Additional server arguments (one per line)">${(server.args || []).join('\n')}</textarea>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc;">Environment Variables:</label>
                            <textarea id="server-env" rows="3" 
                                      style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; 
                                             border-radius: 4px; color: #e0e0e0; font-size: 14px; resize: vertical;" 
                                      placeholder="KEY=value (one per line)">${Object.entries(server.env || {}).map(([k,v]) => `${k}=${v}`).join('\n')}</textarea>
                        </div>
                    </div>
                `;
                
                // Show modal
                showModal('Configure MCP Server', modalContent, [
                    {
                        text: 'Save',
                        className: 'btn-primary',
                        onClick: () => saveMCPServerConfig(serverName)
                    },
                    {
                        text: 'Cancel',
                        className: 'btn-secondary',
                        onClick: closeModal
                    }
                ]);
                
            } catch (error) {
                console.error('Error loading MCP server configuration:', error);
                showMessage('mcpSettingsMessage', 'Failed to load server configuration: ' + error.message, 'error');
            }
        }
        
        async function saveMCPServerConfig(serverName) {
            try {
                const enabled = document.getElementById('server-enabled').checked;
                const command = document.getElementById('server-command').value.trim();
                const argsText = document.getElementById('server-args').value.trim();
                const envText = document.getElementById('server-env').value.trim();
                
                // Parse arguments
                const args = argsText ? argsText.split('\n').filter(line => line.trim()) : [];
                
                // Parse environment variables
                const env = {};
                if (envText) {
                    envText.split('\n').forEach(line => {
                        const [key, ...valueParts] = line.split('=');
                        if (key && key.trim()) {
                            env[key.trim()] = valueParts.join('=').trim();
                        }
                    });
                }
                
                // Update server configuration
                const config = {
                    enabled,
                    command,
                    args,
                    env
                };
                
                const response = await fetchAPI(`/api/mcp-servers/${serverName}/config`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (response.success) {
                    closeModal();
                    showMessage('mcpSettingsMessage', `${serverName} configuration saved successfully`, 'success');
                    // Refresh MCP servers list
                    await loadMCPServers();
                } else {
                    showMessage('mcpSettingsMessage', `Failed to save ${serverName} configuration`, 'error');
                }
                
            } catch (error) {
                console.error('Error saving MCP server configuration:', error);
                showMessage('mcpSettingsMessage', 'Failed to save configuration: ' + error.message, 'error');
            }
        }
        
        async function saveMCPSettings() {
            try {
                // Collect MCP server states
                const mcpServers = {};
                document.querySelectorAll('#mcpServersList input[type="checkbox"]').forEach(checkbox => {
                    const serverName = checkbox.dataset.serverName || checkbox.value;
                    mcpServers[serverName] = {
                        enabled: checkbox.checked,
                        name: serverName
                    };
                });
                
                // Call the backend API
                const response = await fetchAPI('/api/settings/mcp', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        servers: mcpServers,
                        updated_at: new Date().toISOString()
                    })
                });
                
                if (response && response.status === 'success') {
                    showNotification('MCP settings saved successfully', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save MCP settings');
                }
                
            } catch (error) {
                console.error('Error saving MCP settings:', error);
                showNotification(`Failed to save MCP settings: ${error.message}`, 'error');
            }
        }
        
        // Tools Management
        function searchTools() {
            const searchTerm = document.getElementById('toolsSearchInput').value.toLowerCase();
            
            if (!window.toolsData) return;
            
            // Show/hide tools based on search
            for (const [categoryName, tools] of Object.entries(window.toolsData)) {
                let categoryHasVisibleTools = false;
                
                tools.forEach(tool => {
                    // Skip disabled tools if in enabled filter mode
                    if (currentToolsFilter === 'enabled' && !tool.enabled) {
                        return;
                    }
                    
                    const toolElement = document.querySelector(`#tools-list-${categoryName} [id="tool-${tool.name}"]`)?.closest('div[style*="display: flex"]');
                    if (toolElement) {
                        const matches = tool.displayName.toLowerCase().includes(searchTerm) || 
                                      tool.description.toLowerCase().includes(searchTerm) ||
                                      tool.name.toLowerCase().includes(searchTerm);
                        toolElement.style.display = matches || !searchTerm ? 'flex' : 'none';
                        if (matches || !searchTerm) categoryHasVisibleTools = true;
                    }
                });
                
                // Show/hide category based on whether it has visible tools
                const categoryElement = document.getElementById(`category-${categoryName.replace(/[^a-z0-9]/g, '-')}`);
                if (categoryElement) {
                    categoryElement.style.display = categoryHasVisibleTools || !searchTerm ? 'block' : 'none';
                }
            }
        }
        
        function toggleToolCategory(sectionId, categoryName) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('collapsed');
            
            // Update the arrow icon
            const isCollapsed = section.classList.contains('collapsed');
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isCollapsed ? '&#9650;' : '&#9660;';
            }
            
            // Save expanded state
            if (!window.toolCategoryExpanded) window.toolCategoryExpanded = {};
            window.toolCategoryExpanded[categoryName] = !isCollapsed;
        }
        
        async function toggleAllTools(categoryName, enable) {
            try {
                // Find the category section
                const categoryId = `category-${categoryName.replace(/[^a-z0-9]/g, '-')}`;
                const section = document.getElementById(categoryId);
                
                // If category is collapsed, expand it first
                if (section && section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    const toggle = section.querySelector('.workflow-section-toggle');
                    if (toggle) {
                        toggle.innerHTML = '&#9660;';
                    }
                    // Update expanded state
                    if (!window.toolCategoryExpanded) window.toolCategoryExpanded = {};
                    window.toolCategoryExpanded[categoryName] = true;
                    
                    // Load tools for this category
                    await loadToolsForCategory(categoryName);
                }
                
                // Use the new bulk toggle API
                const response = await fetchAPI(`/api/tools/category/${categoryName}/toggle-all`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled: enable })
                });
                
                if (response.status === 'success') {
                    // Update UI based on the actual result
                    const result = response.result;
                    
                    // Update all checkboxes to reflect actual state
                    const tools = window.toolsData[categoryName] || [];
                    for (const tool of tools) {
                        const checkbox = document.getElementById(`tool-${tool.name}`);
                        if (checkbox) {
                            checkbox.checked = enable;
                        }
                    }
                    
                    showMessage('toolsSettingsMessage', response.message, 'success');
                    
                    // Reload the category to ensure UI is in sync
                    await loadToolsForCategory(categoryName);
                } else {
                    showMessage('toolsSettingsMessage', response.message || 'Failed to toggle tools', 'error');
                }
            } catch (error) {
                console.error('Error toggling all tools:', error);
                showMessage('toolsSettingsMessage', 'Failed to toggle all tools', 'error');
            }
        }
        
        function addToolCategory() {
            showCategoryModal();
        }
        
        function editToolCategory(categoryName) {
            const category = window.toolCategories?.find(c => c.name === categoryName);
            if (category) {
                showCategoryModal(category);
            }
        }
        
        async function deleteToolCategory(categoryName) {
            if (confirm(`Are you sure you want to delete the category "${categoryName}" and all its tools?`)) {
                try {
                    const response = await fetchAPI(`/api/tools/category/${categoryName}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.status === 'success') {
                        showMessage('toolsSettingsMessage', response.message, 'success');
                        await loadToolCategories();
                    } else {
                        showMessage('toolsSettingsMessage', response.message || 'Failed to delete category', 'error');
                    }
                } catch (error) {
                    console.error('Error deleting category:', error);
                    showMessage('toolsSettingsMessage', 'Failed to delete category', 'error');
                }
            }
        }
        
        function addToolToCategory(categoryName) {
            showToolModal(categoryName);
        }
        
        function editTool(toolName, categoryName) {
            // Find the tool in the loaded data
            const category = window.toolCategories?.find(c => c.name === categoryName);
            const tool = category?.tools?.find(t => t.name === toolName);
            if (tool) {
                showToolModal(categoryName, tool);
            } else {
                showMessage('toolsSettingsMessage', `Tool "${toolName}" not found in category "${categoryName}"`, 'error');
            }
        }
        
        async function deleteTool(toolName, categoryName) {
            if (confirm(`Are you sure you want to delete the tool "${toolName}"?`)) {
                try {
                    const response = await fetchAPI(`/api/tools/${toolName}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.status === 'success') {
                        showMessage('toolsSettingsMessage', response.message, 'success');
                        await loadToolCategories();
                    } else {
                        showMessage('toolsSettingsMessage', response.message || 'Failed to delete tool', 'error');
                    }
                } catch (error) {
                    console.error('Error deleting tool:', error);
                    showMessage('toolsSettingsMessage', 'Failed to delete tool', 'error');
                }
            }
        }
        
        // Tool Category Modal Functions
        function showCategoryModal(category = null) {
            let modal = document.getElementById('categoryModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'categoryModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px;">
                        <div class="modal-header">
                            <h2 id="categoryModalTitle">Add Category</h2>
                            <span class="close-button" onclick="closeCategoryModal()">&times;</span>
                        </div>
                        <form id="categoryForm">
                            <input type="hidden" id="categoryOriginalName" />
                            <div class="form-group">
                                <label for="categoryDisplayName">Category Name</label>
                                <input type="text" id="categoryDisplayName" required 
                                    placeholder="e.g., Cloud Management Tools" />
                            </div>
                            <div class="modal-buttons">
                                <button type="button" class="btn-cancel" onclick="closeCategoryModal()">Cancel</button>
                                <button type="button" class="btn-save" onclick="saveCategory()">Save</button>
                            </div>
                        </form>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            if (category) {
                document.getElementById('categoryModalTitle').textContent = 'Edit Category';
                document.getElementById('categoryOriginalName').value = category.name;
                document.getElementById('categoryDisplayName').value = category.displayName;
            } else {
                document.getElementById('categoryModalTitle').textContent = 'Add Category';
                document.getElementById('categoryOriginalName').value = '';
                document.getElementById('categoryDisplayName').value = '';
            }
            
            modal.style.display = 'block';
        }
        
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        async function saveCategory() {
            const originalName = document.getElementById('categoryOriginalName').value;
            const displayName = document.getElementById('categoryDisplayName').value.trim();
            
            if (!displayName) {
                alert('Please enter a category name');
                return;
            }
            
            try {
                let response;
                if (originalName) {
                    // Update existing category
                    response = await fetchAPI(`/api/tools/category/${originalName}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ displayName })
                    });
                } else {
                    // Create new category
                    response = await fetchAPI('/api/tools/category', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ displayName })
                    });
                }
                
                if (response.status === 'success') {
                    showMessage('toolsSettingsMessage', response.message, 'success');
                    closeCategoryModal();
                    await loadToolCategories();
                } else {
                    showMessage('toolsSettingsMessage', response.message || 'Failed to save category', 'error');
                }
            } catch (error) {
                console.error('Error saving category:', error);
                showMessage('toolsSettingsMessage', 'Failed to save category', 'error');
            }
        }
        
        // Tool Modal Functions
        function showToolModal(categoryName, tool = null) {
            let modal = document.getElementById('toolModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'toolModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px;">
                        <div class="modal-header">
                            <h2 id="toolModalTitle">Add Tool</h2>
                            <span class="close-button" onclick="closeToolModal()">&times;</span>
                        </div>
                        <form id="toolForm">
                            <input type="hidden" id="toolOriginalName" />
                            <input type="hidden" id="toolCategory" />
                            <div class="form-group">
                                <label for="toolDisplayName">Tool Name</label>
                                <input type="text" id="toolDisplayName" required 
                                    placeholder="e.g., Docker" />
                            </div>
                            <div class="form-group">
                                <label for="toolDescription">Description</label>
                                <textarea id="toolDescription" rows="4" 
                                    style="width: 100%; resize: none;"
                                    placeholder="Brief description of this tool"></textarea>
                            </div>
                            <div class="modal-buttons">
                                <button type="button" class="btn-cancel" onclick="closeToolModal()">Cancel</button>
                                <button type="button" class="btn-save" onclick="saveTool()">Save</button>
                            </div>
                        </form>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            document.getElementById('toolCategory').value = categoryName;
            
            if (tool) {
                document.getElementById('toolModalTitle').textContent = 'Edit Tool';
                document.getElementById('toolOriginalName').value = tool.name;
                document.getElementById('toolDisplayName').value = tool.displayName;
                document.getElementById('toolDescription').value = tool.description || '';
            } else {
                document.getElementById('toolModalTitle').textContent = 'Add Tool';
                document.getElementById('toolOriginalName').value = '';
                document.getElementById('toolDisplayName').value = '';
                document.getElementById('toolDescription').value = '';
            }
            
            modal.style.display = 'block';
        }
        
        function closeToolModal() {
            const modal = document.getElementById('toolModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        async function saveTool() {
            const originalName = document.getElementById('toolOriginalName').value;
            const displayName = document.getElementById('toolDisplayName').value.trim();
            const description = document.getElementById('toolDescription').value.trim();
            const category = document.getElementById('toolCategory').value;
            
            if (!displayName) {
                alert('Please enter a tool name');
                return;
            }
            
            if (!category) {
                alert('Error: Category not set. Please close this modal and try again.');
                console.error('Category is missing!');
                return;
            }
            
            console.log('Saving tool:', { originalName, displayName, description, category });
            
            try {
                let response;
                if (originalName) {
                    // Update existing tool
                    response = await fetchAPI(`/api/tools/${originalName}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ displayName, description })
                    });
                } else {
                    // Create new tool
                    const requestData = { displayName, description, category, enabled: false };
                    console.log('Creating tool with data:', requestData);
                    
                    response = await fetchAPI('/api/tools', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestData)
                    });
                }
                
                if (response.status === 'success') {
                    showMessage('toolsSettingsMessage', response.message, 'success');
                    closeToolModal();
                    await loadToolCategories();
                } else {
                    showMessage('toolsSettingsMessage', response.message || 'Failed to save tool', 'error');
                }
            } catch (error) {
                console.error('Error saving tool:', error);
                showMessage('toolsSettingsMessage', 'Failed to save tool', 'error');
            }
        }
        
        async function exportToolsToMD() {
            try {
                showMessage('toolsSettingsMessage', 'Exporting tools configuration...', 'info');
                
                // Fetch the markdown content directly
                const response = await fetch('http://localhost:8080/api/tools/export');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Get the response as text (markdown)
                const mdContent = await response.text();
                
                // Create a blob with the markdown content
                const blob = new Blob([mdContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                
                // Create a download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `tools-export-${new Date().toISOString().split('T')[0]}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showMessage('toolsSettingsMessage', 'Tools configuration exported successfully!', 'success');
            } catch (error) {
                console.error('Error exporting tools:', error);
                showMessage('toolsSettingsMessage', 'Failed to export tools configuration', 'error');
            }
        }
        
        async function importToolsFromMD() {
            // Create a hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.md';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!file.name.endsWith('.md')) {
                    showMessage('toolsSettingsMessage', 'Please select a Markdown (.md) file', 'error');
                    return;
                }
                
                try {
                    // Read file content
                    const content = await file.text();
                    
                    // Confirm replacement
                    if (!confirm(`This will replace ALL existing tools with the contents of "${file.name}". This action cannot be undone. Continue?`)) {
                        return;
                    }
                    
                    // Show loading message
                    showMessage('toolsSettingsMessage', 'Importing tools from file...', 'info');
                    
                    // Call API to import
                    const response = await fetchAPI('/api/tools/import', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            content: content,
                            filename: file.name 
                        })
                    });
                    
                    if (response.status === 'success') {
                        showMessage('toolsSettingsMessage', 
                            `Successfully imported ${response.categoryCount} categories with ${response.toolCount} tools`, 
                            'success');
                        await loadToolCategories();
                    } else {
                        showMessage('toolsSettingsMessage', 
                            response.message || 'Failed to import tools', 
                            'error');
                    }
                } catch (error) {
                    console.error('Error importing tools:', error);
                    showMessage('toolsSettingsMessage', 'Failed to import tools: ' + error.message, 'error');
                }
            };
            
            // Trigger file selection
            fileInput.click();
        }
        
        function expandAllCategories() {
            document.querySelectorAll('#toolCategoriesList .workflow-section').forEach(section => {
                section.classList.remove('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9660;';
            });
            
            // Update stored state
            if (window.toolCategories) {
                window.toolCategories.forEach(category => {
                    if (!window.toolCategoryExpanded) window.toolCategoryExpanded = {};
                    window.toolCategoryExpanded[category.name] = true;
                });
            }
        }
        
        function collapseAllCategories() {
            document.querySelectorAll('#toolCategoriesList .workflow-section').forEach(section => {
                section.classList.add('collapsed');
                const toggle = section.querySelector('.workflow-section-toggle');
                if (toggle) toggle.innerHTML = '&#9650;';
            });
            
            // Update stored state
            if (window.toolCategories) {
                window.toolCategories.forEach(category => {
                    if (!window.toolCategoryExpanded) window.toolCategoryExpanded = {};
                    window.toolCategoryExpanded[category.name] = false;
                });
            }
        }
        
        // Wrapper functions for buttons with data attributes
        window.editToolFromButton = function(button) {
            const toolName = button.getAttribute('data-tool-name');
            const categoryName = button.getAttribute('data-category-name');
            editTool(toolName, categoryName);
        }
        
        window.deleteToolFromButton = function(button) {
            const toolName = button.getAttribute('data-tool-name');
            const categoryName = button.getAttribute('data-category-name');
            deleteTool(toolName, categoryName);
        }
        
        // Individual tool toggle handler
        window.handleIndividualToolToggle = async function(event) {
            event.stopPropagation(); // Prevent event bubbling
            
            const checkbox = event.target;
            const toolName = checkbox.getAttribute('data-tool-name');
            const categoryName = checkbox.getAttribute('data-category-name');
            
            console.log('handleIndividualToolToggle called:', toolName, categoryName);
            
            if (!toolName || !categoryName) {
                console.error('Missing tool data:', { toolName, categoryName });
                alert('Error: Missing tool information');
                return;
            }
            
            const originalState = !checkbox.checked; // The state before the user clicked
            const newState = checkbox.checked; // The state the user wants
            
            console.log(`Tool ${toolName}: originalState=${originalState}, newState=${newState}`);
            
            // Immediately revert to original state - we'll update it based on actual backend response
            checkbox.checked = originalState;
            
            try {
                const success = await toggleTool(toolName, newState, categoryName);
                if (success) {
                    // Backend succeeded - checkbox should show the new state
                    checkbox.checked = newState;
                    console.log(`Successfully toggled ${toolName} to ${newState}`);
                } else {
                    // Backend failed - checkbox remains in original state
                    checkbox.checked = originalState;
                    console.log(`Failed to toggle ${toolName}`);
                }
            } catch (error) {
                // Error occurred - checkbox remains in original state
                checkbox.checked = originalState;
                console.error('Error in individual tool toggle:', error);
            }
        }

        // Message display function
        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            element.textContent = message;
            element.className = ''; // Clear existing classes
            element.style.display = 'block';
            
            // Apply styling based on type
            if (type === 'success') {
                element.style.color = '#10b981';
                element.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                element.style.border = '1px solid rgba(16, 185, 129, 0.2)';
            } else if (type === 'error') {
                element.style.color = '#ef4444';
                element.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                element.style.border = '1px solid rgba(239, 68, 68, 0.2)';
            } else if (type === 'warning') {
                element.style.color = '#f59e0b';
                element.style.backgroundColor = 'rgba(245, 158, 11, 0.1)';
                element.style.border = '1px solid rgba(245, 158, 11, 0.2)';
            } else if (type === 'info') {
                element.style.color = '#3b82f6';
                element.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                element.style.border = '1px solid rgba(59, 130, 246, 0.2)';
            }
            
            // Auto-hide after 3 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    element.style.display = 'none';
                }, 3000);
            }
        }

        // Tool filter functionality
        let currentToolsFilter = 'all';
        
        function setToolsFilter(filter) {
            currentToolsFilter = filter;
            
            // Update button styles
            const allBtn = document.getElementById('allToolsBtn');
            const enabledBtn = document.getElementById('enabledToolsBtn');
            
            if (filter === 'all') {
                allBtn.style.background = '#3b82f6';
                enabledBtn.style.background = '';
            } else {
                allBtn.style.background = '';
                enabledBtn.style.background = '#3b82f6';
            }
            
            // Reload categories with filter applied
            loadToolCategories();
        }
        
        async function saveToolsSettings() {
            showMessage('toolsSettingsMessage', 'Tool settings are saved automatically when toggled', 'info');
        }
        
        // Agent Configuration Functions
        async function refreshProvider(providerId) {
            const apiKeyInput = document.getElementById(`${providerId}-api-key`);
            let apiKey = apiKeyInput.value.trim();
            
            // Check if we have a saved API key or a new one
            const savedConfig = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            const hasApiKey = apiKey || (savedConfig[providerId] && savedConfig[providerId].hasApiKey);
            
            if (!hasApiKey) {
                showMessage('agentsSettingsMessage', `Please enter an API key for ${providerId}`, 'warning');
                return;
            }
            
            showMessage('agentsSettingsMessage', `Checking for new ${providerId} models...`, 'info');
            
            // Clear the API key from the input immediately after reading
            if (apiKey) {
                apiKeyInput.value = '';
                // Overwrite the variable
                apiKey = Array(apiKey.length + 1).join('*');
                apiKey = null;
            }
            
            // Simulate API call - in production, this would call the actual API
            setTimeout(() => {
                // Update last update time
                const lastUpdateEl = document.getElementById(`${providerId}-last-update`);
                if (lastUpdateEl) {
                    lastUpdateEl.textContent = `Last checked: ${new Date().toLocaleString()}`;
                    lastUpdateEl.style.display = 'block';
                }
                
                showMessage('agentsSettingsMessage', `${providerId} models are up to date`, 'success');
            }, 1500);
        }

        async function refreshAllProviders() {
            const providers = ['openai', 'anthropic', 'gemini'];
            for (const provider of providers) {
                const checkbox = document.getElementById(`provider-${provider}`);
                if (checkbox && checkbox.checked) {
                    await refreshProvider(provider);
                }
            }
        }

        // Toggle provider section expand/collapse
        function toggleProviderSection(providerId) {
            const section = document.getElementById(`provider-section-${providerId}`);
            if (!section) return;
            
            section.classList.toggle('collapsed');
            
            // Update the arrow icon
            const isCollapsed = section.classList.contains('collapsed');
            const toggle = section.querySelector('.workflow-section-toggle');
            if (toggle) {
                toggle.innerHTML = isCollapsed ? '&#9650;' : '&#9660;';
            }
        }

        // Toggle provider visibility (checkbox)
        function toggleProvider(providerId, enabled) {
            // Just track changes, section visibility is handled by expand/collapse
            trackAgentsSettingsChanges();
        }

        // Track changes
        function trackAgentsSettingsChanges() {
            const saveBtn = document.getElementById('saveAgentsSettingsBtn');
            if (saveBtn) {
                saveBtn.classList.add('has-changes');
            }
        }

        // Save individual provider
        async function saveProviderSettings(providerId) {
            const providers = {};
            
            // Get existing saved configuration to preserve other providers
            const existingConfig = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            
            const checkbox = document.getElementById(`provider-${providerId}`);
            if (!checkbox || !checkbox.checked) {
                showProviderMessage(providerId, 'Please enable the provider first', 'warning');
                return;
            }
            
            const apiKeyInput = document.getElementById(`${providerId}-api-key`);
            const apiKey = apiKeyInput.value.trim();
            const selectedModels = [];
            
            // Get all checked models for this provider
            const modelCheckboxes = document.querySelectorAll(`#${providerId}-models input[type="checkbox"]:checked`);
            modelCheckboxes.forEach(cb => {
                if (cb.value) {
                    selectedModels.push(cb.value);
                }
            });
            
            // Determine if we have a valid API key
            let hasApiKey = false;
            let actualApiKey = '';
            
            if (apiKey) {
                // User entered a new API key
                hasApiKey = true;
                actualApiKey = apiKey;
            } else if (originalProviderStates[providerId] && originalProviderStates[providerId].hasApiKey) {
                // No new API key entered, but there's already a saved one
                hasApiKey = true;
            }
            
            // If no new API key entered, don't validate - let backend handle existing keys
            // This prevents issues with stale localStorage data
            
            if (selectedModels.length === 0) {
                showProviderMessage(providerId, 'Please select at least one model', 'warning');
                return;
            }
            
            // Build provider data
            const providerData = {
                enabled: true,
                hasApiKey: hasApiKey, // Always include this to preserve existing keys
                models: selectedModels
            };
            
            // Only include API key if newly entered
            if (apiKey) {
                providerData.apiKey = actualApiKey;
                providerData.apiKeyHint = actualApiKey.length > 4 ? '****' + actualApiKey.slice(-4) : '****';
            }
            
            providers[providerId] = providerData;
            
            // Save to backend
            try {
                const customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
                const requestData = {
                    providers: { ...existingConfig, ...providers },
                    customProviders: customProviders,
                    updated_at: new Date().toISOString()
                };
                
                const response = await fetchAPI('/api/settings/agents', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (response && response.status === 'success') {
                    // Update status display
                    if (response.data && response.data.providers && response.data.providers[providerId]) {
                        const providerData = response.data.providers[providerId];
                        const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                        
                        if (statusSpan && providerData.apiKeyHint) {
                            statusSpan.innerHTML = `&#10003; Saved ${providerData.apiKeyHint}`;
                            statusSpan.style.display = 'inline';
                        }
                    }
                    
                    // Clear API key input
                    if (apiKey) {
                        apiKeyInput.value = '';
                        apiKeyInput.placeholder = 'API key saved (enter new value to change)';
                        
                        // Clean up any old indicators
                        const parentDiv = apiKeyInput.parentElement;
                        const oldIndicator = parentDiv.querySelector('.api-key-saved-indicator');
                        if (oldIndicator) {
                            oldIndicator.remove();
                        }
                    }
                    
                    // Update localStorage cache
                    const sanitizedProvider = {
                        ...providerData,
                        apiKey: undefined,
                        hasApiKey: true
                    };
                    existingConfig[providerId] = sanitizedProvider;
                    localStorage.setItem('agentConfiguration', JSON.stringify(existingConfig));
                    
                    // Update original provider states to reflect the new saved state
                    if (originalProviderStates[providerId]) {
                        originalProviderStates[providerId].hasApiKey = hasApiKey;
                        originalProviderStates[providerId].models = [...selectedModels];
                        originalProviderStates[providerId].enabled = true;
                    }
                    
                    // Reset change tracking
                    resetProviderChangeState(providerId);
                    
                    showProviderMessage(providerId, 'Provider saved successfully!', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save provider');
                }
                
            } catch (error) {
                console.error('Error saving provider:', error);
                showProviderMessage(providerId, `Failed to save: ${error.message}`, 'error');
            }
        }
        
        // Test provider connection
        async function testProviderConnection(providerId) {
            // Ensure provider tracking is initialized
            if (!providerTrackingInitialized && providerTrackingPromise) {
                try {
                    await providerTrackingPromise;
                } catch (error) {
                    console.error('Failed to wait for provider initialization:', error);
                }
            }
            
            // Check if provider is enabled
            const checkbox = document.getElementById(`provider-${providerId}`);
            if (!checkbox) {
                showProviderMessage(providerId, 'Provider configuration not found', 'error');
                return;
            }
            
            // If checkbox is not checked but we have original state showing it should be enabled,
            // it means the UI hasn't loaded the state yet
            if (!checkbox.checked && originalProviderStates[providerId]?.enabled) {
                // Apply the saved state
                checkbox.checked = true;
            }
            
            if (!checkbox.checked) {
                showProviderMessage(providerId, 'Please enable the provider first', 'warning');
                return;
            }
            
            // Check if API key exists
            const apiKeyInput = document.getElementById(`${providerId}-api-key`);
            const hasNewKey = apiKeyInput.value.trim() !== '';
            
            // Note: We don't check localStorage for existing keys because the backend
            // should have them in the database. We only send new keys entered by the user.
            
            // Let the backend handle checking for existing keys
            // If no new key is entered, the backend will try to use the saved key
            
            showProviderMessage(providerId, 'Testing connection...', 'info');
            
            try {
                const response = await fetchAPI(`/api/test-connection/${providerId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey: apiKeyInput.value.trim() // Send empty string if no new key, backend will use saved key
                    })
                });
                
                if (response && response.status === 'success') {
                    showProviderMessage(providerId, response.message || 'Connection successful!', 'success');
                } else {
                    throw new Error(response?.message || 'Connection failed');
                }
            } catch (error) {
                console.error(`Error testing ${providerId} connection:`, error);
                showProviderMessage(providerId, `Connection test failed: ${error.message}`, 'error');
            }
        }
        
        // Track provider changes
        const providerChanges = {
            openai: { apiKeyChanged: false, modelsChanged: false, enabledChanged: false },
            anthropic: { apiKeyChanged: false, modelsChanged: false, enabledChanged: false },
            gemini: { apiKeyChanged: false, modelsChanged: false, enabledChanged: false }
        };
        
        // Track original provider states
        const originalProviderStates = {};
        
        // Track if initialization is in progress
        let providerTrackingInitialized = false;
        let providerTrackingPromise = null;
        
        // Initialize change tracking for providers
        function initializeProviderChangeTracking() {
            // If already initialized or in progress, return existing promise
            if (providerTrackingInitialized) {
                return Promise.resolve();
            }
            if (providerTrackingPromise) {
                return providerTrackingPromise;
            }
            
            // Create promise for initialization
            providerTrackingPromise = fetchAPI('/api/settings/agents', { method: 'GET' }).then(response => {
                if (response && response.settings && response.settings.providers) {
                    const providers = response.settings.providers;
                    
                    // Apply saved settings to UI
                    for (const providerId in providers) {
                        const config = providers[providerId];
                        
                        // Check the provider checkbox if enabled
                        const checkbox = document.getElementById(`provider-${providerId}`);
                        if (checkbox) {
                            checkbox.checked = config.enabled || false;
                        }
                        
                        // Set API key status if has key
                        if (config.hasApiKey && config.apiKeyHint) {
                            const apiKeyInput = document.getElementById(`${providerId}-api-key`);
                            if (apiKeyInput) {
                                apiKeyInput.placeholder = 'API key saved (enter new value to change)';
                            }
                            
                            const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                            if (statusSpan) {
                                statusSpan.innerHTML = `&#10003; Saved ${config.apiKeyHint}`;
                                statusSpan.style.display = 'inline';
                            }
                        }
                        
                        // Check model checkboxes
                        if (config.models && config.models.length > 0) {
                            config.models.forEach(modelId => {
                                const modelCheckbox = document.getElementById(`model-${providerId}-${modelId}`);
                                if (modelCheckbox) {
                                    modelCheckbox.checked = true;
                                }
                            });
                        }
                        
                        // Store original states
                        originalProviderStates[providerId] = {
                            enabled: config.enabled || false,
                            models: [...(config.models || [])],
                            hasApiKey: config.hasApiKey || false
                        };
                    }
                }
                
                // Add event listeners for OpenAI
                const openaiApiKey = document.getElementById('openai-api-key');
                if (openaiApiKey) {
                    openaiApiKey.addEventListener('input', () => {
                        updateProviderChangeState('openai', 'apiKey', true);
                    });
                }
                
                // Add event listeners for Anthropic
                const anthropicApiKey = document.getElementById('anthropic-api-key');
                if (anthropicApiKey) {
                    anthropicApiKey.addEventListener('input', () => {
                        updateProviderChangeState('anthropic', 'apiKey', true);
                    });
                }
                
                // Add event listeners for Gemini
                const geminiApiKey = document.getElementById('gemini-api-key');
                if (geminiApiKey) {
                    geminiApiKey.addEventListener('input', () => {
                        updateProviderChangeState('gemini', 'apiKey', true);
                    });
                }
                
                // Add listeners for provider enable/disable checkboxes
                ['openai', 'anthropic', 'gemini'].forEach(providerId => {
                    const checkbox = document.getElementById(`provider-${providerId}`);
                    if (checkbox) {
                        checkbox.addEventListener('change', () => {
                            updateProviderChangeState(providerId, 'enabled', true);
                        });
                    }
                    
                    // Add listeners for model checkboxes
                    const modelContainer = document.getElementById(`${providerId}-models`);
                    if (modelContainer) {
                        modelContainer.addEventListener('change', (e) => {
                            if (e.target.type === 'checkbox') {
                                updateProviderChangeState(providerId, 'models', true);
                            }
                        });
                    }
                });
                
                // Mark as initialized
                providerTrackingInitialized = true;
                providerTrackingPromise = null;
            }).catch(error => {
            console.error('Failed to initialize provider tracking:', error);
            providerTrackingPromise = null;
        });
        
        return providerTrackingPromise;
        }
        
        // Update provider change state and button appearances
        function updateProviderChangeState(providerId, changeType, hasChanged) {
            if (changeType === 'apiKey') {
                providerChanges[providerId].apiKeyChanged = hasChanged;
                // Update test connection button
                const testBtn = document.querySelector(`button[onclick="testProviderConnection('${providerId}')"]`);
                if (testBtn) {
                    if (hasChanged) {
                        testBtn.classList.add('has-changes');
                    } else {
                        testBtn.classList.remove('has-changes');
                    }
                }
            } else if (changeType === 'models') {
                providerChanges[providerId].modelsChanged = hasChanged;
            } else if (changeType === 'enabled') {
                providerChanges[providerId].enabledChanged = hasChanged;
            }
            
            // Update save button
            const saveBtn = document.querySelector(`button[onclick="saveProviderSettings('${providerId}')"]`);
            if (saveBtn) {
                const hasAnyChanges = providerChanges[providerId].apiKeyChanged || 
                                    providerChanges[providerId].modelsChanged || 
                                    providerChanges[providerId].enabledChanged;
                if (hasAnyChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                }
            }
        }
        
        // Reset change state after save
        function resetProviderChangeState(providerId) {
            providerChanges[providerId] = { apiKeyChanged: false, modelsChanged: false, enabledChanged: false };
            
            // Reset button states
            const saveBtn = document.querySelector(`button[onclick="saveProviderSettings('${providerId}')"]`);
            if (saveBtn) {
                saveBtn.classList.remove('has-changes');
            }
            
            const testBtn = document.querySelector(`button[onclick="testProviderConnection('${providerId}')"]`);
            if (testBtn) {
                testBtn.classList.remove('has-changes');
            }
        }
        
        // Show message for a specific provider
        function showProviderMessage(providerId, message, type) {
            const messageEl = document.getElementById(`${providerId}-provider-message`);
            if (messageEl) {
                messageEl.textContent = message;
                messageEl.style.display = 'block';
                messageEl.style.backgroundColor = type === 'success' ? '#065f46' : 
                                                   type === 'error' ? '#7f1d1d' : 
                                                   type === 'warning' ? '#78350f' : '#1e40af';
                messageEl.style.color = '#e0e0e0';
                
                // Auto-hide success messages
                if (type === 'success') {
                    setTimeout(() => {
                        messageEl.style.display = 'none';
                    }, 5000);  // Increased to 5 seconds
                }
            }
        }

        // Save configuration (original function for backward compatibility)
        async function saveAgentsSettings() {
            const providers = {};
            
            // Get all provider IDs including custom ones
            const builtInProviders = ['openai', 'anthropic', 'gemini'];
            const customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
            const providerIds = [...builtInProviders, ...customProviders.map(p => p.id)];
            
            // Get existing saved configuration to preserve API keys
            const existingConfig = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            
            // Collect issues for all providers
            const issues = [];
            
            for (const providerId of providerIds) {
                const checkbox = document.getElementById(`provider-${providerId}`);
                if (checkbox && checkbox.checked) {
                    const apiKeyInput = document.getElementById(`${providerId}-api-key`);
                    const apiKey = apiKeyInput.value.trim();
                    const selectedModels = [];
                    
                    // Get all checked models for this provider
                    const modelCheckboxes = document.querySelectorAll(`#${providerId}-models input[type="checkbox"]:checked`);
                    modelCheckboxes.forEach(cb => {
                        if (cb.value) {
                            selectedModels.push(cb.value);
                        }
                    });
                    
                    // Determine if we have a valid API key
                    let hasApiKey = false;
                    let actualApiKey = '';
                    
                    if (apiKey) {
                        // User entered a new API key
                        hasApiKey = true;
                        actualApiKey = apiKey;
                    } else if (existingConfig[providerId] && existingConfig[providerId].hasApiKey) {
                        // Use existing saved API key (don't retrieve it - backend handles this)
                        hasApiKey = true;
                        // Don't set actualApiKey from existingConfig - let backend handle decryption
                    }
                    
                    // Collect issues instead of returning early
                    if (!hasApiKey) {
                        issues.push(`${providerId}: Missing API key`);
                    } else if (selectedModels.length === 0) {
                        issues.push(`${providerId}: No models selected`);
                    } else {
                        // Valid configuration
                        const providerData = {
                            enabled: true,
                            hasApiKey: true,
                            models: selectedModels
                        };
                        
                        // Only include API key if newly entered
                        if (apiKey) {
                            providerData.apiKey = actualApiKey;
                            // Generate hint before clearing
                            providerData.apiKeyHint = actualApiKey.length > 4 ? '****' + actualApiKey.slice(-4) : '****';
                        }
                        
                        providers[providerId] = providerData;
                        
                        // Clear the input and update placeholder only for successfully saved providers
                        if (apiKey) {
                            // Clear input immediately
                            apiKeyInput.value = '';
                            // Overwrite the variable to clear from memory
                            actualApiKey = Array(actualApiKey.length + 1).join('*');
                            actualApiKey = null;
                            
                            apiKeyInput.placeholder = 'API key saved (enter new value to change)';
                        }
                    }
                }
            }
            
            // Show issues if any
            if (issues.length > 0) {
                showMessage('agentsSettingsMessage', 'Please fix the following issues:\n' + issues.join('\n'), 'warning');
                return;
            }
            
            // Save all valid providers to backend
            try {
                // Create a copy for the API request
                const requestData = {
                    providers: { ...existingConfig, ...providers },
                    customProviders: customProviders,
                    updated_at: new Date().toISOString()
                };
                
                const response = await fetchAPI('/api/settings/agents', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (response && response.status === 'success') {
                    // Create a sanitized version for localStorage (without API keys)
                    const sanitizedProviders = {};
                    // Process providers that were sent in this request
                    Object.keys(providers).forEach(providerId => {
                        sanitizedProviders[providerId] = {
                            ...providers[providerId],
                            apiKey: undefined, // Remove API key
                            hasApiKey: providers[providerId].hasApiKey
                        };
                    });
                    
                    // Update status display for ALL providers based on response
                    // This includes providers that were already saved and not changed
                    if (response.data && response.data.providers) {
                        Object.keys(response.data.providers).forEach(providerId => {
                            const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                            const providerData = response.data.providers[providerId];
                            
                            if (statusSpan && providerData.apiKeyHint) {
                                statusSpan.innerHTML = `&#10003; Saved ${providerData.apiKeyHint}`;
                                statusSpan.style.display = 'inline';
                            }
                        });
                    }
                    
                    // Also update status for providers we just saved
                    Object.keys(providers).forEach(providerId => {
                        if (providers[providerId].hasApiKey && providers[providerId].apiKey) {
                            const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                            if (statusSpan && !response.data?.providers?.[providerId]) {
                                // Fallback if not in response
                                const hint = '****' + providers[providerId].apiKey.slice(-4);
                                statusSpan.innerHTML = `&#10003; Saved ${hint}`;
                                statusSpan.style.display = 'inline';
                            }
                        }
                    });
                    
                    // Keep localStorage as cache but without API keys
                    localStorage.setItem('agentConfiguration', JSON.stringify({ ...existingConfig, ...sanitizedProviders }));
                    showMessage('agentsSettingsMessage', 'Agent configuration saved successfully!', 'success');
                } else {
                    throw new Error(response?.message || 'Failed to save agent settings');
                }
                
                // Clear sensitive data from memory
                Object.keys(providers).forEach(providerId => {
                    if (providers[providerId].apiKey) {
                        // Overwrite the API key in memory
                        providers[providerId].apiKey = Array(providers[providerId].apiKey.length + 1).join('*');
                        providers[providerId].apiKey = null;
                    }
                });
                // Clear the requestData object
                if (requestData && requestData.providers) {
                    Object.keys(requestData.providers).forEach(providerId => {
                        if (requestData.providers[providerId].apiKey) {
                            requestData.providers[providerId].apiKey = null;
                        }
                    });
                }
                
                // Clear API key input fields for security
                providerIds.forEach(providerId => {
                    const apiKeyInput = document.getElementById(`${providerId}-api-key`);
                    if (apiKeyInput && apiKeyInput.value) {
                        apiKeyInput.value = '';
                        
                        // Remove any old saved indicators
                        const parentDiv = apiKeyInput.parentElement;
                        const oldIndicator = parentDiv.querySelector('.api-key-saved-indicator');
                        if (oldIndicator) {
                            oldIndicator.remove();
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error saving agent settings:', error);
                showMessage('agentsSettingsMessage', `Failed to save: ${error.message}`, 'error');
                return;
            }
            
            // Reset save button
            const saveBtn = document.getElementById('saveAgentsSettingsBtn');
            if (saveBtn) {
                saveBtn.classList.remove('has-changes');
            }
        }

        // Test selected models
        async function testSelectedModels() {
            const selectedModels = [];
            
            // Collect all selected models
            const modelCheckboxes = document.querySelectorAll('.model-card input[type="checkbox"]:checked');
            modelCheckboxes.forEach(cb => {
                selectedModels.push(cb.value);
            });
            
            if (selectedModels.length === 0) {
                showMessage('agentsSettingsMessage', 'Please select at least one model to test', 'warning');
                return;
            }
            
            showMessage('agentsSettingsMessage', `Testing ${selectedModels.length} selected models...`, 'info');
            
            // Simulate testing
            setTimeout(() => {
                showMessage('agentsSettingsMessage', `Successfully tested ${selectedModels.length} models`, 'success');
            }, 2000);
        }

        // Export configuration
        function exportModelConfig() {
            const config = {
                providers: {},
                timestamp: Date.now(),
                version: '1.0'
            };
            
            // Get saved configuration to check which providers have API keys
            const savedConfig = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            
            ['openai', 'anthropic', 'gemini'].forEach(providerId => {
                const enabled = document.getElementById(`provider-${providerId}`)?.checked;
                const selectedModels = [];
                
                document.querySelectorAll(`#${providerId}-models input[type="checkbox"]:checked`).forEach(cb => {
                    selectedModels.push(cb.value);
                });
                
                config.providers[providerId] = {
                    enabled,
                    selectedModels,
                    // Include indicator that API key exists but don't export the actual key
                    hasApiKey: savedConfig[providerId]?.hasApiKey || false
                };
            });
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-models-config-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showMessage('agentsSettingsMessage', 'Configuration exported successfully (API keys not included for security)', 'success');
        }

        // Import configuration
        function importModelConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const config = JSON.parse(text);
                    
                    // Apply configuration
                    Object.keys(config.providers).forEach(providerId => {
                        const providerConfig = config.providers[providerId];
                        
                        // Set enabled state
                        const checkbox = document.getElementById(`provider-${providerId}`);
                        if (checkbox) {
                            checkbox.checked = providerConfig.enabled;
                            toggleProvider(providerId, providerConfig.enabled);
                        }
                        
                        // Select models
                        providerConfig.selectedModels?.forEach(modelId => {
                            const modelCheckbox = document.querySelector(`#${providerId}-models input[value="${modelId}"]`);
                            if (modelCheckbox) {
                                modelCheckbox.checked = true;
                            }
                        });
                    });
                    
                    showMessage('agentsSettingsMessage', 'Configuration imported successfully', 'success');
                    
                } catch (error) {
                    showMessage('agentsSettingsMessage', 'Failed to import configuration: ' + error.message, 'error');
                }
            };
            input.click();
        }

        // Load saved configuration
        async function loadAgentConfiguration() {
            try {
                // Load from backend API
                const response = await fetchAPI('/api/settings/agents');
                if (response && response.settings) {
                    const settings = response.settings;
                    
                    // Load custom providers if they exist in settings
                    if (settings.customProviders) {
                        settings.customProviders.forEach(provider => {
                            addProviderSectionToUI(provider);
                        });
                    }
                    
                    // Apply agent configuration directly since we may not have applyAgentConfiguration function
                    if (settings.providers) {
                        for (const [providerId, config] of Object.entries(settings.providers)) {
                            const checkbox = document.getElementById(`provider-${providerId}`);
                            if (checkbox) {
                                checkbox.checked = config.enabled;
                                toggleProvider(providerId, config.enabled);
                                
                                // Don't show API keys for security, just indicate they're saved
                                const apiKeyInput = document.getElementById(`${providerId}-api-key`);
                                if (apiKeyInput && config.hasApiKey) {
                                    apiKeyInput.placeholder = 'API key saved (enter new value to change)';
                                    
                                    // Show API key status
                                    const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                                    if (statusSpan && config.apiKeyHint) {
                                        statusSpan.innerHTML = `&#10003; Saved ${config.apiKeyHint}`;
                                        statusSpan.style.display = 'inline';
                                    }
                                    
                                    // Clean up any old indicators
                                    const parentDiv = apiKeyInput.parentElement;
                                    const oldIndicator = parentDiv.querySelector('.api-key-saved-indicator');
                                    if (oldIndicator) {
                                        oldIndicator.remove();
                                    }
                                }
                                
                                // Check the selected models
                                if (config.models) {
                                    config.models.forEach(modelId => {
                                        const modelCheckbox = document.querySelector(`#${providerId}-models input[value="${modelId}"]`);
                                        if (modelCheckbox) {
                                            modelCheckbox.checked = true;
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Initialize provider change tracking after loading configuration
                initializeProviderChangeTracking();
            } catch (error) {
                console.error('Failed to load agent configuration from API, falling back to localStorage:', error);
                // Fallback to localStorage for backward compatibility
                const customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
                customProviders.forEach(provider => {
                    addProviderSectionToUI(provider);
                });
                
                const saved = localStorage.getItem('agentConfiguration');
                if (saved) {
                    const config = JSON.parse(saved);
                    
                    Object.keys(config).forEach(providerId => {
                    const providerConfig = config[providerId];
                    
                    // Enable provider
                    const checkbox = document.getElementById(`provider-${providerId}`);
                    if (checkbox) {
                        checkbox.checked = providerConfig.enabled;
                        toggleProvider(providerId, providerConfig.enabled);
                    }
                    
                    // Handle API keys with security pattern
                    const apiKeyInput = document.getElementById(`${providerId}-api-key`);
                    if (apiKeyInput && providerConfig.hasApiKey) {
                        apiKeyInput.placeholder = 'API key saved (enter new value to change)';
                        apiKeyInput.value = ''; // Clear any existing value
                        
                        // Show API key status using the new status span
                        const statusSpan = document.getElementById(`${providerId}-api-key-status`);
                        if (statusSpan) {
                            statusSpan.innerHTML = `&#10003; Saved ${providerConfig.apiKeyHint || '****'}`;
                            statusSpan.style.display = 'inline';
                        }
                        
                        // Clean up any old indicators
                        const parentDiv = apiKeyInput.parentElement;
                        const oldIndicator = parentDiv.querySelector('.api-key-saved-indicator');
                        if (oldIndicator) {
                            oldIndicator.remove();
                        }
                    }
                    
                    // Check selected models
                    if (providerConfig.models) {
                        providerConfig.models.forEach(modelId => {
                            const modelCheckbox = document.querySelector(`#${providerId}-models input[value="${modelId}"]`);
                            if (modelCheckbox) {
                                modelCheckbox.checked = true;
                            }
                        });
                    }
                });
            }
            
            // Add event listeners for agent configuration
            const providers = ['openai', 'anthropic', 'gemini'];
            
            providers.forEach(provider => {
                const checkbox = document.getElementById(`provider-${provider}`);
                const apiKeyInput = document.getElementById(`${provider}-api-key`);
                
                if (checkbox) {
                    checkbox.addEventListener('change', trackAgentsSettingsChanges);
                }
                if (apiKeyInput) {
                    apiKeyInput.addEventListener('input', function() {
                        trackAgentsSettingsChanges();
                        // Remove saved indicator when user starts typing
                        const indicator = this.parentElement.querySelector('.api-key-saved-indicator');
                        // Also hide the new status span
                        const statusSpan = document.getElementById(`${provider}-api-key-status`);
                        if (statusSpan) {
                            statusSpan.style.display = 'none';
                        }
                        if (indicator) {
                            indicator.remove();
                        }
                    });
                }
            });
            
            // Add change listeners to all model checkboxes
            const modelCheckboxes = document.querySelectorAll('.model-card input[type="checkbox"]');
            modelCheckboxes.forEach(cb => {
                cb.addEventListener('change', trackAgentsSettingsChanges);
            });
            
            // Initialize provider change tracking after loading from localStorage
            initializeProviderChangeTracking();
            }
        }
        
        // Add new provider
        function addNewProvider() {
            showProviderModal();
        }
        
        // Edit provider
        function editProvider(providerId) {
            // Load existing provider data
            const savedConfig = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            const customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
            const provider = customProviders.find(p => p.id === providerId);
            
            if (provider) {
                showProviderModal(provider);
            } else {
                // Built-in provider - show edit limited to description
                showMessage('agentsSettingsMessage', 'Built-in providers can only have their description edited', 'info');
            }
        }
        
        // Delete provider
        async function deleteProvider(providerId) {
            // Check if it's a built-in provider
            const builtInProviders = ['openai', 'anthropic', 'gemini'];
            if (builtInProviders.includes(providerId)) {
                showMessage('agentsSettingsMessage', 'Built-in providers cannot be deleted', 'warning');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete this provider?`)) {
                return;
            }
            
            // Remove from custom providers
            let customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
            customProviders = customProviders.filter(p => p.id !== providerId);
            localStorage.setItem('customProviders', JSON.stringify(customProviders));
            
            // Remove from agent configuration
            const config = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
            delete config[providerId];
            localStorage.setItem('agentConfiguration', JSON.stringify(config));
            
            // Remove the provider section from UI
            const section = document.getElementById(`provider-section-${providerId}`);
            if (section) {
                section.remove();
            }
            
            showMessage('agentsSettingsMessage', 'Provider deleted successfully', 'success');
        }
        
        // Show provider modal
        function showProviderModal(provider = null) {
            let modal = document.getElementById('providerModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'providerModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px;">
                        <div class="modal-header">
                            <h2 id="providerModalTitle">Add AI Provider</h2>
                            <span class="close-button" onclick="closeProviderModal()">&times;</span>
                        </div>
                        <form id="providerForm" onsubmit="saveProvider(event)">
                            <div class="form-group">
                                <label for="providerName">Provider Name</label>
                                <input type="text" id="providerName" name="providerName" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="providerDescription">Description</label>
                                <textarea id="providerDescription" name="providerDescription" rows="3" 
                                          placeholder="Brief description of this AI provider"></textarea>
                            </div>
                            
                            <div class="form-group">
                                <label for="providerApiKey">API Key</label>
                                <input type="password" id="providerApiKey" name="providerApiKey" 
                                       placeholder="Enter API key (optional - can be added later)">
                            </div>
                            
                            <div class="form-group">
                                <label for="providerModelsUrl">Models Documentation URL</label>
                                <input type="url" id="providerModelsUrl" name="providerModelsUrl" 
                                       placeholder="https://example.com/models">
                            </div>
                            
                            <div class="modal-buttons">
                                <button type="button" class="btn-cancel" onclick="closeProviderModal()">Cancel</button>
                                <button type="submit" class="btn-save">Save Provider</button>
                            </div>
                        </form>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            // Reset or populate form
            const form = document.getElementById('providerForm');
            form.reset();
            
            if (provider) {
                document.getElementById('providerModalTitle').textContent = 'Edit AI Provider';
                document.getElementById('providerName').value = provider.name;
                document.getElementById('providerDescription').value = provider.description || '';
                document.getElementById('providerModelsUrl').value = provider.modelsUrl || '';
                form.dataset.providerId = provider.id;
            } else {
                document.getElementById('providerModalTitle').textContent = 'Add AI Provider';
                delete form.dataset.providerId;
            }
            
            modal.style.display = 'block';
        }
        
        // Close provider modal
        function closeProviderModal() {
            const modal = document.getElementById('providerModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Save provider
        async function saveProvider(event) {
            event.preventDefault();
            
            const form = event.target;
            const name = document.getElementById('providerName').value.trim();
            const description = document.getElementById('providerDescription').value.trim();
            const apiKey = document.getElementById('providerApiKey').value.trim();
            const modelsUrl = document.getElementById('providerModelsUrl').value.trim();
            
            // Create provider ID from name
            const providerId = form.dataset.providerId || name.toLowerCase().replace(/[^a-z0-9]/g, '-');
            
            // Load custom providers
            let customProviders = JSON.parse(localStorage.getItem('customProviders') || '[]');
            
            // Check for duplicate names (only for new providers)
            if (!form.dataset.providerId && customProviders.some(p => p.id === providerId)) {
                showMessage('agentsSettingsMessage', 'A provider with this name already exists', 'error');
                return;
            }
            
            // Create or update provider
            const provider = {
                id: providerId,
                name: name,
                description: description,
                modelsUrl: modelsUrl,
                models: []  // Empty initially, user can add models later
            };
            
            if (form.dataset.providerId) {
                // Update existing
                const index = customProviders.findIndex(p => p.id === providerId);
                if (index >= 0) {
                    customProviders[index] = provider;
                }
            } else {
                // Add new
                customProviders.push(provider);
                
                // Add provider section to UI
                addProviderSectionToUI(provider);
            }
            
            // Save custom providers
            localStorage.setItem('customProviders', JSON.stringify(customProviders));
            
            // Save API key if provided
            if (apiKey) {
                const config = JSON.parse(localStorage.getItem('agentConfiguration') || '{}');
                config[providerId] = {
                    enabled: true,
                    hasApiKey: true,
                    apiKey: apiKey,
                    models: []
                };
                localStorage.setItem('agentConfiguration', JSON.stringify(config));
            }
            
            showMessage('agentsSettingsMessage', 'Provider saved successfully', 'success');
            closeProviderModal();
        }
        
        // Add provider section to UI
        function addProviderSectionToUI(provider) {
            const providersList = document.getElementById('providersList');
            const section = document.createElement('div');
            section.className = 'workflow-section';
            section.id = `provider-section-${provider.id}`;
            section.innerHTML = `
                <div class="workflow-section-header" onclick="toggleProviderSection('${provider.id}')">
                    <h4 class="workflow-section-title">${provider.name}</h4>
                    <span class="workflow-section-count">0</span>
                    <span class="workflow-section-toggle">&#9650;</span>
                    <div style="margin-left: auto; display: flex; gap: 10px;">
                        <button class="btn-icon" onclick="event.stopPropagation(); editProvider('${provider.id}')" title="Edit Provider">
                            <span style="font-size: 16px;">&#9998;</span>
                        </button>
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteProvider('${provider.id}')" title="Delete Provider">
                            <span style="font-size: 16px;">&#128465;</span>
                        </button>
                        <button class="btn-icon" onclick="event.stopPropagation(); refreshProvider('${provider.id}')" title="Check for new models">
                            Refresh
                        </button>
                        <label class="toggle-switch" onclick="event.stopPropagation();">
                            <input type="checkbox" id="provider-${provider.id}" onchange="toggleProvider('${provider.id}', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                <div class="workflow-section-content" id="${provider.id}-config">
                    <div style="padding: 15px;">
                        <p style="margin: 0 0 15px 0; color: #999; font-size: 14px;">${provider.description || 'Custom AI provider'}</p>
                        ${provider.modelsUrl ? `<p style="margin: 0 0 15px 0;"><a href="${provider.modelsUrl}" target="_blank" style="color: #3b82f6;">View Models Documentation</a></p>` : ''}
                        <small id="${provider.id}-last-update" style="color: #666; display: none;"></small>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #ccc; font-size: 14px;">API Key</label>
                            <input type="password" id="${provider.id}-api-key" placeholder="Enter API key..." 
                                   style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; 
                                          border-radius: 4px; color: #e0e0e0; font-size: 14px;">
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label style="color: #ccc; font-size: 14px;">Models:</label>
                            <button class="btn-secondary" onclick="addModelToProvider('${provider.id}')" style="margin-left: 10px;">+ Add Model</button>
                        </div>
                        
                        <div id="${provider.id}-models" class="models-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                            <div style="color: #666; padding: 20px; text-align: center;">No models configured yet</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert before the "Additional providers" comment
            const additionalComment = Array.from(providersList.childNodes).find(node => 
                node.nodeType === Node.COMMENT_NODE && node.textContent.includes('Additional providers'));
            if (additionalComment) {
                providersList.insertBefore(section, additionalComment);
            } else {
                providersList.appendChild(section);
            }
        }
        
        
        // View prompt history
        async function viewPromptHistory() {
            try {
                const response = await fetch('/api/prompts/system/history');
                if (!response.ok) {
                    throw new Error('Failed to load history');
                }
                
                const data = await response.json();
                const history = data.history || [];
                
                // Create modal content
                let historyHtml = '<div style="max-height: 400px; overflow-y: auto;">';
                if (history.length === 0) {
                    historyHtml += '<p style="color: #999;">No history available</p>';
                } else {
                    historyHtml += '<table style="width: 100%; border-collapse: collapse;">';
                    historyHtml += '<thead><tr style="border-bottom: 1px solid #444;">';
                    historyHtml += '<th style="padding: 10px; text-align: left;">Version</th>';
                    historyHtml += '<th style="padding: 10px; text-align: left;">Date</th>';
                    historyHtml += '<th style="padding: 10px; text-align: left;">Author</th>';
                    historyHtml += '<th style="padding: 10px; text-align: left;">Notes</th>';
                    historyHtml += '<th style="padding: 10px; text-align: left;">Actions</th>';
                    historyHtml += '</tr></thead><tbody>';
                    
                    for (const entry of history) {
                        historyHtml += '<tr style="border-bottom: 1px solid #333;">';
                        historyHtml += `<td style="padding: 10px;">v${entry.version}</td>`;
                        historyHtml += `<td style="padding: 10px;">${new Date(entry.created_at).toLocaleDateString()}</td>`;
                        historyHtml += `<td style="padding: 10px;">${entry.created_by || 'system'}</td>`;
                        historyHtml += `<td style="padding: 10px;">${entry.change_notes || '-'}</td>`;
                        historyHtml += `<td style="padding: 10px;">`;
                        historyHtml += `<button class="btn-secondary" style="padding: 4px 8px; font-size: 12px; margin-right: 5px;" onclick="viewPromptVersion(${entry.version})">View</button>`;
                        historyHtml += `<button class="btn-secondary" style="padding: 4px 8px; font-size: 12px;" onclick="revertToVersion(${entry.version})">Revert</button>`;
                        historyHtml += `</td>`;
                        historyHtml += '</tr>';
                    }
                    
                    historyHtml += '</tbody></table>';
                }
                historyHtml += '</div>';
                
                // Show in modal
                showModal('Prompt Version History', historyHtml);
                
            } catch (error) {
                console.error('Error loading history:', error);
                showMessage('systemSettingsMessage', 'Failed to load history', 'error');
            }
        }
        
        // View specific version
        async function viewPromptVersion(version) {
            try {
                const response = await fetch(`/api/prompts/system/version/${version}`);
                if (!response.ok) {
                    throw new Error('Failed to load version');
                }
                
                const data = await response.json();
                
                // Show prompt in modal
                const content = `
                    <div>
                        <div style="margin-bottom: 10px;">
                            <strong>Version:</strong> ${data.version}<br>
                            <strong>Created:</strong> ${new Date(data.created_at).toLocaleString()}<br>
                            <strong>Author:</strong> ${data.created_by || 'system'}<br>
                            <strong>Notes:</strong> ${data.change_notes || 'None'}
                        </div>
                        <textarea readonly style="width: 100%; height: 400px; background: #1a1a1a; 
                                                 border: 1px solid #444; color: #e0e0e0; padding: 10px; 
                                                 font-family: monospace; font-size: 13px;">
${data.prompt}
                        </textarea>
                    </div>
                `;
                
                showModal(`Prompt Version ${version}`, content);
                
            } catch (error) {
                console.error('Error loading version:', error);
                showMessage('systemSettingsMessage', 'Failed to load version', 'error');
            }
        }
        
        // Revert to version
        async function revertToVersion(version) {
            if (!confirm(`Are you sure you want to revert to version ${version}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/prompts/system/revert/${version}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        created_by: 'user'
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showMessage('systemSettingsMessage', `Reverted to version ${version} (now version ${result.version})`, 'success');
                    
                    // Reload prompt
                    await loadSystemPrompt();
                    
                    // Close modal if open
                    closeModal();
                } else {
                    const error = await response.json();
                    showMessage('systemSettingsMessage', `Failed to revert: ${error.error}`, 'error');
                }
            } catch (error) {
                console.error('Error reverting version:', error);
                showMessage('systemSettingsMessage', 'Failed to revert version', 'error');
            }
        }
        
        // Export prompt
        async function exportPrompt() {
            try {
                const response = await fetch('/api/prompts/system/export');
                if (!response.ok) {
                    throw new Error('Failed to export prompt');
                }
                
                const data = await response.json();
                
                // Create download
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `system-prompt-v${data.version}-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showMessage('systemSettingsMessage', 'System prompt exported successfully', 'success');
                
            } catch (error) {
                console.error('Error exporting prompt:', error);
                showMessage('systemSettingsMessage', 'Failed to export prompt', 'error');
            }
        }
        
        // Import prompt
        async function importPrompt() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.md,.txt';
            
            input.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const content = await file.text();
                    let prompt = '';
                    
                    if (file.name.endsWith('.json')) {
                        // Parse JSON and extract prompt
                        const data = JSON.parse(content);
                        prompt = data.prompt || data.system_prompt || content;
                    } else {
                        // Plain text or markdown
                        prompt = content;
                    }
                    
                    // Show confirmation
                    if (!confirm('This will create a new version of the system prompt. Continue?')) {
                        return;
                    }
                    
                    // Import via API
                    const response = await fetch('/api/prompts/system/import', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            source: file.name
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        showMessage('systemSettingsMessage', `Prompt imported successfully (Version ${result.version})`, 'success');
                        
                        // Reload prompt
                        await loadSystemPrompt();
                    } else {
                        const error = await response.json();
                        showMessage('systemSettingsMessage', `Failed to import: ${error.error}`, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error importing prompt:', error);
                    showMessage('systemSettingsMessage', 'Failed to import prompt - invalid format', 'error');
                }
            };
            
            input.click();
        }
        
        // Modal helper functions
        function showModal(title, content) {
            // Check if modal exists, create if not
            let modal = document.getElementById('genericModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'genericModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2 id="modalTitle"></h2>
                            <span class="close-button" onclick="closeModal()">&times;</span>
                        </div>
                        <div id="modalBody" style="padding: 20px;">
                            <!-- Content goes here -->
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalBody').innerHTML = content;
            modal.style.display = 'block';
        }
        
        function closeModal() {
            const modal = document.getElementById('genericModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Load system prompt on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Existing initialization code...
            
            // Load system prompt if on system tab
            loadSystemPrompt();
            
            // Initialize provider change tracking
            initializeProviderChangeTracking();
        });
        
        // Edit Persona Instance functionality
        async function loadEditPersonaInstance(instanceId) {
            try {
                // Fetch the persona instance details
                const response = await fetchAPI(`/api/personas/instances/${instanceId}`);
                if (!response || response.status !== 'success') {
                    throw new Error(response?.message || 'Failed to load persona instance');
                }
                
                const instance = response.instance;
                const content = document.getElementById('mainContent');
                
                // Fetch available persona types to get type details
                const typesResponse = await fetchAPI('/api/personas/types');
                const types = typesResponse?.types || [];
                const typeConfig = types.find(t => t.type === instance.persona_type) || {};
                
                // Initialize section expanded states
                if (!window.personaInstanceSectionExpanded) {
                    window.personaInstanceSectionExpanded = {};
                }
                
                // Initialize unsaved changes tracking
                window.personaInstanceHasUnsavedChanges = false;
                window.originalPersonaInstanceData = JSON.stringify({
                    first_name: instance.first_name || '',
                    last_name: instance.last_name || '',
                    email: instance.email || '',
                    skills: instance.skills || [],
                    mcp_servers: instance.mcp_servers || [],
                    tools: instance.tools || []
                });
                
                content.innerHTML = `
                    <div class="edit-persona-instance-container">
                        <div class="edit-header">
                            <h2>Edit Persona Instance: ${instance.full_name}</h2>
                            <span class="persona-type-badge">${typeConfig.display_name || instance.persona_type}</span>
                        </div>
                        
                        <!-- Basic Information Section -->
                        <div class="section-container">
                            <div class="section-header ${window.personaInstanceSectionExpanded['basic'] === false ? 'collapsed' : ''}" 
                                 onclick="togglePersonaInstanceSection('basic')">
                                <span class="section-toggle">${window.personaInstanceSectionExpanded['basic'] === false ? '&#9654;' : '&#9660;'}</span>
                                <h3>Basic Information</h3>
                            </div>
                            <div class="section-content" id="persona-instance-basic-section" 
                                 style="${window.personaInstanceSectionExpanded['basic'] === false ? 'display: none;' : ''}">
                                <div class="form-group">
                                    <label>Instance ID</label>
                                    <input type="text" value="${instance.instance_id}" readonly style="background: #2a2a2a; color: #888;">
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label>First Name</label>
                                        <input type="text" id="instanceFirstName" value="${instance.first_name || ''}" 
                                               placeholder="Enter first name" onchange="trackPersonaInstanceChanges()">
                                    </div>
                                    
                                    <div class="form-group">
                                        <label>Last Name</label>
                                        <input type="text" id="instanceLastName" value="${instance.last_name || ''}" 
                                               placeholder="Enter last name" onchange="trackPersonaInstanceChanges()">
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label>Email</label>
                                    <input type="email" id="instanceEmail" value="${instance.email || ''}" 
                                           placeholder="Enter email address" onchange="trackPersonaInstanceChanges()">
                                </div>
                                
                                <div class="form-group">
                                    <label>Status</label>
                                    <div class="status-info">
                                        <span class="status-indicator status-${instance.is_active ? 'idle' : 'stopped'}"></span>
                                        <span>${instance.is_active ? 'Active' : 'Inactive'}</span>
                                        <button class="btn-secondary" style="margin-left: 20px;" 
                                                onclick="togglePersonaInstanceActive('${instanceId}')">
                                            ${instance.is_active ? 'Deactivate' : 'Activate'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Skills Section -->
                        <div class="section-container">
                            <div class="section-header ${window.personaInstanceSectionExpanded['skills'] === false ? 'collapsed' : ''}" 
                                 onclick="togglePersonaInstanceSection('skills')">
                                <span class="section-toggle">${window.personaInstanceSectionExpanded['skills'] === false ? '&#9654;' : '&#9660;'}</span>
                                <h3>Skills</h3>
                            </div>
                            <div class="section-content" id="persona-instance-skills-section" 
                                 style="${window.personaInstanceSectionExpanded['skills'] === false ? 'display: none;' : ''}">
                                <div class="skills-container">
                                    <div id="instanceSkillsList" class="skills-list">
                                        ${(instance.skills || []).map(skill => `
                                            <span class="skill-tag">
                                                ${skill}
                                                <span class="remove-skill" onclick="removeInstanceSkill('${skill}')">&times;</span>
                                            </span>
                                        `).join('')}
                                    </div>
                                    <div class="add-skill-container">
                                        <input type="text" id="newInstanceSkill" placeholder="Add a skill" 
                                               onkeypress="if(event.key==='Enter') addInstanceSkill()">
                                        <button class="btn-primary" onclick="addInstanceSkill()">Add</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- MCP Servers Section -->
                        <div class="section-container">
                            <div class="section-header ${window.personaInstanceSectionExpanded['mcp'] === false ? 'collapsed' : ''}" 
                                 onclick="togglePersonaInstanceSection('mcp')">
                                <span class="section-toggle">${window.personaInstanceSectionExpanded['mcp'] === false ? '&#9654;' : '&#9660;'}</span>
                                <h3>MCP Servers</h3>
                            </div>
                            <div class="section-content" id="persona-instance-mcp-section" 
                                 style="${window.personaInstanceSectionExpanded['mcp'] === false ? 'display: none;' : ''}">
                                <div id="instanceMcpServersList">
                                    Loading MCP servers...
                                </div>
                            </div>
                        </div>
                        
                        <!-- Tools Section -->
                        <div class="section-container">
                            <div class="section-header ${window.personaInstanceSectionExpanded['tools'] === false ? 'collapsed' : ''}" 
                                 onclick="togglePersonaInstanceSection('tools')">
                                <span class="section-toggle">${window.personaInstanceSectionExpanded['tools'] === false ? '&#9654;' : '&#9660;'}</span>
                                <h3>Tools</h3>
                            </div>
                            <div class="section-content" id="persona-instance-tools-section" 
                                 style="${window.personaInstanceSectionExpanded['tools'] === false ? 'display: none;' : ''}">
                                <div class="tools-search-container" style="margin-bottom: 15px;">
                                    <input type="text" id="instanceToolsSearch" placeholder="Search tools..." 
                                           oninput="filterInstanceTools()" style="width: 100%;">
                                </div>
                                <div id="instanceToolsList">
                                    Loading tools...
                                </div>
                            </div>
                        </div>
                        
                        <!-- Metrics Section -->
                        <div class="section-container">
                            <div class="section-header ${window.personaInstanceSectionExpanded['metrics'] === false ? 'collapsed' : ''}" 
                                 onclick="togglePersonaInstanceSection('metrics')">
                                <span class="section-toggle">${window.personaInstanceSectionExpanded['metrics'] === false ? '&#9654;' : '&#9660;'}</span>
                                <h3>Metrics</h3>
                            </div>
                            <div class="section-content" id="persona-instance-metrics-section" 
                                 style="${window.personaInstanceSectionExpanded['metrics'] === false ? 'display: none;' : ''}">
                                ${renderInstanceMetrics(instance.metrics)}
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="action-buttons" style="margin-top: 30px;">
                            <button class="btn-primary save-btn ${window.personaInstanceHasUnsavedChanges ? 'has-changes' : ''}" 
                                    id="savePersonaInstanceBtn" onclick="savePersonaInstance('${instanceId}')">
                                Save Changes
                            </button>
                            <button class="btn-secondary" onclick="deletePersonaInstance('${instanceId}')">
                                Delete Instance
                            </button>
                            <button class="btn-secondary" onclick="showSystemLogs()">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
                
                // Load MCP servers
                await loadInstanceMCPServers(instance.mcp_servers || []);
                
                // Load tools
                await loadInstanceTools(instance.tools || []);
                
                // Store current instance data globally
                window.currentEditingInstance = instanceId;
                
            } catch (error) {
                console.error('Failed to load persona instance:', error);
                showNotification(`Failed to load persona instance: ${error.message}`, 'error');
            }
        }
        
        // Toggle section expand/collapse for persona instance
        function togglePersonaInstanceSection(section) {
            const isExpanded = window.personaInstanceSectionExpanded[section] !== false;
            window.personaInstanceSectionExpanded[section] = !isExpanded;
            
            const header = document.querySelector(`[onclick="togglePersonaInstanceSection('${section}')"]`);
            const content = document.getElementById(`persona-instance-${section}-section`);
            
            if (header) {
                header.classList.toggle('collapsed');
                const toggle = header.querySelector('.section-toggle');
                if (toggle) {
                    toggle.textContent = window.personaInstanceSectionExpanded[section] ? '&#9660;' : '&#9654;';
                }
            }
            
            if (content) {
                content.style.display = window.personaInstanceSectionExpanded[section] ? 'block' : 'none';
            }
        }
        
        // Track changes for persona instance
        function trackPersonaInstanceChanges() {
            const currentData = {
                first_name: document.getElementById('instanceFirstName').value,
                last_name: document.getElementById('instanceLastName').value,
                email: document.getElementById('instanceEmail').value,
                skills: getCurrentInstanceSkills(),
                mcp_servers: getSelectedInstanceMCPServers(),
                tools: getSelectedInstanceTools()
            };
            
            window.personaInstanceHasUnsavedChanges = 
                JSON.stringify(currentData) !== window.originalPersonaInstanceData;
            
            const saveBtn = document.getElementById('savePersonaInstanceBtn');
            if (saveBtn) {
                if (window.personaInstanceHasUnsavedChanges) {
                    saveBtn.classList.add('has-changes');
                } else {
                    saveBtn.classList.remove('has-changes');
                }
            }
        }
        
        // Skills management for instance
        function getCurrentInstanceSkills() {
            const skills = [];
            document.querySelectorAll('#instanceSkillsList .skill-tag').forEach(tag => {
                const skillText = tag.textContent.replace('&times;', '').trim();
                if (skillText) skills.push(skillText);
            });
            return skills;
        }
        
        function addInstanceSkill() {
            const input = document.getElementById('newInstanceSkill');
            const skill = input.value.trim();
            
            if (skill) {
                const currentSkills = getCurrentInstanceSkills();
                if (!currentSkills.includes(skill)) {
                    currentSkills.push(skill);
                    displayInstanceSkills(currentSkills);
                    input.value = '';
                    trackPersonaInstanceChanges();
                }
            }
        }
        
        function removeInstanceSkill(skill) {
            const currentSkills = getCurrentInstanceSkills().filter(s => s !== skill);
            displayInstanceSkills(currentSkills);
            trackPersonaInstanceChanges();
        }
        
        function displayInstanceSkills(skills) {
            const container = document.getElementById('instanceSkillsList');
            container.innerHTML = skills.map(skill => `
                <span class="skill-tag">
                    ${skill}
                    <span class="remove-skill" onclick="removeInstanceSkill('${skill}')">&times;</span>
                </span>
            `).join('');
        }
        
        // Load MCP servers for instance
        async function loadInstanceMCPServers(selectedServers) {
            try {
                const response = await fetchAPI('/api/mcp-servers');
                const servers = response?.servers || [];
                
                const container = document.getElementById('instanceMcpServersList');
                container.innerHTML = servers.map(server => `
                    <div class="mcp-server-item">
                        <label class="checkbox-label">
                            <input type="checkbox" 
                                   id="instance-mcp-${server.name}" 
                                   value="${server.name}"
                                   ${selectedServers.includes(server.name) ? 'checked' : ''}
                                   onchange="trackPersonaInstanceChanges()">
                            <span>${server.displayName}</span>
                        </label>
                        <span class="mcp-description">${server.description}</span>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Failed to load MCP servers:', error);
                document.getElementById('instanceMcpServersList').innerHTML = 
                    '<div style="color: #ef4444;">Failed to load MCP servers</div>';
            }
        }
        
        // Get selected MCP servers for instance
        function getSelectedInstanceMCPServers() {
            const selected = [];
            document.querySelectorAll('#instanceMcpServersList input[type="checkbox"]:checked').forEach(cb => {
                selected.push(cb.value);
            });
            return selected;
        }
        
        // Load tools for instance
        async function loadInstanceTools(selectedTools) {
            try {
                const response = await fetchAPI('/api/tools/categories');
                const categories = response?.categories || [];
                
                window.instanceAllTools = [];
                categories.forEach(category => {
                    category.tools.forEach(tool => {
                        window.instanceAllTools.push({
                            name: tool.name,
                            displayName: tool.displayName,
                            category: category.displayName,
                            categoryName: category.name,
                            selected: selectedTools.includes(tool.name)
                        });
                    });
                });
                
                displayInstanceTools(window.instanceAllTools);
            } catch (error) {
                console.error('Failed to load tools:', error);
                document.getElementById('instanceToolsList').innerHTML = 
                    '<div style="color: #ef4444;">Failed to load tools</div>';
            }
        }
        
        // Display tools for instance
        function displayInstanceTools(tools) {
            const container = document.getElementById('instanceToolsList');
            
            // Group tools by category
            const groupedTools = {};
            tools.forEach(tool => {
                if (!groupedTools[tool.categoryName]) {
                    groupedTools[tool.categoryName] = {
                        display: tool.category,
                        tools: []
                    };
                }
                groupedTools[tool.categoryName].tools.push(tool);
            });
            
            container.innerHTML = Object.entries(groupedTools).map(([categoryName, category]) => `
                <div class="tool-category">
                    <h4>${category.display}</h4>
                    <div class="tools-grid">
                        ${category.tools.map(tool => `
                            <label class="tool-item">
                                <input type="checkbox" 
                                       value="${tool.name}"
                                       ${tool.selected ? 'checked' : ''}
                                       onchange="trackPersonaInstanceChanges()">
                                <span>${tool.displayName}</span>
                            </label>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        // Filter tools for instance
        function filterInstanceTools() {
            const searchTerm = document.getElementById('instanceToolsSearch').value.toLowerCase();
            
            if (!searchTerm) {
                displayInstanceTools(window.instanceAllTools);
                return;
            }
            
            const filteredTools = window.instanceAllTools.filter(tool => 
                tool.displayName.toLowerCase().includes(searchTerm) ||
                tool.category.toLowerCase().includes(searchTerm)
            );
            
            displayInstanceTools(filteredTools);
        }
        
        // Get selected tools for instance
        function getSelectedInstanceTools() {
            const selected = [];
            document.querySelectorAll('#instanceToolsList input[type="checkbox"]:checked').forEach(cb => {
                selected.push(cb.value);
            });
            return selected;
        }
        
        // Render instance metrics
        function renderInstanceMetrics(metrics) {
            if (!metrics) {
                return '<div style="color: #666;">No metrics available yet</div>';
            }
            
            return `
                <div class="metrics-grid">
                    <div class="metric-item">
                        <label>Work Items Processed</label>
                        <div class="metric-value">${metrics.work_items_processed || 0}</div>
                    </div>
                    <div class="metric-item">
                        <label>Average Processing Time</label>
                        <div class="metric-value">${metrics.avg_processing_time || 'N/A'}</div>
                    </div>
                    <div class="metric-item">
                        <label>Success Rate</label>
                        <div class="metric-value">${metrics.success_rate || 'N/A'}</div>
                    </div>
                    <div class="metric-item">
                        <label>Last Active</label>
                        <div class="metric-value">${metrics.last_active || 'Never'}</div>
                    </div>
                </div>
            `;
        }
        
        // Toggle persona instance active state
        async function togglePersonaInstanceActive(instanceId) {
            try {
                const response = await fetchAPI(`/api/personas/instances/${instanceId}/toggle`, {
                    method: 'POST'
                });
                
                if (response && response.status === 'success') {
                    showNotification(response.message, 'success');
                    // Reload the instance data
                    await loadEditPersonaInstance(instanceId);
                } else {
                    throw new Error(response?.message || 'Failed to toggle instance state');
                }
            } catch (error) {
                console.error('Failed to toggle instance:', error);
                showNotification(`Failed to toggle instance: ${error.message}`, 'error');
            }
        }
        
        // Save persona instance
        async function savePersonaInstance(instanceId) {
            try {
                const data = {
                    first_name: document.getElementById('instanceFirstName').value,
                    last_name: document.getElementById('instanceLastName').value,
                    email: document.getElementById('instanceEmail').value,
                    skills: getCurrentInstanceSkills(),
                    mcp_servers: getSelectedInstanceMCPServers(),
                    tools: getSelectedInstanceTools()
                };
                
                const response = await fetchAPI(`/api/personas/instances/${instanceId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response && response.status === 'success') {
                    showNotification('Persona instance saved successfully', 'success');
                    window.personaInstanceHasUnsavedChanges = false;
                    window.originalPersonaInstanceData = JSON.stringify(data);
                    
                    const saveBtn = document.getElementById('savePersonaInstanceBtn');
                    if (saveBtn) {
                        saveBtn.classList.remove('has-changes');
                    }
                    
                    // Update the dashboard
                    await updateDashboard();
                } else {
                    throw new Error(response?.message || 'Failed to save instance');
                }
            } catch (error) {
                console.error('Failed to save instance:', error);
                showNotification(`Failed to save instance: ${error.message}`, 'error');
            }
        }
        
        // Helper functions for Edit Persona Instance
        function getCurrentInstanceSkills() {
            const skillsList = document.getElementById('instanceSkillsList');
            if (!skillsList) return [];
            
            const skills = [];
            skillsList.querySelectorAll('.skill-item').forEach(item => {
                skills.push(item.textContent.replace('&times;', '').trim());
            });
            return skills;
        }
        
        function getSelectedInstanceMCPServers() {
            const servers = [];
            document.querySelectorAll('#instanceMCPServersList input[type="checkbox"]:checked').forEach(checkbox => {
                servers.push(checkbox.value);
            });
            return servers;
        }
        
        function getSelectedInstanceTools() {
            const tools = [];
            document.querySelectorAll('#instanceToolsList input[type="checkbox"]:checked').forEach(checkbox => {
                tools.push(checkbox.value);
            });
            return tools;
        }
        
        // Delete persona instance
        async function deletePersonaInstance(instanceId) {
            if (!confirm('Are you sure you want to delete this persona instance? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetchAPI(`/api/personas/instances/${instanceId}`, {
                    method: 'DELETE'
                });
                
                if (response && response.status === 'success') {
                    showNotification('Persona instance deleted successfully', 'success');
                    // Return to main dashboard
                    document.getElementById('content').innerHTML = '';
                    selectedSection = null;
                    selectedPersona = null;
                    // Update the dashboard
                    await updateDashboard();
                } else {
                    throw new Error(response?.message || 'Failed to delete instance');
                }
            } catch (error) {
                console.error('Failed to delete instance:', error);
                showNotification(`Failed to delete instance: ${error.message}`, 'error');
            }
        }
    </script>
    
    <!-- Persona Edit Modal -->
    <div id="personaEditModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Edit Persona</h2>
                <span class="close-button" onclick="closePersonaModal()">&times;</span>
            </div>
            <form id="personaEditForm">
                <input type="hidden" id="personaId" />
                
                <div class="form-group">
                    <label for="firstName">First Name</label>
                    <input type="text" id="firstName" name="firstName" required />
                </div>
                
                <div class="form-group">
                    <label for="lastName">Last Name</label>
                    <input type="text" id="lastName" name="lastName" required />
                </div>
                
                <div class="form-group">
                    <label for="email">Email Address</label>
                    <input type="email" id="email" name="email" required />
                </div>
                
                <div class="form-group">
                    <label for="role">Role</label>
                    <input type="text" id="role" name="role" required />
                </div>
                
                <div class="form-group">
                    <label>Skills</label>
                    <div class="skills-container">
                        <div class="skills-tags" id="skillsTags">
                            <!-- Skills will be dynamically added here -->
                        </div>
                        <div class="add-skill-container">
                            <input type="text" class="add-skill-input" id="newSkillInput" placeholder="Add a new skill..." />
                            <button type="button" class="add-skill-btn" onclick="addSkill()">Add</button>
                        </div>
                    </div>
                </div>
                
                <div class="modal-buttons">
                    <button type="button" class="btn-cancel" onclick="closePersonaModal()">Cancel</button>
                    <button type="button" class="btn-save" onclick="savePersona()">Save</button>
                </div>
            </form>
        </div>
    </div>
</body>
</html>
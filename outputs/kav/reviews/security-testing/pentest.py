#!/usr/bin/env python3
"""
Automated Penetration Testing Script for Trivia Application
Author: Kav (Security Test Engineer)
"""

import requests
import json
import time
import sys
from typing import Dict, List, Any
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class TriviaAppPentest:
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.vulnerabilities = []
        self.test_results = {
            'total_tests': 0,
            'passed': 0,
            'failed': 0,
            'vulnerabilities': []
        }
    
    def log(self, message: str, level: str = "INFO"):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
    
    def add_vulnerability(self, vuln: Dict[str, Any]):
        self.vulnerabilities.append(vuln)
        self.test_results['vulnerabilities'].append(vuln)
        self.test_results['failed'] += 1
        self.log(f"VULNERABILITY FOUND: {vuln['title']}", "ERROR")
    
    def test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        self.log("Testing for SQL injection vulnerabilities...")
        
        sql_payloads = [
            "' OR '1'='1",
            "1' OR '1' = '1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "1' UNION SELECT NULL--",
            "' UNION SELECT username, password FROM users--"
        ]
        
        endpoints = [
            ("/api/auth/login", "POST", {"email": "test@test.com", "password": ""}),
            ("/api/users", "GET", {"search": ""}),
            ("/api/games", "GET", {"category": ""})
        ]
        
        for endpoint, method, params in endpoints:
            for payload in sql_payloads:
                # Inject payload into each parameter
                for param in params:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        if method == "POST":
                            response = self.session.post(
                                f"{self.base_url}{endpoint}",
                                json=test_params,
                                timeout=5
                            )
                        else:
                            response = self.session.get(
                                f"{self.base_url}{endpoint}",
                                params=test_params,
                                timeout=5
                            )
                        
                        # Check for SQL error messages
                        error_patterns = [
                            "SQL syntax",
                            "mysql_fetch",
                            "Warning: mysql",
                            "PostgreSQL",
                            "valid MySQL result",
                            "mssql_",
                            "ORA-01756"
                        ]
                        
                        response_text = response.text.lower()
                        for pattern in error_patterns:
                            if pattern.lower() in response_text:
                                self.add_vulnerability({
                                    'title': 'SQL Injection',
                                    'severity': 'CRITICAL',
                                    'endpoint': f"{method} {endpoint}",
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"SQL error pattern '{pattern}' found in response"
                                })
                                break
                        
                        # Check for successful bypass
                        if response.status_code == 200 and method == "POST" and endpoint == "/api/auth/login":
                            if "token" in response_text or "access_token" in response_text:
                                self.add_vulnerability({
                                    'title': 'SQL Injection - Authentication Bypass',
                                    'severity': 'CRITICAL',
                                    'endpoint': f"{method} {endpoint}",
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': "Authentication bypassed with SQL injection"
                                })
                    
                    except Exception as e:
                        self.log(f"Error testing {endpoint}: {str(e)}", "WARNING")
        
        self.test_results['total_tests'] += len(endpoints) * len(sql_payloads)
    
    def test_xss(self):
        """Test for Cross-Site Scripting vulnerabilities"""
        self.log("Testing for XSS vulnerabilities...")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src='javascript:alert(`XSS`)'></iframe>",
            "'><script>alert(String.fromCharCode(88,83,83))</script>",
            "<input onfocus=alert('XSS') autofocus>",
            "<details open ontoggle=alert('XSS')>"
        ]
        
        endpoints = [
            ("/api/users/profile", "PUT", {"bio": ""}),
            ("/api/games/create", "POST", {"name": "", "description": ""}),
            ("/api/comments", "POST", {"text": ""})
        ]
        
        for endpoint, method, params in endpoints:
            for payload in xss_payloads:
                for param in params:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        # First, try to inject the payload
                        if method == "POST":
                            response = self.session.post(
                                f"{self.base_url}{endpoint}",
                                json=test_params,
                                timeout=5
                            )
                        elif method == "PUT":
                            response = self.session.put(
                                f"{self.base_url}{endpoint}",
                                json=test_params,
                                timeout=5
                            )
                        
                        # Check if payload is reflected without encoding
                        if payload in response.text:
                            self.add_vulnerability({
                                'title': 'Reflected XSS',
                                'severity': 'HIGH',
                                'endpoint': f"{method} {endpoint}",
                                'parameter': param,
                                'payload': payload,
                                'evidence': "Payload reflected in response without encoding"
                            })
                    
                    except Exception as e:
                        self.log(f"Error testing XSS on {endpoint}: {str(e)}", "WARNING")
        
        self.test_results['total_tests'] += len(endpoints) * len(xss_payloads)
    
    def test_authentication(self):
        """Test authentication security"""
        self.log("Testing authentication security...")
        
        # Test weak password policy
        weak_passwords = ["123456", "password", "12345678", "qwerty", "abc123"]
        
        for password in weak_passwords:
            try:
                response = self.session.post(
                    f"{self.base_url}/api/auth/register",
                    json={
                        "email": f"test{time.time()}@test.com",
                        "password": password,
                        "username": f"testuser{int(time.time())}"
                    }
                )
                
                if response.status_code == 201:
                    self.add_vulnerability({
                        'title': 'Weak Password Policy',
                        'severity': 'MEDIUM',
                        'endpoint': 'POST /api/auth/register',
                        'evidence': f"Weak password '{password}' accepted"
                    })
                    break
            except:
                pass
        
        # Test for timing attacks on login
        valid_email = "admin@trivia.com"
        invalid_email = "nonexistent@trivia.com"
        
        valid_times = []
        invalid_times = []
        
        for _ in range(5):
            # Test valid email
            start = time.time()
            self.session.post(
                f"{self.base_url}/api/auth/login",
                json={"email": valid_email, "password": "wrongpassword"}
            )
            valid_times.append(time.time() - start)
            
            # Test invalid email
            start = time.time()
            self.session.post(
                f"{self.base_url}/api/auth/login",
                json={"email": invalid_email, "password": "wrongpassword"}
            )
            invalid_times.append(time.time() - start)
        
        avg_valid = sum(valid_times) / len(valid_times)
        avg_invalid = sum(invalid_times) / len(invalid_times)
        
        if abs(avg_valid - avg_invalid) > 0.1:  # 100ms difference
            self.add_vulnerability({
                'title': 'Username Enumeration via Timing Attack',
                'severity': 'MEDIUM',
                'endpoint': 'POST /api/auth/login',
                'evidence': f"Valid user: {avg_valid:.3f}s, Invalid user: {avg_invalid:.3f}s"
            })
        
        self.test_results['total_tests'] += len(weak_passwords) + 10
    
    def test_authorization(self):
        """Test authorization and access control"""
        self.log("Testing authorization and access control...")
        
        # Create two test users
        user1_creds = {
            "email": f"user1_{time.time()}@test.com",
            "password": "TestPassword123!",
            "username": f"user1_{int(time.time())}"
        }
        
        user2_creds = {
            "email": f"user2_{time.time()}@test.com",
            "password": "TestPassword123!",
            "username": f"user2_{int(time.time())}"
        }
        
        # Register users
        self.session.post(f"{self.base_url}/api/auth/register", json=user1_creds)
        self.session.post(f"{self.base_url}/api/auth/register", json=user2_creds)
        
        # Login as user1
        response = self.session.post(
            f"{self.base_url}/api/auth/login",
            json={"email": user1_creds["email"], "password": user1_creds["password"]}
        )
        
        if response.status_code == 200:
            user1_token = response.json().get("access_token")
            user1_id = response.json().get("user_id")
            
            # Login as user2
            response = self.session.post(
                f"{self.base_url}/api/auth/login",
                json={"email": user2_creds["email"], "password": user2_creds["password"]}
            )
            
            if response.status_code == 200:
                user2_id = response.json().get("user_id")
                
                # Test IDOR - Try to access user2's data with user1's token
                headers = {"Authorization": f"Bearer {user1_token}"}
                
                idor_endpoints = [
                    f"/api/users/{user2_id}",
                    f"/api/users/{user2_id}/profile",
                    f"/api/users/{user2_id}/games",
                    f"/api/users/{user2_id}/settings"
                ]
                
                for endpoint in idor_endpoints:
                    try:
                        response = self.session.get(
                            f"{self.base_url}{endpoint}",
                            headers=headers
                        )
                        
                        if response.status_code == 200:
                            self.add_vulnerability({
                                'title': 'Insecure Direct Object Reference (IDOR)',
                                'severity': 'HIGH',
                                'endpoint': f"GET {endpoint}",
                                'evidence': "Accessed another user's data without authorization"
                            })
                    except:
                        pass
        
        self.test_results['total_tests'] += 4
    
    def test_api_security(self):
        """Test API security configurations"""
        self.log("Testing API security configurations...")
        
        # Test for missing security headers
        response = self.session.get(f"{self.base_url}/api/health")
        
        security_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
            'X-XSS-Protection': '1; mode=block',
            'Strict-Transport-Security': 'max-age=',
            'Content-Security-Policy': None
        }
        
        for header, expected_values in security_headers.items():
            if header not in response.headers:
                self.add_vulnerability({
                    'title': f'Missing Security Header: {header}',
                    'severity': 'MEDIUM',
                    'endpoint': 'ALL',
                    'evidence': f"Security header '{header}' is missing"
                })
            elif expected_values:
                header_value = response.headers[header]
                if isinstance(expected_values, list):
                    if not any(val in header_value for val in expected_values):
                        self.add_vulnerability({
                            'title': f'Weak Security Header: {header}',
                            'severity': 'LOW',
                            'endpoint': 'ALL',
                            'evidence': f"Header value '{header_value}' is weak"
                        })
                elif expected_values and expected_values not in header_value:
                    self.add_vulnerability({
                        'title': f'Weak Security Header: {header}',
                        'severity': 'LOW',
                        'endpoint': 'ALL',
                        'evidence': f"Header value '{header_value}' is weak"
                    })
        
        # Test for rate limiting
        endpoint = "/api/auth/login"
        start_time = time.time()
        request_count = 0
        
        for _ in range(100):
            try:
                response = self.session.post(
                    f"{self.base_url}{endpoint}",
                    json={"email": "test@test.com", "password": "wrong"},
                    timeout=1
                )
                request_count += 1
                
                if response.status_code == 429:
                    break
            except:
                pass
        
        elapsed_time = time.time() - start_time
        
        if request_count == 100:
            self.add_vulnerability({
                'title': 'Missing Rate Limiting',
                'severity': 'MEDIUM',
                'endpoint': endpoint,
                'evidence': f"Sent {request_count} requests in {elapsed_time:.2f}s without rate limiting"
            })
        
        self.test_results['total_tests'] += len(security_headers) + 1
    
    def test_business_logic(self):
        """Test for business logic vulnerabilities"""
        self.log("Testing business logic vulnerabilities...")
        
        # Test negative values
        negative_value_endpoints = [
            ("/api/games/score", "POST", {"score": -1000}),
            ("/api/shop/purchase", "POST", {"quantity": -5}),
            ("/api/transfer", "POST", {"amount": -100})
        ]
        
        for endpoint, method, data in negative_value_endpoints:
            try:
                response = self.session.request(
                    method,
                    f"{self.base_url}{endpoint}",
                    json=data
                )
                
                if response.status_code in [200, 201]:
                    self.add_vulnerability({
                        'title': 'Business Logic Flaw - Negative Value Accepted',
                        'severity': 'HIGH',
                        'endpoint': f"{method} {endpoint}",
                        'evidence': f"Negative value {data} was accepted"
                    })
            except:
                pass
        
        self.test_results['total_tests'] += len(negative_value_endpoints)
    
    def generate_report(self):
        """Generate penetration test report"""
        report = f"""
# Penetration Test Report - Trivia Application
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary
Total Tests Performed: {self.test_results['total_tests']}
Vulnerabilities Found: {len(self.vulnerabilities)}

### Severity Distribution:
- CRITICAL: {len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL'])}
- HIGH: {len([v for v in self.vulnerabilities if v['severity'] == 'HIGH'])}
- MEDIUM: {len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM'])}
- LOW: {len([v for v in self.vulnerabilities if v['severity'] == 'LOW'])}

## Detailed Findings

"""
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            report += f"""
### {i}. {vuln['title']}
**Severity**: {vuln['severity']}
**Endpoint**: {vuln.get('endpoint', 'N/A')}
**Evidence**: {vuln['evidence']}
{f"**Payload**: {vuln.get('payload', 'N/A')}" if 'payload' in vuln else ''}

"""
        
        report += """
## Recommendations

1. **SQL Injection**: Implement parameterized queries and input validation
2. **XSS**: Enable Content Security Policy and output encoding
3. **Authentication**: Implement stronger password policies and MFA
4. **Authorization**: Fix IDOR vulnerabilities with proper access controls
5. **API Security**: Add missing security headers and rate limiting
6. **Business Logic**: Validate all input values including edge cases

## Testing Methodology
- OWASP Testing Guide v4.2
- Manual and automated testing
- Black box approach
- Focus on OWASP Top 10

"""
        
        return report
    
    def run_all_tests(self):
        """Run all penetration tests"""
        self.log("Starting penetration test suite...")
        
        test_methods = [
            self.test_sql_injection,
            self.test_xss,
            self.test_authentication,
            self.test_authorization,
            self.test_api_security,
            self.test_business_logic
        ]
        
        for test_method in test_methods:
            try:
                test_method()
            except Exception as e:
                self.log(f"Error in {test_method.__name__}: {str(e)}", "ERROR")
        
        report = self.generate_report()
        
        # Save report
        with open("pentest_report.md", "w") as f:
            f.write(report)
        
        self.log(f"Penetration test completed. Found {len(self.vulnerabilities)} vulnerabilities.")
        return report

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python pentest.py <base_url>")
        sys.exit(1)
    
    base_url = sys.argv[1]
    tester = TriviaAppPentest(base_url)
    tester.run_all_tests()
